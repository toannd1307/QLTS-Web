/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.4.2.0 (NJsonSchema v10.1.11.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

import * as moment from 'moment';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class AccountServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    isTenantAvailable(body: IsTenantAvailableInput | undefined): Observable<IsTenantAvailableOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/IsTenantAvailable";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsTenantAvailable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsTenantAvailable(<any>response_);
                } catch (e) {
                    return <Observable<IsTenantAvailableOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<IsTenantAvailableOutput>><any>_observableThrow(response_);
        }));
    }

    protected processIsTenantAvailable(response: HttpResponseBase): Observable<IsTenantAvailableOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IsTenantAvailableOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IsTenantAvailableOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    register(body: RegisterInput | undefined): Observable<RegisterOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/Register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegister(<any>response_);
                } catch (e) {
                    return <Observable<RegisterOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<RegisterOutput>><any>_observableThrow(response_);
        }));
    }

    protected processRegister(response: HttpResponseBase): Observable<RegisterOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RegisterOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RegisterOutput>(<any>null);
    }
}

@Injectable()
export class AngTenRFIDServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param tenTS (optional) 
     * @param phongBanSuDung (optional) 
     * @param tinhTrangSuDung (optional) 
     * @param isSearch (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(tenTS: string | null | undefined, phongBanSuDung: number[] | null | undefined, tinhTrangSuDung: number | null | undefined, isSearch: boolean | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<GetAllOutputDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/AngTenRFID/GetAll?";
        if (tenTS !== undefined)
            url_ += "TenTS=" + encodeURIComponent("" + tenTS) + "&";
        if (phongBanSuDung !== undefined)
            phongBanSuDung && phongBanSuDung.forEach(item => { url_ += "PhongBanSuDung=" + encodeURIComponent("" + item) + "&"; });
        if (tinhTrangSuDung !== undefined)
            url_ += "TinhTrangSuDung=" + encodeURIComponent("" + tinhTrangSuDung) + "&";
        if (isSearch !== undefined)
            url_ += "IsSearch=" + encodeURIComponent("" + isSearch) + "&";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<GetAllOutputDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetAllOutputDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<GetAllOutputDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAllOutputDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAllOutputDtoPagedResultDto>(<any>null);
    }

    /**
     * @return Success
     */
    getAllNhaCC(): Observable<LookupTableDto[]> {
        let url_ = this.baseUrl + "/api/services/app/AngTenRFID/GetAllNhaCC";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllNhaCC(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllNhaCC(<any>response_);
                } catch (e) {
                    return <Observable<LookupTableDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<LookupTableDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllNhaCC(response: HttpResponseBase): Observable<LookupTableDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(LookupTableDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LookupTableDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllLoaiTS(): Observable<LookupTableDto[]> {
        let url_ = this.baseUrl + "/api/services/app/AngTenRFID/GetAllLoaiTS";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllLoaiTS(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllLoaiTS(<any>response_);
                } catch (e) {
                    return <Observable<LookupTableDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<LookupTableDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllLoaiTS(response: HttpResponseBase): Observable<LookupTableDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(LookupTableDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LookupTableDto[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateInputDto | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/AngTenRFID/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    deleted(input: number | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/AngTenRFID/Deleted?";
        if (input === null)
            throw new Error("The parameter 'input' cannot be null.");
        else if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleted(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleted(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processDeleted(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param input (optional) 
     * @param isView (optional) 
     * @return Success
     */
    getForEdit(input: number | undefined, isView: boolean | undefined): Observable<GetForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/AngTenRFID/GetForEdit?";
        if (input === null)
            throw new Error("The parameter 'input' cannot be null.");
        else if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        if (isView === null)
            throw new Error("The parameter 'isView' cannot be null.");
        else if (isView !== undefined)
            url_ += "isView=" + encodeURIComponent("" + isView) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<GetForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetForViewDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    xoaList(body: number[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AngTenRFID/XoaList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processXoaList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processXoaList(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processXoaList(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param maLoaiTS (optional) 
     * @param idTS (optional) 
     * @return Success
     */
    genCode(maLoaiTS: string | null | undefined, idTS: number | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/AngTenRFID/GenCode?";
        if (maLoaiTS !== undefined)
            url_ += "maLoaiTS=" + encodeURIComponent("" + maLoaiTS) + "&";
        if (idTS === null)
            throw new Error("The parameter 'idTS' cannot be null.");
        else if (idTS !== undefined)
            url_ += "idTS=" + encodeURIComponent("" + idTS) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGenCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGenCode(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGenCode(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @return Success
     */
    getUserDangNhap(): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/AngTenRFID/GetUserDangNhap";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserDangNhap(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserDangNhap(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserDangNhap(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param linkFile (optional) 
     * @return Success
     */
    downloadFileUpload(linkFile: string | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/AngTenRFID/DownloadFileUpload?";
        if (linkFile !== undefined)
            url_ += "linkFile=" + encodeURIComponent("" + linkFile) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadFileUpload(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadFileUpload(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processDownloadFileUpload(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param filePath (optional) 
     * @return Success
     */
    importFileExcel(filePath: string | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/AngTenRFID/ImportFileExcel?";
        if (filePath !== undefined)
            url_ += "filePath=" + encodeURIComponent("" + filePath) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImportFileExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImportFileExcel(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processImportFileExcel(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @return Success
     */
    downloadFileMau(): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/AngTenRFID/DownloadFileMau";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadFileMau(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadFileMau(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processDownloadFileMau(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    exportToExcel(body: InputRFIDDto | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/AngTenRFID/ExportToExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processExportToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

@Injectable()
export class AuditLogServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param userName (optional) 
     * @param serviceName (optional) 
     * @param isSearch (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllAuditLogs(startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined, userName: string | null | undefined, serviceName: string | null | undefined, isSearch: boolean | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<AuditLogListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetAllAuditLogs?";
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&";
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&";
        if (userName !== undefined)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&";
        if (serviceName !== undefined)
            url_ += "ServiceName=" + encodeURIComponent("" + serviceName) + "&";
        if (isSearch !== undefined)
            url_ += "IsSearch=" + encodeURIComponent("" + isSearch) + "&";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllAuditLogs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllAuditLogs(<any>response_);
                } catch (e) {
                    return <Observable<AuditLogListDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AuditLogListDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllAuditLogs(response: HttpResponseBase): Observable<AuditLogListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuditLogListDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AuditLogListDtoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    exportToExcel(body: GetAuditLogsInput | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/ExportToExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processExportToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @return Success
     */
    getAllServiceName(): Observable<StringLookupTableDto[]> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetAllServiceName";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllServiceName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllServiceName(<any>response_);
                } catch (e) {
                    return <Observable<StringLookupTableDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<StringLookupTableDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllServiceName(response: HttpResponseBase): Observable<StringLookupTableDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(StringLookupTableDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StringLookupTableDto[]>(<any>null);
    }
}

@Injectable()
export class BaoCaoCanhBaoServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    checkPhongBan(): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/BaoCaoCanhBao/CheckPhongBan";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckPhongBan(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckPhongBan(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processCheckPhongBan(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param phongBanqQL (optional) 
     * @param tuNgay (optional) 
     * @param denNgay (optional) 
     * @param isSearch (optional) 
     * @return Success
     */
    getAllBaoCao(phongBanqQL: number[] | null | undefined, tuNgay: moment.Moment | null | undefined, denNgay: moment.Moment | null | undefined, isSearch: boolean | null | undefined): Observable<ListBaoCaoCanhBaoOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/app/BaoCaoCanhBao/GetAllBaoCao?";
        if (phongBanqQL !== undefined)
            phongBanqQL && phongBanqQL.forEach(item => { url_ += "phongBanqQL=" + encodeURIComponent("" + item) + "&"; });
        if (tuNgay !== undefined)
            url_ += "tuNgay=" + encodeURIComponent(tuNgay ? "" + tuNgay.toJSON() : "") + "&";
        if (denNgay !== undefined)
            url_ += "denNgay=" + encodeURIComponent(denNgay ? "" + denNgay.toJSON() : "") + "&";
        if (isSearch !== undefined)
            url_ += "isSearch=" + encodeURIComponent("" + isSearch) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllBaoCao(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllBaoCao(<any>response_);
                } catch (e) {
                    return <Observable<ListBaoCaoCanhBaoOutputDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListBaoCaoCanhBaoOutputDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllBaoCao(response: HttpResponseBase): Observable<ListBaoCaoCanhBaoOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ListBaoCaoCanhBaoOutputDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListBaoCaoCanhBaoOutputDto[]>(<any>null);
    }

    /**
     * @param tuNgay (optional) 
     * @param denNgay (optional) 
     * @param body (optional) 
     * @return Success
     */
    exportToExcel(tuNgay: moment.Moment | null | undefined, denNgay: moment.Moment | null | undefined, body: number[] | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/BaoCaoCanhBao/ExportToExcel?";
        if (tuNgay !== undefined)
            url_ += "tuNgay=" + encodeURIComponent(tuNgay ? "" + tuNgay.toJSON() : "") + "&";
        if (denNgay !== undefined)
            url_ += "denNgay=" + encodeURIComponent(denNgay ? "" + denNgay.toJSON() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processExportToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

@Injectable()
export class BaoCaoNguoiDungServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param phongBanqQL (optional) 
     * @param tuNgay (optional) 
     * @param denNgay (optional) 
     * @param isSearch (optional) 
     * @return Success
     */
    getAllBaoCao(phongBanqQL: number[] | null | undefined, tuNgay: moment.Moment | null | undefined, denNgay: moment.Moment | null | undefined, isSearch: boolean | null | undefined): Observable<ListViewDto[]> {
        let url_ = this.baseUrl + "/api/services/app/BaoCaoNguoiDung/GetAllBaoCao?";
        if (phongBanqQL !== undefined)
            phongBanqQL && phongBanqQL.forEach(item => { url_ += "phongBanqQL=" + encodeURIComponent("" + item) + "&"; });
        if (tuNgay !== undefined)
            url_ += "tuNgay=" + encodeURIComponent(tuNgay ? "" + tuNgay.toJSON() : "") + "&";
        if (denNgay !== undefined)
            url_ += "denNgay=" + encodeURIComponent(denNgay ? "" + denNgay.toJSON() : "") + "&";
        if (isSearch !== undefined)
            url_ += "isSearch=" + encodeURIComponent("" + isSearch) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllBaoCao(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllBaoCao(<any>response_);
                } catch (e) {
                    return <Observable<ListViewDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListViewDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllBaoCao(response: HttpResponseBase): Observable<ListViewDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ListViewDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListViewDto[]>(<any>null);
    }

    /**
     * @param tuNgay (optional) 
     * @param denNgay (optional) 
     * @param isSearch (optional) 
     * @param body (optional) 
     * @return Success
     */
    exportToExcel(tuNgay: moment.Moment | null | undefined, denNgay: moment.Moment | null | undefined, isSearch: boolean | null | undefined, body: number[] | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/BaoCaoNguoiDung/ExportToExcel?";
        if (tuNgay !== undefined)
            url_ += "tuNgay=" + encodeURIComponent(tuNgay ? "" + tuNgay.toJSON() : "") + "&";
        if (denNgay !== undefined)
            url_ += "denNgay=" + encodeURIComponent(denNgay ? "" + denNgay.toJSON() : "") + "&";
        if (isSearch !== undefined)
            url_ += "isSearch=" + encodeURIComponent("" + isSearch) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processExportToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

@Injectable()
export class BaoCaoThongTinTaiSanServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    checkPhongBan(): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/BaoCaoThongTinTaiSan/CheckPhongBan";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckPhongBan(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckPhongBan(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processCheckPhongBan(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param phongBanqQL (optional) 
     * @param tuNgay (optional) 
     * @param denNgay (optional) 
     * @param isSearch (optional) 
     * @return Success
     */
    getAllBaoCao(phongBanqQL: number[] | null | undefined, tuNgay: moment.Moment | null | undefined, denNgay: moment.Moment | null | undefined, isSearch: boolean | null | undefined): Observable<ListBaoCaoChiTietDto[]> {
        let url_ = this.baseUrl + "/api/services/app/BaoCaoThongTinTaiSan/GetAllBaoCao?";
        if (phongBanqQL !== undefined)
            phongBanqQL && phongBanqQL.forEach(item => { url_ += "phongBanqQL=" + encodeURIComponent("" + item) + "&"; });
        if (tuNgay !== undefined)
            url_ += "tuNgay=" + encodeURIComponent(tuNgay ? "" + tuNgay.toJSON() : "") + "&";
        if (denNgay !== undefined)
            url_ += "denNgay=" + encodeURIComponent(denNgay ? "" + denNgay.toJSON() : "") + "&";
        if (isSearch !== undefined)
            url_ += "isSearch=" + encodeURIComponent("" + isSearch) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllBaoCao(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllBaoCao(<any>response_);
                } catch (e) {
                    return <Observable<ListBaoCaoChiTietDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListBaoCaoChiTietDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllBaoCao(response: HttpResponseBase): Observable<ListBaoCaoChiTietDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ListBaoCaoChiTietDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListBaoCaoChiTietDto[]>(<any>null);
    }

    /**
     * @param tuNgay (optional) 
     * @param denNgay (optional) 
     * @param isSearch (optional) 
     * @param body (optional) 
     * @return Success
     */
    exportToExcel(tuNgay: moment.Moment | null | undefined, denNgay: moment.Moment | null | undefined, isSearch: boolean | null | undefined, body: number[] | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/BaoCaoThongTinTaiSan/ExportToExcel?";
        if (tuNgay !== undefined)
            url_ += "tuNgay=" + encodeURIComponent(tuNgay ? "" + tuNgay.toJSON() : "") + "&";
        if (denNgay !== undefined)
            url_ += "denNgay=" + encodeURIComponent(denNgay ? "" + denNgay.toJSON() : "") + "&";
        if (isSearch !== undefined)
            url_ += "isSearch=" + encodeURIComponent("" + isSearch) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processExportToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

@Injectable()
export class BaoCaoThongTinThietBiRFIDServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param phongBanqQL (optional) 
     * @param tuNgay (optional) 
     * @param denNgay (optional) 
     * @param isSearch (optional) 
     * @return Success
     */
    getAllBaoCao(phongBanqQL: number[] | null | undefined, tuNgay: moment.Moment | null | undefined, denNgay: moment.Moment | null | undefined, isSearch: boolean | null | undefined): Observable<ListBaoCaoChiTietDto[]> {
        let url_ = this.baseUrl + "/api/services/app/BaoCaoThongTinThietBiRFID/GetAllBaoCao?";
        if (phongBanqQL !== undefined)
            phongBanqQL && phongBanqQL.forEach(item => { url_ += "phongBanqQL=" + encodeURIComponent("" + item) + "&"; });
        if (tuNgay !== undefined)
            url_ += "tuNgay=" + encodeURIComponent(tuNgay ? "" + tuNgay.toJSON() : "") + "&";
        if (denNgay !== undefined)
            url_ += "denNgay=" + encodeURIComponent(denNgay ? "" + denNgay.toJSON() : "") + "&";
        if (isSearch !== undefined)
            url_ += "isSearch=" + encodeURIComponent("" + isSearch) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllBaoCao(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllBaoCao(<any>response_);
                } catch (e) {
                    return <Observable<ListBaoCaoChiTietDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListBaoCaoChiTietDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllBaoCao(response: HttpResponseBase): Observable<ListBaoCaoChiTietDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ListBaoCaoChiTietDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListBaoCaoChiTietDto[]>(<any>null);
    }

    /**
     * @param tuNgay (optional) 
     * @param denNgay (optional) 
     * @param isSearch (optional) 
     * @param body (optional) 
     * @return Success
     */
    exportToExcel(tuNgay: moment.Moment | null | undefined, denNgay: moment.Moment | null | undefined, isSearch: boolean | null | undefined, body: number[] | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/BaoCaoThongTinThietBiRFID/ExportToExcel?";
        if (tuNgay !== undefined)
            url_ += "tuNgay=" + encodeURIComponent(tuNgay ? "" + tuNgay.toJSON() : "") + "&";
        if (denNgay !== undefined)
            url_ += "denNgay=" + encodeURIComponent(denNgay ? "" + denNgay.toJSON() : "") + "&";
        if (isSearch !== undefined)
            url_ += "isSearch=" + encodeURIComponent("" + isSearch) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processExportToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

@Injectable()
export class CanhBaoServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param taiKhoanId (optional) 
     * @param toChucId (optional) 
     * @param noiDung (optional) 
     * @param hoatDong (optional) 
     * @param thoiGianFrom (optional) 
     * @param thoiGianTo (optional) 
     * @param isSearch (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(taiKhoanId: number | null | undefined, toChucId: number[] | null | undefined, noiDung: string | null | undefined, hoatDong: number | null | undefined, thoiGianFrom: moment.Moment | null | undefined, thoiGianTo: moment.Moment | null | undefined, isSearch: boolean | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<CanhBaoForViewDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/CanhBao/GetAll?";
        if (taiKhoanId !== undefined)
            url_ += "TaiKhoanId=" + encodeURIComponent("" + taiKhoanId) + "&";
        if (toChucId !== undefined)
            toChucId && toChucId.forEach(item => { url_ += "ToChucId=" + encodeURIComponent("" + item) + "&"; });
        if (noiDung !== undefined)
            url_ += "NoiDung=" + encodeURIComponent("" + noiDung) + "&";
        if (hoatDong !== undefined)
            url_ += "HoatDong=" + encodeURIComponent("" + hoatDong) + "&";
        if (thoiGianFrom !== undefined)
            url_ += "ThoiGianFrom=" + encodeURIComponent(thoiGianFrom ? "" + thoiGianFrom.toJSON() : "") + "&";
        if (thoiGianTo !== undefined)
            url_ += "ThoiGianTo=" + encodeURIComponent(thoiGianTo ? "" + thoiGianTo.toJSON() : "") + "&";
        if (isSearch !== undefined)
            url_ += "IsSearch=" + encodeURIComponent("" + isSearch) + "&";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<CanhBaoForViewDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CanhBaoForViewDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<CanhBaoForViewDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CanhBaoForViewDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CanhBaoForViewDtoPagedResultDto>(<any>null);
    }

    /**
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllThongBao(sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<ThongBaoOutputPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/CanhBao/GetAllThongBao?";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllThongBao(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllThongBao(<any>response_);
                } catch (e) {
                    return <Observable<ThongBaoOutputPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ThongBaoOutputPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllThongBao(response: HttpResponseBase): Observable<ThongBaoOutputPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ThongBaoOutputPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ThongBaoOutputPagedResultDto>(<any>null);
    }

    /**
     * @return Success
     */
    getAllNguoiDung(): Observable<LookupTableDto[]> {
        let url_ = this.baseUrl + "/api/services/app/CanhBao/GetAllNguoiDung";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllNguoiDung(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllNguoiDung(<any>response_);
                } catch (e) {
                    return <Observable<LookupTableDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<LookupTableDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllNguoiDung(response: HttpResponseBase): Observable<LookupTableDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(LookupTableDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LookupTableDto[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    exportToExcel(body: CanhBaoInputDto | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/CanhBao/ExportToExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processExportToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    taoCanhBao(body: InputFromServiceDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CanhBao/TaoCanhBao";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTaoCanhBao(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTaoCanhBao(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processTaoCanhBao(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class ConfigurationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changeUiTheme(body: ChangeUiThemeInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Configuration/ChangeUiTheme";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeUiTheme(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeUiTheme(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processChangeUiTheme(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class DatLichXuatBaoCaoServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param fillter (optional) 
     * @param isSearch (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllDatLich(fillter: string | null | undefined, isSearch: boolean | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<GetAllDatLichBCDtosPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/DatLichXuatBaoCao/GetAllDatLich?";
        if (fillter !== undefined)
            url_ += "Fillter=" + encodeURIComponent("" + fillter) + "&";
        if (isSearch !== undefined)
            url_ += "IsSearch=" + encodeURIComponent("" + isSearch) + "&";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllDatLich(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllDatLich(<any>response_);
                } catch (e) {
                    return <Observable<GetAllDatLichBCDtosPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetAllDatLichBCDtosPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllDatLich(response: HttpResponseBase): Observable<GetAllDatLichBCDtosPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAllDatLichBCDtosPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAllDatLichBCDtosPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditDatLichDtos | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/DatLichXuatBaoCao/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DatLichXuatBaoCao/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @param isView (optional) 
     * @return Success
     */
    getForEdit(input: number | undefined, isView: boolean | undefined): Observable<GetValueForViewDatLich> {
        let url_ = this.baseUrl + "/api/services/app/DatLichXuatBaoCao/GetForEdit?";
        if (input === null)
            throw new Error("The parameter 'input' cannot be null.");
        else if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        if (isView === null)
            throw new Error("The parameter 'isView' cannot be null.");
        else if (isView !== undefined)
            url_ += "isView=" + encodeURIComponent("" + isView) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetValueForViewDatLich>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetValueForViewDatLich>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<GetValueForViewDatLich> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetValueForViewDatLich.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetValueForViewDatLich>(<any>null);
    }
}

@Injectable()
export class DauDocTheRFIDServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param tenTS (optional) 
     * @param phongBanSuDung (optional) 
     * @param tinhTrangSuDung (optional) 
     * @param isSearch (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(tenTS: string | null | undefined, phongBanSuDung: number[] | null | undefined, tinhTrangSuDung: number | null | undefined, isSearch: boolean | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<GetAllOutputDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/DauDocTheRFID/GetAll?";
        if (tenTS !== undefined)
            url_ += "TenTS=" + encodeURIComponent("" + tenTS) + "&";
        if (phongBanSuDung !== undefined)
            phongBanSuDung && phongBanSuDung.forEach(item => { url_ += "PhongBanSuDung=" + encodeURIComponent("" + item) + "&"; });
        if (tinhTrangSuDung !== undefined)
            url_ += "TinhTrangSuDung=" + encodeURIComponent("" + tinhTrangSuDung) + "&";
        if (isSearch !== undefined)
            url_ += "IsSearch=" + encodeURIComponent("" + isSearch) + "&";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<GetAllOutputDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetAllOutputDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<GetAllOutputDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAllOutputDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAllOutputDtoPagedResultDto>(<any>null);
    }

    /**
     * @return Success
     */
    getAllNhaCC(): Observable<LookupTableDto[]> {
        let url_ = this.baseUrl + "/api/services/app/DauDocTheRFID/GetAllNhaCC";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllNhaCC(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllNhaCC(<any>response_);
                } catch (e) {
                    return <Observable<LookupTableDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<LookupTableDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllNhaCC(response: HttpResponseBase): Observable<LookupTableDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(LookupTableDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LookupTableDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllLoaiTS(): Observable<LookupTableDto[]> {
        let url_ = this.baseUrl + "/api/services/app/DauDocTheRFID/GetAllLoaiTS";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllLoaiTS(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllLoaiTS(<any>response_);
                } catch (e) {
                    return <Observable<LookupTableDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<LookupTableDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllLoaiTS(response: HttpResponseBase): Observable<LookupTableDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(LookupTableDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LookupTableDto[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateInputDto | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/DauDocTheRFID/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    deleted(input: number | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/DauDocTheRFID/Deleted?";
        if (input === null)
            throw new Error("The parameter 'input' cannot be null.");
        else if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleted(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleted(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processDeleted(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param input (optional) 
     * @param isView (optional) 
     * @return Success
     */
    getForEdit(input: number | undefined, isView: boolean | undefined): Observable<GetForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/DauDocTheRFID/GetForEdit?";
        if (input === null)
            throw new Error("The parameter 'input' cannot be null.");
        else if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        if (isView === null)
            throw new Error("The parameter 'isView' cannot be null.");
        else if (isView !== undefined)
            url_ += "isView=" + encodeURIComponent("" + isView) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<GetForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetForViewDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    xoaList(body: number[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DauDocTheRFID/XoaList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processXoaList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processXoaList(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processXoaList(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param maLoaiTS (optional) 
     * @param idTS (optional) 
     * @return Success
     */
    genCode(maLoaiTS: string | null | undefined, idTS: number | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/DauDocTheRFID/GenCode?";
        if (maLoaiTS !== undefined)
            url_ += "maLoaiTS=" + encodeURIComponent("" + maLoaiTS) + "&";
        if (idTS === null)
            throw new Error("The parameter 'idTS' cannot be null.");
        else if (idTS !== undefined)
            url_ += "idTS=" + encodeURIComponent("" + idTS) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGenCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGenCode(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGenCode(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @return Success
     */
    getUserDangNhap(): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/DauDocTheRFID/GetUserDangNhap";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserDangNhap(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserDangNhap(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserDangNhap(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param linkFile (optional) 
     * @return Success
     */
    downloadFileUpload(linkFile: string | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/DauDocTheRFID/DownloadFileUpload?";
        if (linkFile !== undefined)
            url_ += "linkFile=" + encodeURIComponent("" + linkFile) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadFileUpload(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadFileUpload(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processDownloadFileUpload(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param filePath (optional) 
     * @return Success
     */
    importFileExcel(filePath: string | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/DauDocTheRFID/ImportFileExcel?";
        if (filePath !== undefined)
            url_ += "filePath=" + encodeURIComponent("" + filePath) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImportFileExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImportFileExcel(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processImportFileExcel(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @return Success
     */
    downloadFileMau(): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/DauDocTheRFID/DownloadFileMau";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadFileMau(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadFileMau(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processDownloadFileMau(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    exportToExcel(body: InputRFIDDto | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/DauDocTheRFID/ExportToExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processExportToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

@Injectable()
export class DemoServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param keyword (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<DemoForViewPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Demo/GetAll?";
        if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<DemoForViewPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DemoForViewPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<DemoForViewPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DemoForViewPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DemoForViewPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: DemoCreateInput | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Demo/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: number | undefined): Observable<DemoCreateInput> {
        let url_ = this.baseUrl + "/api/services/app/Demo/GetForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(<any>response_);
                } catch (e) {
                    return <Observable<DemoCreateInput>><any>_observableThrow(e);
                }
            } else
                return <Observable<DemoCreateInput>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<DemoCreateInput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DemoCreateInput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DemoCreateInput>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Demo/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    exportToExcel(body: DemoGetAllInputDto | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/Demo/ExportToExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processExportToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param filePath (optional) 
     * @return Success
     */
    importFileExcel(filePath: string | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Demo/ImportFileExcel?";
        if (filePath !== undefined)
            url_ += "FilePath=" + encodeURIComponent("" + filePath) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImportFileExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImportFileExcel(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processImportFileExcel(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @return Success
     */
    downloadFileMau(): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/Demo/DownloadFileMau";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadFileMau(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadFileMau(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processDownloadFileMau(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param linkFile (optional) 
     * @return Success
     */
    downloadFileUpload(linkFile: string | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/Demo/DownloadFileUpload?";
        if (linkFile !== undefined)
            url_ += "linkFile=" + encodeURIComponent("" + linkFile) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadFileUpload(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadFileUpload(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processDownloadFileUpload(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @return Success
     */
    downloadIphoneApp(): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/Demo/DownloadIphoneApp";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadIphoneApp(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadIphoneApp(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processDownloadIphoneApp(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @return Success
     */
    downloadAndroidApp(): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/Demo/DownloadAndroidApp";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadAndroidApp(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadAndroidApp(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processDownloadAndroidApp(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

@Injectable()
export class KiemKeTaiSanServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param keyword (optional) 
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param boPhanDuocKiemKeId (optional) 
     * @param trangThaiId (optional) 
     * @param isSearch (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined, boPhanDuocKiemKeId: number[] | null | undefined, trangThaiId: number | null | undefined, isSearch: boolean | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<KiemKeTaiSanForViewDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/KiemKeTaiSan/GetAll?";
        if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&";
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&";
        if (boPhanDuocKiemKeId !== undefined)
            boPhanDuocKiemKeId && boPhanDuocKiemKeId.forEach(item => { url_ += "BoPhanDuocKiemKeId=" + encodeURIComponent("" + item) + "&"; });
        if (trangThaiId !== undefined)
            url_ += "TrangThaiId=" + encodeURIComponent("" + trangThaiId) + "&";
        if (isSearch !== undefined)
            url_ += "IsSearch=" + encodeURIComponent("" + isSearch) + "&";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<KiemKeTaiSanForViewDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<KiemKeTaiSanForViewDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<KiemKeTaiSanForViewDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = KiemKeTaiSanForViewDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<KiemKeTaiSanForViewDtoPagedResultDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param status (optional) 
     * @param keyword (optional) 
     * @param sorting (optional) 
     * @param isSearch (optional) 
     * @return Success
     */
    getAllTaiSan(id: number | undefined, status: number | undefined, keyword: string | null | undefined, sorting: string | null | undefined, isSearch: boolean | null | undefined): Observable<KetQuaKiemKeForViewDto[]> {
        let url_ = this.baseUrl + "/api/services/app/KiemKeTaiSan/GetAllTaiSan?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (status === null)
            throw new Error("The parameter 'status' cannot be null.");
        else if (status !== undefined)
            url_ += "Status=" + encodeURIComponent("" + status) + "&";
        if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (isSearch !== undefined)
            url_ += "IsSearch=" + encodeURIComponent("" + isSearch) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllTaiSan(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllTaiSan(<any>response_);
                } catch (e) {
                    return <Observable<KetQuaKiemKeForViewDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<KetQuaKiemKeForViewDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllTaiSan(response: HttpResponseBase): Observable<KetQuaKiemKeForViewDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(KetQuaKiemKeForViewDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<KetQuaKiemKeForViewDto[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateTinhTrangTaiSan(body: KetQuaKiemKeForUpdateDto[] | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/KiemKeTaiSan/UpdateTinhTrangTaiSan";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTinhTrangTaiSan(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTinhTrangTaiSan(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateTinhTrangTaiSan(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateTrangThaiKiemKe(body: TrangThaiKiemKeForUpdateDto | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/KiemKeTaiSan/UpdateTrangThaiKiemKe";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTrangThaiKiemKe(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTrangThaiKiemKe(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateTrangThaiKiemKe(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param isView (optional) 
     * @return Success
     */
    getForEdit(id: number | undefined, isView: boolean | undefined): Observable<KiemKeTaiSanCreateInputDto> {
        let url_ = this.baseUrl + "/api/services/app/KiemKeTaiSan/GetForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (isView === null)
            throw new Error("The parameter 'isView' cannot be null.");
        else if (isView !== undefined)
            url_ += "isView=" + encodeURIComponent("" + isView) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(<any>response_);
                } catch (e) {
                    return <Observable<KiemKeTaiSanCreateInputDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<KiemKeTaiSanCreateInputDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<KiemKeTaiSanCreateInputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = KiemKeTaiSanCreateInputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<KiemKeTaiSanCreateInputDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createKetQuaKiemKe(body: KetQuaKiemKeCreateDto | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/KiemKeTaiSan/CreateKetQuaKiemKe";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateKetQuaKiemKe(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateKetQuaKiemKe(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processCreateKetQuaKiemKe(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getUserForEdit(id: number | undefined): Observable<UserForViewDto[]> {
        let url_ = this.baseUrl + "/api/services/app/KiemKeTaiSan/GetUserForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserForEdit(<any>response_);
                } catch (e) {
                    return <Observable<UserForViewDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserForViewDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserForEdit(response: HttpResponseBase): Observable<UserForViewDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(UserForViewDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserForViewDto[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: KiemKeTaiSanCreateInputDto | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/KiemKeTaiSan/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    delete(input: number[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/KiemKeTaiSan/Delete?";
        if (input !== undefined)
            input && input.forEach(item => { url_ += "input=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class KhaiBaoHongMatServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param timKiemKhaiBao (optional) 
     * @param phongBanqQL (optional) 
     * @param khaiBao (optional) 
     * @param isSearch (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllKhaiBaoHongMat(timKiemKhaiBao: string | null | undefined, phongBanqQL: number[] | null | undefined, khaiBao: number | null | undefined, isSearch: boolean | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<ViewKhaiBaoHongMatPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/KhaiBaoHongMat/GetAllKhaiBaoHongMat?";
        if (timKiemKhaiBao !== undefined)
            url_ += "TimKiemKhaiBao=" + encodeURIComponent("" + timKiemKhaiBao) + "&";
        if (phongBanqQL !== undefined)
            phongBanqQL && phongBanqQL.forEach(item => { url_ += "PhongBanqQL=" + encodeURIComponent("" + item) + "&"; });
        if (khaiBao !== undefined)
            url_ += "KhaiBao=" + encodeURIComponent("" + khaiBao) + "&";
        if (isSearch !== undefined)
            url_ += "IsSearch=" + encodeURIComponent("" + isSearch) + "&";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllKhaiBaoHongMat(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllKhaiBaoHongMat(<any>response_);
                } catch (e) {
                    return <Observable<ViewKhaiBaoHongMatPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ViewKhaiBaoHongMatPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllKhaiBaoHongMat(response: HttpResponseBase): Observable<ViewKhaiBaoHongMatPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ViewKhaiBaoHongMatPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ViewKhaiBaoHongMatPagedResultDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllKhaiBaoHongMatChiTiet(id: number | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<ViewKhaiBaoHongMatChiTietPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/KhaiBaoHongMat/GetAllKhaiBaoHongMatChiTiet?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllKhaiBaoHongMatChiTiet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllKhaiBaoHongMatChiTiet(<any>response_);
                } catch (e) {
                    return <Observable<ViewKhaiBaoHongMatChiTietPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ViewKhaiBaoHongMatChiTietPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllKhaiBaoHongMatChiTiet(response: HttpResponseBase): Observable<ViewKhaiBaoHongMatChiTietPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ViewKhaiBaoHongMatChiTietPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ViewKhaiBaoHongMatChiTietPagedResultDto>(<any>null);
    }
}

@Injectable()
export class LichSuRaVaoAngtenServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param keyword (optional) 
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param chieuDiChuyen (optional) 
     * @param boPhanId (optional) 
     * @param phanLoaiId (optional) 
     * @param isSearch (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined, chieuDiChuyen: string | null | undefined, boPhanId: number[] | null | undefined, phanLoaiId: number | null | undefined, isSearch: boolean | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<LichSuRaVaoForViewDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/LichSuRaVaoAngten/GetAll?";
        if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&";
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&";
        if (chieuDiChuyen !== undefined)
            url_ += "ChieuDiChuyen=" + encodeURIComponent("" + chieuDiChuyen) + "&";
        if (boPhanId !== undefined)
            boPhanId && boPhanId.forEach(item => { url_ += "BoPhanId=" + encodeURIComponent("" + item) + "&"; });
        if (phanLoaiId !== undefined)
            url_ += "PhanLoaiId=" + encodeURIComponent("" + phanLoaiId) + "&";
        if (isSearch !== undefined)
            url_ += "IsSearch=" + encodeURIComponent("" + isSearch) + "&";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<LichSuRaVaoForViewDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<LichSuRaVaoForViewDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<LichSuRaVaoForViewDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LichSuRaVaoForViewDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LichSuRaVaoForViewDtoPagedResultDto>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param chieuDiChuyen (optional) 
     * @param boPhanId (optional) 
     * @param phanLoaiId (optional) 
     * @param isSearch (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllTaiSanLa(keyword: string | null | undefined, startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined, chieuDiChuyen: string | null | undefined, boPhanId: number[] | null | undefined, phanLoaiId: number | null | undefined, isSearch: boolean | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<LichSuRaVaoForViewDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/LichSuRaVaoAngten/GetAllTaiSanLa?";
        if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&";
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&";
        if (chieuDiChuyen !== undefined)
            url_ += "ChieuDiChuyen=" + encodeURIComponent("" + chieuDiChuyen) + "&";
        if (boPhanId !== undefined)
            boPhanId && boPhanId.forEach(item => { url_ += "BoPhanId=" + encodeURIComponent("" + item) + "&"; });
        if (phanLoaiId !== undefined)
            url_ += "PhanLoaiId=" + encodeURIComponent("" + phanLoaiId) + "&";
        if (isSearch !== undefined)
            url_ += "IsSearch=" + encodeURIComponent("" + isSearch) + "&";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllTaiSanLa(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllTaiSanLa(<any>response_);
                } catch (e) {
                    return <Observable<LichSuRaVaoForViewDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<LichSuRaVaoForViewDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllTaiSanLa(response: HttpResponseBase): Observable<LichSuRaVaoForViewDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LichSuRaVaoForViewDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LichSuRaVaoForViewDtoPagedResultDto>(<any>null);
    }

    /**
     * @return Success
     */
    getAllNhaCC(): Observable<LookupTableDto[]> {
        let url_ = this.baseUrl + "/api/services/app/LichSuRaVaoAngten/GetAllNhaCC";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllNhaCC(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllNhaCC(<any>response_);
                } catch (e) {
                    return <Observable<LookupTableDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<LookupTableDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllNhaCC(response: HttpResponseBase): Observable<LookupTableDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(LookupTableDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LookupTableDto[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    exportTaiSanLaToExcel(body: InputLichSuRaVaoDto | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/LichSuRaVaoAngten/ExportTaiSanLaToExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportTaiSanLaToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportTaiSanLaToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processExportTaiSanLaToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    exportLichSuRaVaoToExcel(body: InputLichSuRaVaoDto | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/LichSuRaVaoAngten/ExportLichSuRaVaoToExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportLichSuRaVaoToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportLichSuRaVaoToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processExportLichSuRaVaoToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateInputDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/LichSuRaVaoAngten/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class LoaiTaiSanServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param keyword (optional) 
     * @param isSearch (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, isSearch: boolean | null | undefined): Observable<LoaiTaiSanTreeTableForViewDto[]> {
        let url_ = this.baseUrl + "/api/services/app/LoaiTaiSan/GetAll?";
        if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (isSearch !== undefined)
            url_ += "IsSearch=" + encodeURIComponent("" + isSearch) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<LoaiTaiSanTreeTableForViewDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<LoaiTaiSanTreeTableForViewDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<LoaiTaiSanTreeTableForViewDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(LoaiTaiSanTreeTableForViewDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LoaiTaiSanTreeTableForViewDto[]>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param isView (optional) 
     * @return Success
     */
    getForEdit(id: number | undefined, isView: boolean | undefined): Observable<LoaiTaiSanCreateInputDto> {
        let url_ = this.baseUrl + "/api/services/app/LoaiTaiSan/GetForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (isView === null)
            throw new Error("The parameter 'isView' cannot be null.");
        else if (isView !== undefined)
            url_ += "isView=" + encodeURIComponent("" + isView) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(<any>response_);
                } catch (e) {
                    return <Observable<LoaiTaiSanCreateInputDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<LoaiTaiSanCreateInputDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<LoaiTaiSanCreateInputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LoaiTaiSanCreateInputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LoaiTaiSanCreateInputDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: LoaiTaiSanCreateInputDto | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/LoaiTaiSan/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/LoaiTaiSan/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    exportToExcel(body: LoaiTaiSanGetAllInputDto | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/LoaiTaiSan/ExportToExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processExportToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param filePath (optional) 
     * @return Success
     */
    importFileExcel(filePath: string | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/LoaiTaiSan/ImportFileExcel?";
        if (filePath !== undefined)
            url_ += "filePath=" + encodeURIComponent("" + filePath) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImportFileExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImportFileExcel(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processImportFileExcel(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @return Success
     */
    downloadFileMau(): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/LoaiTaiSan/DownloadFileMau";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadFileMau(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadFileMau(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processDownloadFileMau(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

@Injectable()
export class LookupTableServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllStringLookupTable(): Observable<StringLookupTableDto[]> {
        let url_ = this.baseUrl + "/api/services/app/LookupTable/GetAllStringLookupTable";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllStringLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllStringLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<StringLookupTableDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<StringLookupTableDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllStringLookupTable(response: HttpResponseBase): Observable<StringLookupTableDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(StringLookupTableDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StringLookupTableDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllLongLookupTable(): Observable<Int64LookupTableDto[]> {
        let url_ = this.baseUrl + "/api/services/app/LookupTable/GetAllLongLookupTable";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllLongLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllLongLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<Int64LookupTableDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Int64LookupTableDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllLongLookupTable(response: HttpResponseBase): Observable<Int64LookupTableDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(Int64LookupTableDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Int64LookupTableDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllTrangThaiHieuLuc(): Observable<LookupTableDto[]> {
        let url_ = this.baseUrl + "/api/services/app/LookupTable/GetAllTrangThaiHieuLuc";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllTrangThaiHieuLuc(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllTrangThaiHieuLuc(<any>response_);
                } catch (e) {
                    return <Observable<LookupTableDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<LookupTableDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllTrangThaiHieuLuc(response: HttpResponseBase): Observable<LookupTableDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(LookupTableDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LookupTableDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllKetQuaKiemKeTaiSan(): Observable<LookupTableDto[]> {
        let url_ = this.baseUrl + "/api/services/app/LookupTable/GetAllKetQuaKiemKeTaiSan";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllKetQuaKiemKeTaiSan(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllKetQuaKiemKeTaiSan(<any>response_);
                } catch (e) {
                    return <Observable<LookupTableDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<LookupTableDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllKetQuaKiemKeTaiSan(response: HttpResponseBase): Observable<LookupTableDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(LookupTableDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LookupTableDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllTrangThaiDuyet(): Observable<LookupTableDto[]> {
        let url_ = this.baseUrl + "/api/services/app/LookupTable/GetAllTrangThaiDuyet";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllTrangThaiDuyet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllTrangThaiDuyet(<any>response_);
                } catch (e) {
                    return <Observable<LookupTableDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<LookupTableDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllTrangThaiDuyet(response: HttpResponseBase): Observable<LookupTableDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(LookupTableDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LookupTableDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllDemo(): Observable<LookupTableDto[]> {
        let url_ = this.baseUrl + "/api/services/app/LookupTable/GetAllDemo";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllDemo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllDemo(<any>response_);
                } catch (e) {
                    return <Observable<LookupTableDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<LookupTableDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllDemo(response: HttpResponseBase): Observable<LookupTableDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(LookupTableDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LookupTableDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllToChucLookupTable(): Observable<LookupTableDto[]> {
        let url_ = this.baseUrl + "/api/services/app/LookupTable/GetAllToChucLookupTable";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllToChucLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllToChucLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<LookupTableDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<LookupTableDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllToChucLookupTable(response: HttpResponseBase): Observable<LookupTableDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(LookupTableDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LookupTableDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllLinhVucKinhDoanh(): Observable<LookupTableDto[]> {
        let url_ = this.baseUrl + "/api/services/app/LookupTable/GetAllLinhVucKinhDoanh";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllLinhVucKinhDoanh(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllLinhVucKinhDoanh(<any>response_);
                } catch (e) {
                    return <Observable<LookupTableDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<LookupTableDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllLinhVucKinhDoanh(response: HttpResponseBase): Observable<LookupTableDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(LookupTableDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LookupTableDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllToChucTree(): Observable<TreeviewItemDto[]> {
        let url_ = this.baseUrl + "/api/services/app/LookupTable/GetAllToChucTree";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllToChucTree(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllToChucTree(<any>response_);
                } catch (e) {
                    return <Observable<TreeviewItemDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<TreeviewItemDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllToChucTree(response: HttpResponseBase): Observable<TreeviewItemDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(TreeviewItemDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TreeviewItemDto[]>(<any>null);
    }

    /**
     * @param layCha (optional) 
     * @return Success
     */
    getAllToChucTheoNguoiDungTree(layCha: boolean | undefined): Observable<TreeviewItemDto[]> {
        let url_ = this.baseUrl + "/api/services/app/LookupTable/GetAllToChucTheoNguoiDungTree?";
        if (layCha === null)
            throw new Error("The parameter 'layCha' cannot be null.");
        else if (layCha !== undefined)
            url_ += "layCha=" + encodeURIComponent("" + layCha) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllToChucTheoNguoiDungTree(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllToChucTheoNguoiDungTree(<any>response_);
                } catch (e) {
                    return <Observable<TreeviewItemDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<TreeviewItemDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllToChucTheoNguoiDungTree(response: HttpResponseBase): Observable<TreeviewItemDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(TreeviewItemDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TreeviewItemDto[]>(<any>null);
    }

    /**
     * @param layCha (optional) 
     * @return Success
     */
    getAllToChucIdTheoNguoiDungList(layCha: boolean | undefined): Observable<number[]> {
        let url_ = this.baseUrl + "/api/services/app/LookupTable/GetAllToChucIdTheoNguoiDungList?";
        if (layCha === null)
            throw new Error("The parameter 'layCha' cannot be null.");
        else if (layCha !== undefined)
            url_ += "layCha=" + encodeURIComponent("" + layCha) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllToChucIdTheoNguoiDungList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllToChucIdTheoNguoiDungList(<any>response_);
                } catch (e) {
                    return <Observable<number[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<number[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllToChucIdTheoNguoiDungList(response: HttpResponseBase): Observable<number[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllLoaiTaiSanTree(): Observable<TreeviewItemDto[]> {
        let url_ = this.baseUrl + "/api/services/app/LookupTable/GetAllLoaiTaiSanTree";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllLoaiTaiSanTree(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllLoaiTaiSanTree(<any>response_);
                } catch (e) {
                    return <Observable<TreeviewItemDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<TreeviewItemDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllLoaiTaiSanTree(response: HttpResponseBase): Observable<TreeviewItemDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(TreeviewItemDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TreeviewItemDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllNhaCungCap(): Observable<LookupTableDto[]> {
        let url_ = this.baseUrl + "/api/services/app/LookupTable/GetAllNhaCungCap";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllNhaCungCap(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllNhaCungCap(<any>response_);
                } catch (e) {
                    return <Observable<LookupTableDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<LookupTableDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllNhaCungCap(response: HttpResponseBase): Observable<LookupTableDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(LookupTableDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LookupTableDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllTinhTrangMaSuDungTaiSan(): Observable<LookupTableDto[]> {
        let url_ = this.baseUrl + "/api/services/app/LookupTable/GetAllTinhTrangMaSuDungTaiSan";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllTinhTrangMaSuDungTaiSan(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllTinhTrangMaSuDungTaiSan(<any>response_);
                } catch (e) {
                    return <Observable<LookupTableDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<LookupTableDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllTinhTrangMaSuDungTaiSan(response: HttpResponseBase): Observable<LookupTableDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(LookupTableDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LookupTableDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllTrangThaiTaiSan(): Observable<LookupTableDto[]> {
        let url_ = this.baseUrl + "/api/services/app/LookupTable/GetAllTrangThaiTaiSan";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllTrangThaiTaiSan(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllTrangThaiTaiSan(<any>response_);
                } catch (e) {
                    return <Observable<LookupTableDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<LookupTableDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllTrangThaiTaiSan(response: HttpResponseBase): Observable<LookupTableDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(LookupTableDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LookupTableDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllTrangThaiTaiSanTimKiem(): Observable<LookupTableDto[]> {
        let url_ = this.baseUrl + "/api/services/app/LookupTable/GetAllTrangThaiTaiSanTimKiem";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllTrangThaiTaiSanTimKiem(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllTrangThaiTaiSanTimKiem(<any>response_);
                } catch (e) {
                    return <Observable<LookupTableDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<LookupTableDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllTrangThaiTaiSanTimKiem(response: HttpResponseBase): Observable<LookupTableDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(LookupTableDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LookupTableDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllTrangThaiSuaChuaBaoDuong(): Observable<LookupTableDto[]> {
        let url_ = this.baseUrl + "/api/services/app/LookupTable/GetAllTrangThaiSuaChuaBaoDuong";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllTrangThaiSuaChuaBaoDuong(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllTrangThaiSuaChuaBaoDuong(<any>response_);
                } catch (e) {
                    return <Observable<LookupTableDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<LookupTableDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllTrangThaiSuaChuaBaoDuong(response: HttpResponseBase): Observable<LookupTableDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(LookupTableDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LookupTableDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllTrangThaiKiemKe(): Observable<LookupTableDto[]> {
        let url_ = this.baseUrl + "/api/services/app/LookupTable/GetAllTrangThaiKiemKe";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllTrangThaiKiemKe(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllTrangThaiKiemKe(<any>response_);
                } catch (e) {
                    return <Observable<LookupTableDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<LookupTableDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllTrangThaiKiemKe(response: HttpResponseBase): Observable<LookupTableDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(LookupTableDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LookupTableDto[]>(<any>null);
    }

    /**
     * @param taiSanId (optional) 
     * @return Success
     */
    deleteTaiSan(taiSanId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/LookupTable/DeleteTaiSan?";
        if (taiSanId === null)
            throw new Error("The parameter 'taiSanId' cannot be null.");
        else if (taiSanId !== undefined)
            url_ += "taiSanId=" + encodeURIComponent("" + taiSanId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteTaiSan(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteTaiSan(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteTaiSan(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param taiSanId (optional) 
     * @return Success
     */
    deleteTaiSanList(taiSanId: number[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/LookupTable/DeleteTaiSanList?";
        if (taiSanId !== undefined)
            taiSanId && taiSanId.forEach(item => { url_ += "taiSanId=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteTaiSanList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteTaiSanList(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteTaiSanList(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @param toChucId (optional) 
     * @return Success
     */
    getAllNguoiDung(keyword: string | null | undefined, toChucId: number | null | undefined): Observable<UserForViewDto[]> {
        let url_ = this.baseUrl + "/api/services/app/LookupTable/GetAllNguoiDung?";
        if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (toChucId !== undefined)
            url_ += "ToChucId=" + encodeURIComponent("" + toChucId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllNguoiDung(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllNguoiDung(<any>response_);
                } catch (e) {
                    return <Observable<UserForViewDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserForViewDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllNguoiDung(response: HttpResponseBase): Observable<UserForViewDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(UserForViewDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserForViewDto[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changePassword(body: ChangePasswordDto | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/LookupTable/ChangePassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangePassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangePassword(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processChangePassword(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param taiSanId (optional) 
     * @return Success
     */
    getTrangThaiTaiSanTruoc(taiSanId: number | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/LookupTable/GetTrangThaiTaiSanTruoc?";
        if (taiSanId === null)
            throw new Error("The parameter 'taiSanId' cannot be null.");
        else if (taiSanId !== undefined)
            url_ += "taiSanId=" + encodeURIComponent("" + taiSanId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTrangThaiTaiSanTruoc(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTrangThaiTaiSanTruoc(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetTrangThaiTaiSanTruoc(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param userIdList (optional) 
     * @return Success
     */
    getAllUserNameById(userIdList: number[] | null | undefined): Observable<Int64LookupTableDto[]> {
        let url_ = this.baseUrl + "/api/services/app/LookupTable/GetAllUserNameById?";
        if (userIdList !== undefined)
            userIdList && userIdList.forEach(item => { url_ += "userIdList=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllUserNameById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllUserNameById(<any>response_);
                } catch (e) {
                    return <Observable<Int64LookupTableDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Int64LookupTableDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllUserNameById(response: HttpResponseBase): Observable<Int64LookupTableDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(Int64LookupTableDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Int64LookupTableDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllViTriDiaLyLookupTable(): Observable<LookupTableDto[]> {
        let url_ = this.baseUrl + "/api/services/app/LookupTable/GetAllViTriDiaLyLookupTable";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllViTriDiaLyLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllViTriDiaLyLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<LookupTableDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<LookupTableDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllViTriDiaLyLookupTable(response: HttpResponseBase): Observable<LookupTableDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(LookupTableDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LookupTableDto[]>(<any>null);
    }

    /**
     * @param rfidCode (optional) 
     * @return Success
     */
    getEPCCode(rfidCode: string | null | undefined): Observable<GetEPCCodeDto> {
        let url_ = this.baseUrl + "/api/services/app/LookupTable/GetEPCCode?";
        if (rfidCode !== undefined)
            url_ += "rfidCode=" + encodeURIComponent("" + rfidCode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEPCCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEPCCode(<any>response_);
                } catch (e) {
                    return <Observable<GetEPCCodeDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetEPCCodeDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetEPCCode(response: HttpResponseBase): Observable<GetEPCCodeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetEPCCodeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetEPCCodeDto>(<any>null);
    }

    /**
     * @param qrCode (optional) 
     * @return Success
     */
    getAssetByQRCode(qrCode: string | null | undefined): Observable<GetForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/LookupTable/GetAssetByQRCode?";
        if (qrCode !== undefined)
            url_ += "qrCode=" + encodeURIComponent("" + qrCode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAssetByQRCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAssetByQRCode(<any>response_);
                } catch (e) {
                    return <Observable<GetForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAssetByQRCode(response: HttpResponseBase): Observable<GetForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetForViewDto>(<any>null);
    }

    /**
     * @return Success
     */
    getAllDotKiemKeNguoiDung(): Observable<Int64LookupTableDto[]> {
        let url_ = this.baseUrl + "/api/services/app/LookupTable/GetAllDotKiemKeNguoiDung";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllDotKiemKeNguoiDung(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllDotKiemKeNguoiDung(<any>response_);
                } catch (e) {
                    return <Observable<Int64LookupTableDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Int64LookupTableDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllDotKiemKeNguoiDung(response: HttpResponseBase): Observable<Int64LookupTableDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(Int64LookupTableDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Int64LookupTableDto[]>(<any>null);
    }

    /**
     * @param dotKiemKeId (optional) 
     * @return Success
     */
    getThongTinDotKiemKe(dotKiemKeId: number | undefined): Observable<ThongTinKiemKeForMobileDto> {
        let url_ = this.baseUrl + "/api/services/app/LookupTable/GetThongTinDotKiemKe?";
        if (dotKiemKeId === null)
            throw new Error("The parameter 'dotKiemKeId' cannot be null.");
        else if (dotKiemKeId !== undefined)
            url_ += "dotKiemKeId=" + encodeURIComponent("" + dotKiemKeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetThongTinDotKiemKe(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetThongTinDotKiemKe(<any>response_);
                } catch (e) {
                    return <Observable<ThongTinKiemKeForMobileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ThongTinKiemKeForMobileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetThongTinDotKiemKe(response: HttpResponseBase): Observable<ThongTinKiemKeForMobileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ThongTinKiemKeForMobileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ThongTinKiemKeForMobileDto>(<any>null);
    }

    /**
     * @return Success
     */
    getAllPhanLoaiTaiSanTrongHeThong(): Observable<LookupTableDto[]> {
        let url_ = this.baseUrl + "/api/services/app/LookupTable/GetAllPhanLoaiTaiSanTrongHeThong";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPhanLoaiTaiSanTrongHeThong(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPhanLoaiTaiSanTrongHeThong(<any>response_);
                } catch (e) {
                    return <Observable<LookupTableDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<LookupTableDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllPhanLoaiTaiSanTrongHeThong(response: HttpResponseBase): Observable<LookupTableDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(LookupTableDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LookupTableDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllChieuTaiSanDiChuyen(): Observable<LookupTableDto[]> {
        let url_ = this.baseUrl + "/api/services/app/LookupTable/GetAllChieuTaiSanDiChuyen";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllChieuTaiSanDiChuyen(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllChieuTaiSanDiChuyen(<any>response_);
                } catch (e) {
                    return <Observable<LookupTableDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<LookupTableDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllChieuTaiSanDiChuyen(response: HttpResponseBase): Observable<LookupTableDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(LookupTableDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LookupTableDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllHoatDong(): Observable<LookupTableDto[]> {
        let url_ = this.baseUrl + "/api/services/app/LookupTable/GetAllHoatDong";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllHoatDong(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllHoatDong(<any>response_);
                } catch (e) {
                    return <Observable<LookupTableDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<LookupTableDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllHoatDong(response: HttpResponseBase): Observable<LookupTableDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(LookupTableDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LookupTableDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllToChucCuaNguoiDangNhapTree(): Observable<FlatTreeSelectDto[]> {
        let url_ = this.baseUrl + "/api/services/app/LookupTable/GetAllToChucCuaNguoiDangNhapTree";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllToChucCuaNguoiDangNhapTree(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllToChucCuaNguoiDangNhapTree(<any>response_);
                } catch (e) {
                    return <Observable<FlatTreeSelectDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<FlatTreeSelectDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllToChucCuaNguoiDangNhapTree(response: HttpResponseBase): Observable<FlatTreeSelectDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(FlatTreeSelectDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FlatTreeSelectDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllToChuc(): Observable<FlatTreeSelectDto[]> {
        let url_ = this.baseUrl + "/api/services/app/LookupTable/GetAllToChuc";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllToChuc(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllToChuc(<any>response_);
                } catch (e) {
                    return <Observable<FlatTreeSelectDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<FlatTreeSelectDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllToChuc(response: HttpResponseBase): Observable<FlatTreeSelectDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(FlatTreeSelectDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FlatTreeSelectDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllToChucTheoNguoiDung(): Observable<FlatTreeSelectDto[]> {
        let url_ = this.baseUrl + "/api/services/app/LookupTable/GetAllToChucTheoNguoiDung";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllToChucTheoNguoiDung(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllToChucTheoNguoiDung(<any>response_);
                } catch (e) {
                    return <Observable<FlatTreeSelectDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<FlatTreeSelectDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllToChucTheoNguoiDung(response: HttpResponseBase): Observable<FlatTreeSelectDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(FlatTreeSelectDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FlatTreeSelectDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllBaoCaoLookupTable(): Observable<LookupTableDto[]> {
        let url_ = this.baseUrl + "/api/services/app/LookupTable/GetAllBaoCaoLookupTable";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllBaoCaoLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllBaoCaoLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<LookupTableDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<LookupTableDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllBaoCaoLookupTable(response: HttpResponseBase): Observable<LookupTableDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(LookupTableDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LookupTableDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllLapLaiLookupTable(): Observable<LookupTableDto[]> {
        let url_ = this.baseUrl + "/api/services/app/LookupTable/GetAllLapLaiLookupTable";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllLapLaiLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllLapLaiLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<LookupTableDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<LookupTableDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllLapLaiLookupTable(response: HttpResponseBase): Observable<LookupTableDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(LookupTableDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LookupTableDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllToChucTheoDangNhapTree(): Observable<TreeviewItemDto[]> {
        let url_ = this.baseUrl + "/api/services/app/LookupTable/GetAllToChucTheoDangNhapTree";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllToChucTheoDangNhapTree(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllToChucTheoDangNhapTree(<any>response_);
                } catch (e) {
                    return <Observable<TreeviewItemDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<TreeviewItemDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllToChucTheoDangNhapTree(response: HttpResponseBase): Observable<TreeviewItemDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(TreeviewItemDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TreeviewItemDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllThangLookupTable(): Observable<LookupTableDto[]> {
        let url_ = this.baseUrl + "/api/services/app/LookupTable/GetAllThangLookupTable";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllThangLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllThangLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<LookupTableDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<LookupTableDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllThangLookupTable(response: HttpResponseBase): Observable<LookupTableDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(LookupTableDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LookupTableDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllQuyLookupTable(): Observable<LookupTableDto[]> {
        let url_ = this.baseUrl + "/api/services/app/LookupTable/GetAllQuyLookupTable";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllQuyLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllQuyLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<LookupTableDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<LookupTableDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllQuyLookupTable(response: HttpResponseBase): Observable<LookupTableDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(LookupTableDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LookupTableDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllThuLookupTable(): Observable<LookupTableDto[]> {
        let url_ = this.baseUrl + "/api/services/app/LookupTable/GetAllThuLookupTable";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllThuLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllThuLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<LookupTableDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<LookupTableDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllThuLookupTable(response: HttpResponseBase): Observable<LookupTableDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(LookupTableDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LookupTableDto[]>(<any>null);
    }

    /**
     * @param phongBan (optional) 
     * @return Success
     */
    getAllNguoiDungTheoPBLookupTable(phongBan: number | null | undefined): Observable<LookupTableDto[]> {
        let url_ = this.baseUrl + "/api/services/app/LookupTable/GetAllNguoiDungTheoPBLookupTable?";
        if (phongBan !== undefined)
            url_ += "phongBan=" + encodeURIComponent("" + phongBan) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllNguoiDungTheoPBLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllNguoiDungTheoPBLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<LookupTableDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<LookupTableDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllNguoiDungTheoPBLookupTable(response: HttpResponseBase): Observable<LookupTableDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(LookupTableDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LookupTableDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllNguonKinhPhi(): Observable<LookupTableDto[]> {
        let url_ = this.baseUrl + "/api/services/app/LookupTable/GetAllNguonKinhPhi";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllNguonKinhPhi(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllNguonKinhPhi(<any>response_);
                } catch (e) {
                    return <Observable<LookupTableDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<LookupTableDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllNguonKinhPhi(response: HttpResponseBase): Observable<LookupTableDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(LookupTableDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LookupTableDto[]>(<any>null);
    }
}

@Injectable()
export class MailServerServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getBaoCao(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MailServer/GetBaoCao";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBaoCao(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBaoCao(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processGetBaoCao(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getRoleLanhDao(): Observable<number[]> {
        let url_ = this.baseUrl + "/api/services/app/MailServer/GetRoleLanhDao";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoleLanhDao(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoleLanhDao(<any>response_);
                } catch (e) {
                    return <Observable<number[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<number[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetRoleLanhDao(response: HttpResponseBase): Observable<number[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number[]>(<any>null);
    }

    /**
     * @return Success
     */
    getForEdit(): Observable<MailServer> {
        let url_ = this.baseUrl + "/api/services/app/MailServer/GetForEdit";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(<any>response_);
                } catch (e) {
                    return <Observable<MailServer>><any>_observableThrow(e);
                }
            } else
                return <Observable<MailServer>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<MailServer> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MailServer.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MailServer>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateMailServer(body: MailServerDto | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/MailServer/UpdateMailServer";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateMailServer(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateMailServer(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateMailServer(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param donViId (optional) 
     * @param body (optional) 
     * @return Success
     */
    sendMailCapPhat(donViId: number | undefined, body: TaiSanChuaSuDungForViewDto[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MailServer/SendMailCapPhat?";
        if (donViId === null)
            throw new Error("The parameter 'donViId' cannot be null.");
        else if (donViId !== undefined)
            url_ += "donViId=" + encodeURIComponent("" + donViId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendMailCapPhat(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendMailCapPhat(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSendMailCapPhat(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param donViId (optional) 
     * @param body (optional) 
     * @return Success
     */
    sendMailThuHoi(donViId: number | null | undefined, body: TaiSanChuaSuDungForViewDto[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MailServer/SendMailThuHoi?";
        if (donViId !== undefined)
            url_ += "donViId=" + encodeURIComponent("" + donViId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendMailThuHoi(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendMailThuHoi(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSendMailThuHoi(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param donViId (optional) 
     * @param body (optional) 
     * @return Success
     */
    sendMailDieuChuyen(donViId: number | null | undefined, body: TaiSanChuaSuDungForViewDto[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MailServer/SendMailDieuChuyen?";
        if (donViId !== undefined)
            url_ += "donViId=" + encodeURIComponent("" + donViId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendMailDieuChuyen(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendMailDieuChuyen(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSendMailDieuChuyen(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param donViBaoId (optional) 
     * @param body (optional) 
     * @return Success
     */
    sendMailBaoHong(donViBaoId: number | null | undefined, body: ViewTaiSanHong[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MailServer/SendMailBaoHong?";
        if (donViBaoId !== undefined)
            url_ += "donViBaoId=" + encodeURIComponent("" + donViBaoId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendMailBaoHong(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendMailBaoHong(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSendMailBaoHong(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sendMailKetQuaBaoDuong(body: ViewTaiSanSuaChuaBaoDuong | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MailServer/SendMailKetQuaBaoDuong";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendMailKetQuaBaoDuong(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendMailKetQuaBaoDuong(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSendMailKetQuaBaoDuong(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param donViBaoId (optional) 
     * @param body (optional) 
     * @return Success
     */
    sendMailBaoMat(donViBaoId: number | null | undefined, body: ViewTaiSanHong[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MailServer/SendMailBaoMat?";
        if (donViBaoId !== undefined)
            url_ += "donViBaoId=" + encodeURIComponent("" + donViBaoId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendMailBaoMat(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendMailBaoMat(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSendMailBaoMat(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sendMailHoanThanhPhieu(body: DuTruMuaSamOutPut | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MailServer/SendMailHoanThanhPhieu";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendMailHoanThanhPhieu(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendMailHoanThanhPhieu(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSendMailHoanThanhPhieu(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sendMailHuyPhieu(body: DuTruMuaSamOutPut | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MailServer/SendMailHuyPhieu";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendMailHuyPhieu(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendMailHuyPhieu(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSendMailHuyPhieu(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param idKiemKe (optional) 
     * @return Success
     */
    sendMailBatDauKiemKe(idKiemKe: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MailServer/SendMailBatDauKiemKe?";
        if (idKiemKe === null)
            throw new Error("The parameter 'idKiemKe' cannot be null.");
        else if (idKiemKe !== undefined)
            url_ += "idKiemKe=" + encodeURIComponent("" + idKiemKe) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendMailBatDauKiemKe(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendMailBatDauKiemKe(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSendMailBatDauKiemKe(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param idKiemKe (optional) 
     * @return Success
     */
    sendMailKetThucKiemKe(idKiemKe: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MailServer/SendMailKetThucKiemKe?";
        if (idKiemKe === null)
            throw new Error("The parameter 'idKiemKe' cannot be null.");
        else if (idKiemKe !== undefined)
            url_ += "idKiemKe=" + encodeURIComponent("" + idKiemKe) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendMailKetThucKiemKe(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendMailKetThucKiemKe(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSendMailKetThucKiemKe(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param donViBaoId (optional) 
     * @param body (optional) 
     * @return Success
     */
    sendMailThanhLy(donViBaoId: number | null | undefined, body: ViewTaiSanThanhLy[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MailServer/SendMailThanhLy?";
        if (donViBaoId !== undefined)
            url_ += "donViBaoId=" + encodeURIComponent("" + donViBaoId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendMailThanhLy(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendMailThanhLy(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSendMailThanhLy(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class NhaCungCapServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param keyword (optional) 
     * @param linhVuc (optional) 
     * @param isSearch (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, linhVuc: number | null | undefined, isSearch: boolean | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<NhaCungCapForViewDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/NhaCungCap/GetAll?";
        if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (linhVuc !== undefined)
            url_ += "LinhVuc=" + encodeURIComponent("" + linhVuc) + "&";
        if (isSearch !== undefined)
            url_ += "IsSearch=" + encodeURIComponent("" + isSearch) + "&";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<NhaCungCapForViewDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<NhaCungCapForViewDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<NhaCungCapForViewDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NhaCungCapForViewDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NhaCungCapForViewDtoPagedResultDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param isView (optional) 
     * @return Success
     */
    getForEdit(id: number | undefined, isView: boolean | undefined): Observable<NhaCungCapCreateInputDto> {
        let url_ = this.baseUrl + "/api/services/app/NhaCungCap/GetForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (isView === null)
            throw new Error("The parameter 'isView' cannot be null.");
        else if (isView !== undefined)
            url_ += "isView=" + encodeURIComponent("" + isView) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(<any>response_);
                } catch (e) {
                    return <Observable<NhaCungCapCreateInputDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<NhaCungCapCreateInputDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<NhaCungCapCreateInputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NhaCungCapCreateInputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NhaCungCapCreateInputDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: NhaCungCapCreateInputDto | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/NhaCungCap/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/NhaCungCap/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    exportToExcel(body: NhaCungCapGetAllInputDto | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/NhaCungCap/ExportToExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processExportToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param filePath (optional) 
     * @return Success
     */
    importFileExcel(filePath: string | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/NhaCungCap/ImportFileExcel?";
        if (filePath !== undefined)
            url_ += "filePath=" + encodeURIComponent("" + filePath) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImportFileExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImportFileExcel(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processImportFileExcel(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param inputEmail (optional) 
     * @return Success
     */
    isEmail(inputEmail: string | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/NhaCungCap/IsEmail?";
        if (inputEmail !== undefined)
            url_ += "inputEmail=" + encodeURIComponent("" + inputEmail) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsEmail(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processIsEmail(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @return Success
     */
    downloadFileMau(): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/NhaCungCap/DownloadFileMau";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadFileMau(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadFileMau(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processDownloadFileMau(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param linkFile (optional) 
     * @return Success
     */
    downloadFileUpload(linkFile: string | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/NhaCungCap/DownloadFileUpload?";
        if (linkFile !== undefined)
            url_ += "linkFile=" + encodeURIComponent("" + linkFile) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadFileUpload(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadFileUpload(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processDownloadFileUpload(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

@Injectable()
export class PhieuDuTruMuaSamServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param keyword (optional) 
     * @param phongBan (optional) 
     * @param isSearch (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, phongBan: number[] | null | undefined, isSearch: boolean | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<DuTruMuaSamOutPutPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/PhieuDuTruMuaSam/GetAll?";
        if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (phongBan !== undefined)
            phongBan && phongBan.forEach(item => { url_ += "PhongBan=" + encodeURIComponent("" + item) + "&"; });
        if (isSearch !== undefined)
            url_ += "IsSearch=" + encodeURIComponent("" + isSearch) + "&";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<DuTruMuaSamOutPutPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DuTruMuaSamOutPutPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<DuTruMuaSamOutPutPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DuTruMuaSamOutPutPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DuTruMuaSamOutPutPagedResultDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getUserDangNhap(input: number | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/PhieuDuTruMuaSam/GetUserDangNhap?";
        if (input === null)
            throw new Error("The parameter 'input' cannot be null.");
        else if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserDangNhap(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserDangNhap(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserDangNhap(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param input (optional) 
     * @param isView (optional) 
     * @return Success
     */
    getForEdit(input: number | undefined, isView: boolean | null | undefined): Observable<CreateDuTruInput> {
        let url_ = this.baseUrl + "/api/services/app/PhieuDuTruMuaSam/GetForEdit?";
        if (input === null)
            throw new Error("The parameter 'input' cannot be null.");
        else if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        if (isView !== undefined)
            url_ += "isView=" + encodeURIComponent("" + isView) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(<any>response_);
                } catch (e) {
                    return <Observable<CreateDuTruInput>><any>_observableThrow(e);
                }
            } else
                return <Observable<CreateDuTruInput>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<CreateDuTruInput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateDuTruInput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateDuTruInput>(<any>null);
    }

    /**
     * @param linkFile (optional) 
     * @return Success
     */
    downloadFileUpload(linkFile: string | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/PhieuDuTruMuaSam/DownloadFileUpload?";
        if (linkFile !== undefined)
            url_ += "linkFile=" + encodeURIComponent("" + linkFile) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadFileUpload(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadFileUpload(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processDownloadFileUpload(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    deleted(input: number | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/PhieuDuTruMuaSam/Deleted?";
        if (input === null)
            throw new Error("The parameter 'input' cannot be null.");
        else if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleted(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleted(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processDeleted(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    hoanThanh(input: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PhieuDuTruMuaSam/HoanThanh?";
        if (input === null)
            throw new Error("The parameter 'input' cannot be null.");
        else if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHoanThanh(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHoanThanh(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processHoanThanh(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    huyBo(input: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PhieuDuTruMuaSam/HuyBo?";
        if (input === null)
            throw new Error("The parameter 'input' cannot be null.");
        else if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHuyBo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHuyBo(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processHuyBo(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    xoaList(body: number[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PhieuDuTruMuaSam/XoaList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processXoaList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processXoaList(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processXoaList(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    exportToExcel(body: DuTruMuaSamInput | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/PhieuDuTruMuaSam/ExportToExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processExportToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateDuTruInput | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/PhieuDuTruMuaSam/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }
}

@Injectable()
export class RoleServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param keyword (optional) 
     * @param isSearch (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, isSearch: boolean | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<RoleDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetAll?";
        if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (isSearch !== undefined)
            url_ += "IsSearch=" + encodeURIComponent("" + isSearch) + "&";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<RoleDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoleDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<RoleDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleDtoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateRoleDto | undefined): Observable<RoleDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<RoleDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoleDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<RoleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleDto>(<any>null);
    }

    /**
     * @param permission (optional) 
     * @return Success
     */
    getRoles(permission: string | null | undefined): Observable<RoleListDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetRoles?";
        if (permission !== undefined)
            url_ += "Permission=" + encodeURIComponent("" + permission) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoles(<any>response_);
                } catch (e) {
                    return <Observable<RoleListDtoListResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoleListDtoListResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetRoles(response: HttpResponseBase): Observable<RoleListDtoListResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleListDtoListResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleListDtoListResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: RoleDto | undefined): Observable<RoleDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<RoleDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoleDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<RoleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleDto>(<any>null);
    }

    /**
     * @param roleName (optional) 
     * @param displayRoleName (optional) 
     * @param id (optional) 
     * @return Success
     */
    checkExist(roleName: string | null | undefined, displayRoleName: string | null | undefined, id: number | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Role/CheckExist?";
        if (roleName !== undefined)
            url_ += "roleName=" + encodeURIComponent("" + roleName) + "&";
        if (displayRoleName !== undefined)
            url_ += "displayRoleName=" + encodeURIComponent("" + displayRoleName) + "&";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckExist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckExist(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCheckExist(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Role/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getAllPermissions(): Observable<PermissionDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetAllPermissions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPermissions(<any>response_);
                } catch (e) {
                    return <Observable<PermissionDtoListResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PermissionDtoListResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllPermissions(response: HttpResponseBase): Observable<PermissionDtoListResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PermissionDtoListResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PermissionDtoListResultDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getRoleForEdit(id: number | undefined): Observable<GetRoleForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetRoleForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoleForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoleForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetRoleForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetRoleForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetRoleForEdit(response: HttpResponseBase): Observable<GetRoleForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetRoleForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRoleForEditOutput>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<RoleDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<RoleDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoleDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<RoleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleDto>(<any>null);
    }
}

@Injectable()
export class SessionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getCurrentLoginInformations(): Observable<GetCurrentLoginInformationsOutput> {
        let url_ = this.baseUrl + "/api/services/app/Session/GetCurrentLoginInformations";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrentLoginInformations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentLoginInformations(<any>response_);
                } catch (e) {
                    return <Observable<GetCurrentLoginInformationsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetCurrentLoginInformationsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetCurrentLoginInformations(response: HttpResponseBase): Observable<GetCurrentLoginInformationsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetCurrentLoginInformationsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCurrentLoginInformationsOutput>(<any>null);
    }
}

@Injectable()
export class TaiSanChuaSuDungServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param keyWord (optional) 
     * @param phongBanQuanLyId (optional) 
     * @param loaiTaiSanId (optional) 
     * @param nhaCungCapId (optional) 
     * @param tinhTrangSuDung (optional) 
     * @param isSearch (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyWord: string | null | undefined, phongBanQuanLyId: number[] | null | undefined, loaiTaiSanId: number | null | undefined, nhaCungCapId: number | null | undefined, tinhTrangSuDung: number | null | undefined, isSearch: boolean | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<TaiSanChuaSuDungForViewDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/TaiSanChuaSuDung/GetAll?";
        if (keyWord !== undefined)
            url_ += "KeyWord=" + encodeURIComponent("" + keyWord) + "&";
        if (phongBanQuanLyId !== undefined)
            phongBanQuanLyId && phongBanQuanLyId.forEach(item => { url_ += "PhongBanQuanLyId=" + encodeURIComponent("" + item) + "&"; });
        if (loaiTaiSanId !== undefined)
            url_ += "LoaiTaiSanId=" + encodeURIComponent("" + loaiTaiSanId) + "&";
        if (nhaCungCapId !== undefined)
            url_ += "NhaCungCapId=" + encodeURIComponent("" + nhaCungCapId) + "&";
        if (tinhTrangSuDung !== undefined)
            url_ += "TinhTrangSuDung=" + encodeURIComponent("" + tinhTrangSuDung) + "&";
        if (isSearch !== undefined)
            url_ += "IsSearch=" + encodeURIComponent("" + isSearch) + "&";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<TaiSanChuaSuDungForViewDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TaiSanChuaSuDungForViewDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<TaiSanChuaSuDungForViewDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TaiSanChuaSuDungForViewDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TaiSanChuaSuDungForViewDtoPagedResultDto>(<any>null);
    }

    /**
     * @param keyWord (optional) 
     * @param phongBanQuanLyId (optional) 
     * @param loaiTaiSanId (optional) 
     * @param nhaCungCapId (optional) 
     * @param tinhTrangSuDung (optional) 
     * @param isSearch (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllByMaAndSerialNumber(keyWord: string | null | undefined, phongBanQuanLyId: number[] | null | undefined, loaiTaiSanId: number | null | undefined, nhaCungCapId: number | null | undefined, tinhTrangSuDung: number | null | undefined, isSearch: boolean | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<TaiSanChuaSuDungForViewDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/TaiSanChuaSuDung/GetAllByMaAndSerialNumber?";
        if (keyWord !== undefined)
            url_ += "KeyWord=" + encodeURIComponent("" + keyWord) + "&";
        if (phongBanQuanLyId !== undefined)
            phongBanQuanLyId && phongBanQuanLyId.forEach(item => { url_ += "PhongBanQuanLyId=" + encodeURIComponent("" + item) + "&"; });
        if (loaiTaiSanId !== undefined)
            url_ += "LoaiTaiSanId=" + encodeURIComponent("" + loaiTaiSanId) + "&";
        if (nhaCungCapId !== undefined)
            url_ += "NhaCungCapId=" + encodeURIComponent("" + nhaCungCapId) + "&";
        if (tinhTrangSuDung !== undefined)
            url_ += "TinhTrangSuDung=" + encodeURIComponent("" + tinhTrangSuDung) + "&";
        if (isSearch !== undefined)
            url_ += "IsSearch=" + encodeURIComponent("" + isSearch) + "&";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllByMaAndSerialNumber(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllByMaAndSerialNumber(<any>response_);
                } catch (e) {
                    return <Observable<TaiSanChuaSuDungForViewDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TaiSanChuaSuDungForViewDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllByMaAndSerialNumber(response: HttpResponseBase): Observable<TaiSanChuaSuDungForViewDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TaiSanChuaSuDungForViewDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TaiSanChuaSuDungForViewDtoPagedResultDto>(<any>null);
    }

    /**
     * @param keyWord (optional) 
     * @param phongBanQuanLyId (optional) 
     * @param loaiTaiSanId (optional) 
     * @param nhaCungCapId (optional) 
     * @param tinhTrangSuDung (optional) 
     * @param isSearch (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllTaiSanCapPhat(keyWord: string | null | undefined, phongBanQuanLyId: number[] | null | undefined, loaiTaiSanId: number | null | undefined, nhaCungCapId: number | null | undefined, tinhTrangSuDung: number | null | undefined, isSearch: boolean | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<TaiSanChuaSuDungForViewDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/TaiSanChuaSuDung/GetAllTaiSanCapPhat?";
        if (keyWord !== undefined)
            url_ += "KeyWord=" + encodeURIComponent("" + keyWord) + "&";
        if (phongBanQuanLyId !== undefined)
            phongBanQuanLyId && phongBanQuanLyId.forEach(item => { url_ += "PhongBanQuanLyId=" + encodeURIComponent("" + item) + "&"; });
        if (loaiTaiSanId !== undefined)
            url_ += "LoaiTaiSanId=" + encodeURIComponent("" + loaiTaiSanId) + "&";
        if (nhaCungCapId !== undefined)
            url_ += "NhaCungCapId=" + encodeURIComponent("" + nhaCungCapId) + "&";
        if (tinhTrangSuDung !== undefined)
            url_ += "TinhTrangSuDung=" + encodeURIComponent("" + tinhTrangSuDung) + "&";
        if (isSearch !== undefined)
            url_ += "IsSearch=" + encodeURIComponent("" + isSearch) + "&";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllTaiSanCapPhat(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllTaiSanCapPhat(<any>response_);
                } catch (e) {
                    return <Observable<TaiSanChuaSuDungForViewDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TaiSanChuaSuDungForViewDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllTaiSanCapPhat(response: HttpResponseBase): Observable<TaiSanChuaSuDungForViewDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TaiSanChuaSuDungForViewDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TaiSanChuaSuDungForViewDtoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    capPhatTaiSan(body: PhieuTaiSanCreateInputDto | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/TaiSanChuaSuDung/CapPhatTaiSan";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCapPhatTaiSan(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCapPhatTaiSan(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCapPhatTaiSan(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }
}

@Injectable()
export class TaiSanDangSuDungServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param keyWord (optional) 
     * @param phongBanQuanLyId (optional) 
     * @param loaiTaiSanId (optional) 
     * @param nhaCungCapId (optional) 
     * @param tinhTrangSuDung (optional) 
     * @param isSearch (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyWord: string | null | undefined, phongBanQuanLyId: number[] | null | undefined, loaiTaiSanId: number | null | undefined, nhaCungCapId: number | null | undefined, tinhTrangSuDung: number | null | undefined, isSearch: boolean | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<TaiSanChuaSuDungForViewDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/TaiSanDangSuDung/GetAll?";
        if (keyWord !== undefined)
            url_ += "KeyWord=" + encodeURIComponent("" + keyWord) + "&";
        if (phongBanQuanLyId !== undefined)
            phongBanQuanLyId && phongBanQuanLyId.forEach(item => { url_ += "PhongBanQuanLyId=" + encodeURIComponent("" + item) + "&"; });
        if (loaiTaiSanId !== undefined)
            url_ += "LoaiTaiSanId=" + encodeURIComponent("" + loaiTaiSanId) + "&";
        if (nhaCungCapId !== undefined)
            url_ += "NhaCungCapId=" + encodeURIComponent("" + nhaCungCapId) + "&";
        if (tinhTrangSuDung !== undefined)
            url_ += "TinhTrangSuDung=" + encodeURIComponent("" + tinhTrangSuDung) + "&";
        if (isSearch !== undefined)
            url_ += "IsSearch=" + encodeURIComponent("" + isSearch) + "&";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<TaiSanChuaSuDungForViewDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TaiSanChuaSuDungForViewDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<TaiSanChuaSuDungForViewDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TaiSanChuaSuDungForViewDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TaiSanChuaSuDungForViewDtoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    hoanTacTaiSanDangSuDung(body: EntityDto[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TaiSanDangSuDung/HoanTacTaiSanDangSuDung";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHoanTacTaiSanDangSuDung(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHoanTacTaiSanDangSuDung(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processHoanTacTaiSanDangSuDung(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    hoanTacTaiSanList(body: number[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TaiSanDangSuDung/HoanTacTaiSanList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHoanTacTaiSanList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHoanTacTaiSanList(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processHoanTacTaiSanList(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param keyWord (optional) 
     * @param phongBanQuanLyId (optional) 
     * @param loaiTaiSanId (optional) 
     * @param nhaCungCapId (optional) 
     * @param tinhTrangSuDung (optional) 
     * @param isSearch (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllByMaAndSerialNumberTsdsd(keyWord: string | null | undefined, phongBanQuanLyId: number[] | null | undefined, loaiTaiSanId: number | null | undefined, nhaCungCapId: number | null | undefined, tinhTrangSuDung: number | null | undefined, isSearch: boolean | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<TaiSanChuaSuDungForViewDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/TaiSanDangSuDung/GetAllByMaAndSerialNumberTsdsd?";
        if (keyWord !== undefined)
            url_ += "KeyWord=" + encodeURIComponent("" + keyWord) + "&";
        if (phongBanQuanLyId !== undefined)
            phongBanQuanLyId && phongBanQuanLyId.forEach(item => { url_ += "PhongBanQuanLyId=" + encodeURIComponent("" + item) + "&"; });
        if (loaiTaiSanId !== undefined)
            url_ += "LoaiTaiSanId=" + encodeURIComponent("" + loaiTaiSanId) + "&";
        if (nhaCungCapId !== undefined)
            url_ += "NhaCungCapId=" + encodeURIComponent("" + nhaCungCapId) + "&";
        if (tinhTrangSuDung !== undefined)
            url_ += "TinhTrangSuDung=" + encodeURIComponent("" + tinhTrangSuDung) + "&";
        if (isSearch !== undefined)
            url_ += "IsSearch=" + encodeURIComponent("" + isSearch) + "&";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllByMaAndSerialNumberTsdsd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllByMaAndSerialNumberTsdsd(<any>response_);
                } catch (e) {
                    return <Observable<TaiSanChuaSuDungForViewDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TaiSanChuaSuDungForViewDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllByMaAndSerialNumberTsdsd(response: HttpResponseBase): Observable<TaiSanChuaSuDungForViewDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TaiSanChuaSuDungForViewDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TaiSanChuaSuDungForViewDtoPagedResultDto>(<any>null);
    }

    /**
     * @param keyWord (optional) 
     * @param phongBanQuanLyId (optional) 
     * @param loaiTaiSanId (optional) 
     * @param nhaCungCapId (optional) 
     * @param tinhTrangSuDung (optional) 
     * @param isSearch (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllTaiSanCapPhat(keyWord: string | null | undefined, phongBanQuanLyId: number[] | null | undefined, loaiTaiSanId: number | null | undefined, nhaCungCapId: number | null | undefined, tinhTrangSuDung: number | null | undefined, isSearch: boolean | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<TaiSanChuaSuDungForViewDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/TaiSanDangSuDung/GetAllTaiSanCapPhat?";
        if (keyWord !== undefined)
            url_ += "KeyWord=" + encodeURIComponent("" + keyWord) + "&";
        if (phongBanQuanLyId !== undefined)
            phongBanQuanLyId && phongBanQuanLyId.forEach(item => { url_ += "PhongBanQuanLyId=" + encodeURIComponent("" + item) + "&"; });
        if (loaiTaiSanId !== undefined)
            url_ += "LoaiTaiSanId=" + encodeURIComponent("" + loaiTaiSanId) + "&";
        if (nhaCungCapId !== undefined)
            url_ += "NhaCungCapId=" + encodeURIComponent("" + nhaCungCapId) + "&";
        if (tinhTrangSuDung !== undefined)
            url_ += "TinhTrangSuDung=" + encodeURIComponent("" + tinhTrangSuDung) + "&";
        if (isSearch !== undefined)
            url_ += "IsSearch=" + encodeURIComponent("" + isSearch) + "&";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllTaiSanCapPhat(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllTaiSanCapPhat(<any>response_);
                } catch (e) {
                    return <Observable<TaiSanChuaSuDungForViewDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TaiSanChuaSuDungForViewDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllTaiSanCapPhat(response: HttpResponseBase): Observable<TaiSanChuaSuDungForViewDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TaiSanChuaSuDungForViewDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TaiSanChuaSuDungForViewDtoPagedResultDto>(<any>null);
    }
}

@Injectable()
export class TaiSanHongServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param tenTaiSan (optional) 
     * @param phongBanqQL (optional) 
     * @param loaiTaiSan (optional) 
     * @param nhaCungCap (optional) 
     * @param isSearch (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllTaiSanHong(tenTaiSan: string | null | undefined, phongBanqQL: number[] | null | undefined, loaiTaiSan: number | null | undefined, nhaCungCap: string | null | undefined, isSearch: boolean | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<ViewTaiSanHongPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/TaiSanHong/GetAllTaiSanHong?";
        if (tenTaiSan !== undefined)
            url_ += "TenTaiSan=" + encodeURIComponent("" + tenTaiSan) + "&";
        if (phongBanqQL !== undefined)
            phongBanqQL && phongBanqQL.forEach(item => { url_ += "PhongBanqQL=" + encodeURIComponent("" + item) + "&"; });
        if (loaiTaiSan !== undefined)
            url_ += "LoaiTaiSan=" + encodeURIComponent("" + loaiTaiSan) + "&";
        if (nhaCungCap !== undefined)
            url_ += "NhaCungCap=" + encodeURIComponent("" + nhaCungCap) + "&";
        if (isSearch !== undefined)
            url_ += "IsSearch=" + encodeURIComponent("" + isSearch) + "&";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllTaiSanHong(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllTaiSanHong(<any>response_);
                } catch (e) {
                    return <Observable<ViewTaiSanHongPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ViewTaiSanHongPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllTaiSanHong(response: HttpResponseBase): Observable<ViewTaiSanHongPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ViewTaiSanHongPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ViewTaiSanHongPagedResultDto>(<any>null);
    }

    /**
     * @param tenTaiSan (optional) 
     * @param phongBanqQL (optional) 
     * @param loaiTaiSan (optional) 
     * @param isSearch (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllTaiSan(tenTaiSan: string | null | undefined, phongBanqQL: number[] | null | undefined, loaiTaiSan: number | null | undefined, isSearch: boolean | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<ViewTaiSanPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/TaiSanHong/GetAllTaiSan?";
        if (tenTaiSan !== undefined)
            url_ += "TenTaiSan=" + encodeURIComponent("" + tenTaiSan) + "&";
        if (phongBanqQL !== undefined)
            phongBanqQL && phongBanqQL.forEach(item => { url_ += "PhongBanqQL=" + encodeURIComponent("" + item) + "&"; });
        if (loaiTaiSan !== undefined)
            url_ += "LoaiTaiSan=" + encodeURIComponent("" + loaiTaiSan) + "&";
        if (isSearch !== undefined)
            url_ += "IsSearch=" + encodeURIComponent("" + isSearch) + "&";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllTaiSan(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllTaiSan(<any>response_);
                } catch (e) {
                    return <Observable<ViewTaiSanPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ViewTaiSanPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllTaiSan(response: HttpResponseBase): Observable<ViewTaiSanPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ViewTaiSanPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ViewTaiSanPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createTaiSanHong(body: PhieuTaiSanCreateInputDto | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/TaiSanHong/CreateTaiSanHong";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateTaiSanHong(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateTaiSanHong(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreateTaiSanHong(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    hoanTacTaiSanHong(body: EntityDto[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TaiSanHong/HoanTacTaiSanHong";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHoanTacTaiSanHong(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHoanTacTaiSanHong(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processHoanTacTaiSanHong(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class TaiSanHuyServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param tenTaiSan (optional) 
     * @param phongBanqQL (optional) 
     * @param loaiTaiSan (optional) 
     * @param nhaCungCap (optional) 
     * @param isSearch (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllTaiSanHuy(tenTaiSan: string | null | undefined, phongBanqQL: number[] | null | undefined, loaiTaiSan: number | null | undefined, nhaCungCap: string | null | undefined, isSearch: boolean | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<ViewTaiSanHuyPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/TaiSanHuy/GetAllTaiSanHuy?";
        if (tenTaiSan !== undefined)
            url_ += "TenTaiSan=" + encodeURIComponent("" + tenTaiSan) + "&";
        if (phongBanqQL !== undefined)
            phongBanqQL && phongBanqQL.forEach(item => { url_ += "PhongBanqQL=" + encodeURIComponent("" + item) + "&"; });
        if (loaiTaiSan !== undefined)
            url_ += "LoaiTaiSan=" + encodeURIComponent("" + loaiTaiSan) + "&";
        if (nhaCungCap !== undefined)
            url_ += "NhaCungCap=" + encodeURIComponent("" + nhaCungCap) + "&";
        if (isSearch !== undefined)
            url_ += "IsSearch=" + encodeURIComponent("" + isSearch) + "&";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllTaiSanHuy(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllTaiSanHuy(<any>response_);
                } catch (e) {
                    return <Observable<ViewTaiSanHuyPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ViewTaiSanHuyPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllTaiSanHuy(response: HttpResponseBase): Observable<ViewTaiSanHuyPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ViewTaiSanHuyPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ViewTaiSanHuyPagedResultDto>(<any>null);
    }

    /**
     * @param tenTaiSan (optional) 
     * @param phongBanqQL (optional) 
     * @param loaiTaiSan (optional) 
     * @param isSearch (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllTaiSan(tenTaiSan: string | null | undefined, phongBanqQL: number[] | null | undefined, loaiTaiSan: number | null | undefined, isSearch: boolean | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<ViewTaiSanPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/TaiSanHuy/GetAllTaiSan?";
        if (tenTaiSan !== undefined)
            url_ += "TenTaiSan=" + encodeURIComponent("" + tenTaiSan) + "&";
        if (phongBanqQL !== undefined)
            phongBanqQL && phongBanqQL.forEach(item => { url_ += "PhongBanqQL=" + encodeURIComponent("" + item) + "&"; });
        if (loaiTaiSan !== undefined)
            url_ += "LoaiTaiSan=" + encodeURIComponent("" + loaiTaiSan) + "&";
        if (isSearch !== undefined)
            url_ += "IsSearch=" + encodeURIComponent("" + isSearch) + "&";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllTaiSan(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllTaiSan(<any>response_);
                } catch (e) {
                    return <Observable<ViewTaiSanPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ViewTaiSanPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllTaiSan(response: HttpResponseBase): Observable<ViewTaiSanPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ViewTaiSanPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ViewTaiSanPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createTaiSanHuy(body: PhieuTaiSanCreateInputDto | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/TaiSanHuy/CreateTaiSanHuy";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateTaiSanHuy(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateTaiSanHuy(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreateTaiSanHuy(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    hoanTacTaiSanHuy(body: EntityDto[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TaiSanHuy/HoanTacTaiSanHuy";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHoanTacTaiSanHuy(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHoanTacTaiSanHuy(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processHoanTacTaiSanHuy(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class TaiSanMatServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param tenTaiSan (optional) 
     * @param phongBanqQL (optional) 
     * @param loaiTaiSan (optional) 
     * @param nhaCungCap (optional) 
     * @param isSearch (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllTaiSanMat(tenTaiSan: string | null | undefined, phongBanqQL: number[] | null | undefined, loaiTaiSan: number | null | undefined, nhaCungCap: string | null | undefined, isSearch: boolean | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<ViewTaiSanMatPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/TaiSanMat/GetAllTaiSanMat?";
        if (tenTaiSan !== undefined)
            url_ += "TenTaiSan=" + encodeURIComponent("" + tenTaiSan) + "&";
        if (phongBanqQL !== undefined)
            phongBanqQL && phongBanqQL.forEach(item => { url_ += "PhongBanqQL=" + encodeURIComponent("" + item) + "&"; });
        if (loaiTaiSan !== undefined)
            url_ += "LoaiTaiSan=" + encodeURIComponent("" + loaiTaiSan) + "&";
        if (nhaCungCap !== undefined)
            url_ += "NhaCungCap=" + encodeURIComponent("" + nhaCungCap) + "&";
        if (isSearch !== undefined)
            url_ += "IsSearch=" + encodeURIComponent("" + isSearch) + "&";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllTaiSanMat(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllTaiSanMat(<any>response_);
                } catch (e) {
                    return <Observable<ViewTaiSanMatPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ViewTaiSanMatPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllTaiSanMat(response: HttpResponseBase): Observable<ViewTaiSanMatPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ViewTaiSanMatPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ViewTaiSanMatPagedResultDto>(<any>null);
    }

    /**
     * @param tenTaiSan (optional) 
     * @param phongBanqQL (optional) 
     * @param loaiTaiSan (optional) 
     * @param isSearch (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllTaiSan(tenTaiSan: string | null | undefined, phongBanqQL: number[] | null | undefined, loaiTaiSan: number | null | undefined, isSearch: boolean | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<ViewTaiSanPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/TaiSanMat/GetAllTaiSan?";
        if (tenTaiSan !== undefined)
            url_ += "TenTaiSan=" + encodeURIComponent("" + tenTaiSan) + "&";
        if (phongBanqQL !== undefined)
            phongBanqQL && phongBanqQL.forEach(item => { url_ += "PhongBanqQL=" + encodeURIComponent("" + item) + "&"; });
        if (loaiTaiSan !== undefined)
            url_ += "LoaiTaiSan=" + encodeURIComponent("" + loaiTaiSan) + "&";
        if (isSearch !== undefined)
            url_ += "IsSearch=" + encodeURIComponent("" + isSearch) + "&";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllTaiSan(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllTaiSan(<any>response_);
                } catch (e) {
                    return <Observable<ViewTaiSanPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ViewTaiSanPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllTaiSan(response: HttpResponseBase): Observable<ViewTaiSanPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ViewTaiSanPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ViewTaiSanPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createTaiSanMat(body: PhieuTaiSanCreateInputDto | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/TaiSanMat/CreateTaiSanMat";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateTaiSanMat(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateTaiSanMat(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreateTaiSanMat(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    hoanTacTaiSanMat(body: EntityDto[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TaiSanMat/HoanTacTaiSanMat";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHoanTacTaiSanMat(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHoanTacTaiSanMat(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processHoanTacTaiSanMat(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class TaiSanSuaChuaBaoDuongServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param tenTaiSan (optional) 
     * @param phongBanqQL (optional) 
     * @param loaiTaiSan (optional) 
     * @param nhaCungCap (optional) 
     * @param hinhThuc (optional) 
     * @param trangThai (optional) 
     * @param isSearch (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllTaiSanSuaChuaBaoDuong(tenTaiSan: string | null | undefined, phongBanqQL: number[] | null | undefined, loaiTaiSan: number | null | undefined, nhaCungCap: string | null | undefined, hinhThuc: number | null | undefined, trangThai: number | null | undefined, isSearch: boolean | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<ViewTaiSanSuaChuaBaoDuongPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/TaiSanSuaChuaBaoDuong/GetAllTaiSanSuaChuaBaoDuong?";
        if (tenTaiSan !== undefined)
            url_ += "TenTaiSan=" + encodeURIComponent("" + tenTaiSan) + "&";
        if (phongBanqQL !== undefined)
            phongBanqQL && phongBanqQL.forEach(item => { url_ += "PhongBanqQL=" + encodeURIComponent("" + item) + "&"; });
        if (loaiTaiSan !== undefined)
            url_ += "LoaiTaiSan=" + encodeURIComponent("" + loaiTaiSan) + "&";
        if (nhaCungCap !== undefined)
            url_ += "NhaCungCap=" + encodeURIComponent("" + nhaCungCap) + "&";
        if (hinhThuc !== undefined)
            url_ += "HinhThuc=" + encodeURIComponent("" + hinhThuc) + "&";
        if (trangThai !== undefined)
            url_ += "TrangThai=" + encodeURIComponent("" + trangThai) + "&";
        if (isSearch !== undefined)
            url_ += "IsSearch=" + encodeURIComponent("" + isSearch) + "&";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllTaiSanSuaChuaBaoDuong(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllTaiSanSuaChuaBaoDuong(<any>response_);
                } catch (e) {
                    return <Observable<ViewTaiSanSuaChuaBaoDuongPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ViewTaiSanSuaChuaBaoDuongPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllTaiSanSuaChuaBaoDuong(response: HttpResponseBase): Observable<ViewTaiSanSuaChuaBaoDuongPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ViewTaiSanSuaChuaBaoDuongPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ViewTaiSanSuaChuaBaoDuongPagedResultDto>(<any>null);
    }

    /**
     * @param tenTaiSan (optional) 
     * @param phongBanqQL (optional) 
     * @param loaiTaiSan (optional) 
     * @param isSearch (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllTaiSan(tenTaiSan: string | null | undefined, phongBanqQL: number[] | null | undefined, loaiTaiSan: number | null | undefined, isSearch: boolean | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<ViewTaiSanPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/TaiSanSuaChuaBaoDuong/GetAllTaiSan?";
        if (tenTaiSan !== undefined)
            url_ += "TenTaiSan=" + encodeURIComponent("" + tenTaiSan) + "&";
        if (phongBanqQL !== undefined)
            phongBanqQL && phongBanqQL.forEach(item => { url_ += "PhongBanqQL=" + encodeURIComponent("" + item) + "&"; });
        if (loaiTaiSan !== undefined)
            url_ += "LoaiTaiSan=" + encodeURIComponent("" + loaiTaiSan) + "&";
        if (isSearch !== undefined)
            url_ += "IsSearch=" + encodeURIComponent("" + isSearch) + "&";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllTaiSan(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllTaiSan(<any>response_);
                } catch (e) {
                    return <Observable<ViewTaiSanPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ViewTaiSanPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllTaiSan(response: HttpResponseBase): Observable<ViewTaiSanPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ViewTaiSanPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ViewTaiSanPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    hoanTacTaiSanSuaChuaBaoDuong(body: EntityDto[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TaiSanSuaChuaBaoDuong/HoanTacTaiSanSuaChuaBaoDuong";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHoanTacTaiSanSuaChuaBaoDuong(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHoanTacTaiSanSuaChuaBaoDuong(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processHoanTacTaiSanSuaChuaBaoDuong(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    editTaiSanSuaChuaBaoDuong(body: ViewTaiSanSuaChuaBaoDuong | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/TaiSanSuaChuaBaoDuong/EditTaiSanSuaChuaBaoDuong";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditTaiSanSuaChuaBaoDuong(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditTaiSanSuaChuaBaoDuong(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processEditTaiSanSuaChuaBaoDuong(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createTaiSanSuaChuaBaoDuong(body: PhieuTaiSanCreateInputDto | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/TaiSanSuaChuaBaoDuong/CreateTaiSanSuaChuaBaoDuong";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateTaiSanSuaChuaBaoDuong(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateTaiSanSuaChuaBaoDuong(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreateTaiSanSuaChuaBaoDuong(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }
}

@Injectable()
export class TaiSanThanhLyServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param tenTaiSan (optional) 
     * @param phongBanqQL (optional) 
     * @param loaiTaiSan (optional) 
     * @param nhaCungCap (optional) 
     * @param isSearch (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllTaiSanThanhLy(tenTaiSan: string | null | undefined, phongBanqQL: number[] | null | undefined, loaiTaiSan: number | null | undefined, nhaCungCap: string | null | undefined, isSearch: boolean | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<ViewTaiSanThanhLyPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/TaiSanThanhLy/GetAllTaiSanThanhLy?";
        if (tenTaiSan !== undefined)
            url_ += "TenTaiSan=" + encodeURIComponent("" + tenTaiSan) + "&";
        if (phongBanqQL !== undefined)
            phongBanqQL && phongBanqQL.forEach(item => { url_ += "PhongBanqQL=" + encodeURIComponent("" + item) + "&"; });
        if (loaiTaiSan !== undefined)
            url_ += "LoaiTaiSan=" + encodeURIComponent("" + loaiTaiSan) + "&";
        if (nhaCungCap !== undefined)
            url_ += "NhaCungCap=" + encodeURIComponent("" + nhaCungCap) + "&";
        if (isSearch !== undefined)
            url_ += "IsSearch=" + encodeURIComponent("" + isSearch) + "&";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllTaiSanThanhLy(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllTaiSanThanhLy(<any>response_);
                } catch (e) {
                    return <Observable<ViewTaiSanThanhLyPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ViewTaiSanThanhLyPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllTaiSanThanhLy(response: HttpResponseBase): Observable<ViewTaiSanThanhLyPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ViewTaiSanThanhLyPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ViewTaiSanThanhLyPagedResultDto>(<any>null);
    }

    /**
     * @param tenTaiSan (optional) 
     * @param phongBanqQL (optional) 
     * @param loaiTaiSan (optional) 
     * @param isSearch (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllTaiSan(tenTaiSan: string | null | undefined, phongBanqQL: number[] | null | undefined, loaiTaiSan: number | null | undefined, isSearch: boolean | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<ViewTaiSanPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/TaiSanThanhLy/GetAllTaiSan?";
        if (tenTaiSan !== undefined)
            url_ += "TenTaiSan=" + encodeURIComponent("" + tenTaiSan) + "&";
        if (phongBanqQL !== undefined)
            phongBanqQL && phongBanqQL.forEach(item => { url_ += "PhongBanqQL=" + encodeURIComponent("" + item) + "&"; });
        if (loaiTaiSan !== undefined)
            url_ += "LoaiTaiSan=" + encodeURIComponent("" + loaiTaiSan) + "&";
        if (isSearch !== undefined)
            url_ += "IsSearch=" + encodeURIComponent("" + isSearch) + "&";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllTaiSan(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllTaiSan(<any>response_);
                } catch (e) {
                    return <Observable<ViewTaiSanPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ViewTaiSanPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllTaiSan(response: HttpResponseBase): Observable<ViewTaiSanPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ViewTaiSanPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ViewTaiSanPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createTaiSanThanhLy(body: PhieuTaiSanCreateInputDto | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/TaiSanThanhLy/CreateTaiSanThanhLy";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateTaiSanThanhLy(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateTaiSanThanhLy(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreateTaiSanThanhLy(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    hoanTacTaiSanThanhLy(body: EntityDto[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TaiSanThanhLy/HoanTacTaiSanThanhLy";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHoanTacTaiSanThanhLy(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHoanTacTaiSanThanhLy(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processHoanTacTaiSanThanhLy(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class TenantServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateTenantDto | undefined): Observable<TenantDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<TenantDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TenantDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<TenantDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<TenantDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<TenantDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TenantDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<TenantDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantDto>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @param isActive (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, isActive: boolean | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<TenantDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/GetAll?";
        if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<TenantDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TenantDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<TenantDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantDtoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: TenantDto | undefined): Observable<TenantDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<TenantDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TenantDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<TenantDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantDto>(<any>null);
    }
}

@Injectable()
export class ToanBoTaiSanServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param fillter (optional) 
     * @param phongBanqQL (optional) 
     * @param loaiTS (optional) 
     * @param nhaCungCap (optional) 
     * @param tinhTrangSD (optional) 
     * @param maSD (optional) 
     * @param isSearch (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(fillter: string | null | undefined, phongBanqQL: number[] | null | undefined, loaiTS: number | null | undefined, nhaCungCap: number | null | undefined, tinhTrangSD: number | null | undefined, maSD: number | null | undefined, isSearch: boolean | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<GetAllOutputDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/ToanBoTaiSan/GetAll?";
        if (fillter !== undefined)
            url_ += "Fillter=" + encodeURIComponent("" + fillter) + "&";
        if (phongBanqQL !== undefined)
            phongBanqQL && phongBanqQL.forEach(item => { url_ += "PhongBanqQL=" + encodeURIComponent("" + item) + "&"; });
        if (loaiTS !== undefined)
            url_ += "LoaiTS=" + encodeURIComponent("" + loaiTS) + "&";
        if (nhaCungCap !== undefined)
            url_ += "NhaCungCap=" + encodeURIComponent("" + nhaCungCap) + "&";
        if (tinhTrangSD !== undefined)
            url_ += "TinhTrangSD=" + encodeURIComponent("" + tinhTrangSD) + "&";
        if (maSD !== undefined)
            url_ += "MaSD=" + encodeURIComponent("" + maSD) + "&";
        if (isSearch !== undefined)
            url_ += "IsSearch=" + encodeURIComponent("" + isSearch) + "&";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<GetAllOutputDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetAllOutputDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<GetAllOutputDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAllOutputDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAllOutputDtoPagedResultDto>(<any>null);
    }

    /**
     * @return Success
     */
    getAllNhaCC(): Observable<LookupTableDto[]> {
        let url_ = this.baseUrl + "/api/services/app/ToanBoTaiSan/GetAllNhaCC";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllNhaCC(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllNhaCC(<any>response_);
                } catch (e) {
                    return <Observable<LookupTableDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<LookupTableDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllNhaCC(response: HttpResponseBase): Observable<LookupTableDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(LookupTableDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LookupTableDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllLoaiTS(): Observable<LookupTableDto[]> {
        let url_ = this.baseUrl + "/api/services/app/ToanBoTaiSan/GetAllLoaiTS";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllLoaiTS(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllLoaiTS(<any>response_);
                } catch (e) {
                    return <Observable<LookupTableDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<LookupTableDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllLoaiTS(response: HttpResponseBase): Observable<LookupTableDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(LookupTableDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LookupTableDto[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateInputDto | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/ToanBoTaiSan/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    deleted(input: number | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/ToanBoTaiSan/Deleted?";
        if (input === null)
            throw new Error("The parameter 'input' cannot be null.");
        else if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleted(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleted(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processDeleted(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param input (optional) 
     * @param isView (optional) 
     * @return Success
     */
    getForEdit(input: number | undefined, isView: boolean | undefined): Observable<GetForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/ToanBoTaiSan/GetForEdit?";
        if (input === null)
            throw new Error("The parameter 'input' cannot be null.");
        else if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        if (isView === null)
            throw new Error("The parameter 'isView' cannot be null.");
        else if (isView !== undefined)
            url_ += "isView=" + encodeURIComponent("" + isView) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<GetForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetForViewDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    xoaList(body: number[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ToanBoTaiSan/XoaList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processXoaList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processXoaList(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processXoaList(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param idLoaiTS (optional) 
     * @param idTS (optional) 
     * @return Success
     */
    genCode(idLoaiTS: number | undefined, idTS: number | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/ToanBoTaiSan/GenCode?";
        if (idLoaiTS === null)
            throw new Error("The parameter 'idLoaiTS' cannot be null.");
        else if (idLoaiTS !== undefined)
            url_ += "idLoaiTS=" + encodeURIComponent("" + idLoaiTS) + "&";
        if (idTS === null)
            throw new Error("The parameter 'idTS' cannot be null.");
        else if (idTS !== undefined)
            url_ += "idTS=" + encodeURIComponent("" + idTS) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGenCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGenCode(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGenCode(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @return Success
     */
    getUserDangNhap(): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/ToanBoTaiSan/GetUserDangNhap";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserDangNhap(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserDangNhap(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserDangNhap(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param linkFile (optional) 
     * @return Success
     */
    downloadFileUpload(linkFile: string | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/ToanBoTaiSan/DownloadFileUpload?";
        if (linkFile !== undefined)
            url_ += "linkFile=" + encodeURIComponent("" + linkFile) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadFileUpload(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadFileUpload(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processDownloadFileUpload(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    exportToExcel(body: GetAllInputDto | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/ToanBoTaiSan/ExportToExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processExportToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @return Success
     */
    downloadFileMau(): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/ToanBoTaiSan/DownloadFileMau";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadFileMau(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadFileMau(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processDownloadFileMau(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param filePath (optional) 
     * @return Success
     */
    importFileExcel(filePath: string | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/ToanBoTaiSan/ImportFileExcel?";
        if (filePath !== undefined)
            url_ += "filePath=" + encodeURIComponent("" + filePath) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImportFileExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImportFileExcel(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processImportFileExcel(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }
}

@Injectable()
export class ToChucServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param keyword (optional) 
     * @param isSearch (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, isSearch: boolean | null | undefined): Observable<ToChucTreeTableForViewDto[]> {
        let url_ = this.baseUrl + "/api/services/app/ToChuc/GetAll?";
        if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (isSearch !== undefined)
            url_ += "IsSearch=" + encodeURIComponent("" + isSearch) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<ToChucTreeTableForViewDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ToChucTreeTableForViewDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ToChucTreeTableForViewDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ToChucTreeTableForViewDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ToChucTreeTableForViewDto[]>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param isView (optional) 
     * @return Success
     */
    getForEdit(id: number | undefined, isView: boolean | undefined): Observable<ToChucCreateInputDto> {
        let url_ = this.baseUrl + "/api/services/app/ToChuc/GetForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (isView === null)
            throw new Error("The parameter 'isView' cannot be null.");
        else if (isView !== undefined)
            url_ += "isView=" + encodeURIComponent("" + isView) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(<any>response_);
                } catch (e) {
                    return <Observable<ToChucCreateInputDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ToChucCreateInputDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<ToChucCreateInputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ToChucCreateInputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ToChucCreateInputDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: ToChucCreateInputDto | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/ToChuc/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ToChuc/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    exportToExcel(body: ToChucGetAllInputDto | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/ToChuc/ExportToExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processExportToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @return Success
     */
    getAllToChucForExcel(): Observable<ToChucForExportDto[]> {
        let url_ = this.baseUrl + "/api/services/app/ToChuc/GetAllToChucForExcel";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllToChucForExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllToChucForExcel(<any>response_);
                } catch (e) {
                    return <Observable<ToChucForExportDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ToChucForExportDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllToChucForExcel(response: HttpResponseBase): Observable<ToChucForExportDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ToChucForExportDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ToChucForExportDto[]>(<any>null);
    }

    /**
     * @param filePath (optional) 
     * @return Success
     */
    importFileExcel(filePath: string | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/ToChuc/ImportFileExcel?";
        if (filePath !== undefined)
            url_ += "filePath=" + encodeURIComponent("" + filePath) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImportFileExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImportFileExcel(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processImportFileExcel(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @return Success
     */
    downloadFileMau(): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/ToChuc/DownloadFileMau";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadFileMau(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadFileMau(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processDownloadFileMau(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @return Success
     */
    getAllToChucCha(): Observable<LookupTableDto[]> {
        let url_ = this.baseUrl + "/api/services/app/ToChuc/GetAllToChucCha";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllToChucCha(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllToChucCha(<any>response_);
                } catch (e) {
                    return <Observable<LookupTableDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<LookupTableDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllToChucCha(response: HttpResponseBase): Observable<LookupTableDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(LookupTableDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LookupTableDto[]>(<any>null);
    }
}

export interface IAuthenticateSSOModel {
    TenantCode: string,
    Authorization: string;
    SessionId: string;
}

export class AuthenticateSSOResultModel implements IAuthenticateSSOResultModel {
    id: string | undefined;
    userName: string | undefined;
    email: string | undefined;
    userApps: any | undefined;

    constructor(data?: IAuthenticateSSOResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userName = _data["userName"];
            this.email = _data["email"];
            this.userApps = _data["userApps"];
        }
    }

    static fromJS(data: any): AuthenticateSSOResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateSSOResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["email"] = this.email;
        data["userApps"] = this.userApps;
        return data; 
    }

    clone(): AuthenticateSSOResultModel {
        const json = this.toJSON();
        let result = new AuthenticateSSOResultModel();
        result.init(json);
        return result;
    }
}

export interface IAuthenticateSSOResultModel {
    id: string | undefined;
    userName: string | undefined;
    email: string | undefined;
    userApps: any | undefined;
}

export class TenantSSOResultModel implements ITenantSSOResultModel {
    id: string | undefined;
    tenantName: string | undefined;
    taxCode: string | undefined;
    address: string | undefined;
    phone: string | undefined;
    email: string | undefined;
    fax: string | undefined;
    website: string | undefined;
    logo: string | undefined;
    isDelete: number | undefined;
    tenantCode: string | undefined

    constructor(data?: ITenantSSOResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantName = _data["tenantName"];
            this.taxCode = _data["taxCode"];
            this.address = _data["address"];
            this.phone = _data["phone"];
            this.email = _data["email"];
            this.fax = _data["fax"];
            this.website = _data["website"];
            this.logo = _data["logo"];
            this.isDelete = _data["isDelete"];
            this.tenantCode = _data["tenantCode"];
        }
    }

    static fromJS(data: any): TenantSSOResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new TenantSSOResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantName"] = this.tenantName;
        data["taxCode"] = this.taxCode;
        data["address"] = this.address;
        data["phone"] = this.phone;
        data["email"] = this.email;
        data["fax"] = this.fax;
        data["website"] = this.website;
        data["logo"] = this.logo;
        data["isDelete"] = this.isDelete;
        data["tenantCode"] = this.tenantCode;
        return data; 
    }

    clone(): TenantSSOResultModel {
        const json = this.toJSON();
        let result = new TenantSSOResultModel();
        result.init(json);
        return result;
    }
}

export interface ITenantSSOResultModel {
    id: string | undefined;
    tenantName: string | undefined;
    taxCode: string | undefined;
    address: string | undefined;
    phone: string | undefined;
    email: string | undefined;
    fax: string | undefined;
    website: string | undefined;
    logo: string | undefined;
    isDelete: number | undefined;
    tenantCode: string | undefined;
}

@Injectable()
export class TokenAuthServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    private ssoUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
        this.ssoUrl = "https://devaccount.smart-office.vn";
    }

    /**
     * @param body (optional) 
     * @return Success
     */

    loginSSO(headers: IAuthenticateSSOModel): Observable<AuthenticateSSOResultModel> {
        let url_ = this.ssoUrl + "/account/user/getUserInfo";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "SessionId": headers.SessionId,
                "TenantCode": headers.TenantCode,
                "Authorization": headers.Authorization,
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetExternalSSOAuthenticationProviders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetExternalSSOAuthenticationProviders(<any>response_);
                } catch (e) {
                    return <Observable<AuthenticateSSOResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<AuthenticateSSOResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processGetExternalSSOAuthenticationProviders(response: HttpResponseBase): Observable<AuthenticateSSOResultModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthenticateSSOResultModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AuthenticateSSOResultModel>(<any>null);
    }

    authenticate(body: AuthenticateModel | undefined): Observable<AuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/Authenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuthenticate(<any>response_);
                } catch (e) {
                    return <Observable<AuthenticateResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<AuthenticateResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processAuthenticate(response: HttpResponseBase): Observable<AuthenticateResultModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthenticateResultModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AuthenticateResultModel>(<any>null);
    }

    /**
     * @return Success
     */
    logout(): Observable<void> {
        let url_ = this.baseUrl + "/api/TokenAuth/Logout";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogout(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogout(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processLogout(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getExternalAuthenticationProviders(): Observable<ExternalLoginProviderInfoModel[]> {
        let url_ = this.baseUrl + "/api/TokenAuth/GetExternalAuthenticationProviders";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetExternalAuthenticationProviders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetExternalAuthenticationProviders(<any>response_);
                } catch (e) {
                    return <Observable<ExternalLoginProviderInfoModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExternalLoginProviderInfoModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetExternalAuthenticationProviders(response: HttpResponseBase): Observable<ExternalLoginProviderInfoModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ExternalLoginProviderInfoModel.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExternalLoginProviderInfoModel[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    externalAuthenticate(body: ExternalAuthenticateModel | undefined): Observable<ExternalAuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/ExternalAuthenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExternalAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExternalAuthenticate(<any>response_);
                } catch (e) {
                    return <Observable<ExternalAuthenticateResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExternalAuthenticateResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processExternalAuthenticate(response: HttpResponseBase): Observable<ExternalAuthenticateResultModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExternalAuthenticateResultModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExternalAuthenticateResultModel>(<any>null);
    }
}

@Injectable()
export class UploadServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    demoUpload(): Observable<string[]> {
        let url_ = this.baseUrl + "/api/Upload/DemoUpload";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDemoUpload(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDemoUpload(<any>response_);
                } catch (e) {
                    return <Observable<string[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<string[]>><any>_observableThrow(response_);
        }));
    }

    protected processDemoUpload(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(<any>null);
    }

    /**
     * @return Success
     */
    nhaCungCapUpload(): Observable<string[]> {
        let url_ = this.baseUrl + "/api/Upload/NhaCungCapUpload";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processNhaCungCapUpload(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processNhaCungCapUpload(<any>response_);
                } catch (e) {
                    return <Observable<string[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<string[]>><any>_observableThrow(response_);
        }));
    }

    protected processNhaCungCapUpload(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(<any>null);
    }

    /**
     * @return Success
     */
    duTruMuaSamUpload(): Observable<string[]> {
        let url_ = this.baseUrl + "/api/Upload/DuTruMuaSamUpload";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDuTruMuaSamUpload(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDuTruMuaSamUpload(<any>response_);
                } catch (e) {
                    return <Observable<string[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<string[]>><any>_observableThrow(response_);
        }));
    }

    protected processDuTruMuaSamUpload(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(<any>null);
    }

    /**
     * @return Success
     */
    toanBoTSUpload(): Observable<string[]> {
        let url_ = this.baseUrl + "/api/Upload/ToanBoTSUpload";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processToanBoTSUpload(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processToanBoTSUpload(<any>response_);
                } catch (e) {
                    return <Observable<string[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<string[]>><any>_observableThrow(response_);
        }));
    }

    protected processToanBoTSUpload(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(<any>null);
    }

    /**
     * @return Success
     */
    toChucUpload(): Observable<string[]> {
        let url_ = this.baseUrl + "/api/Upload/ToChucUpload";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processToChucUpload(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processToChucUpload(<any>response_);
                } catch (e) {
                    return <Observable<string[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<string[]>><any>_observableThrow(response_);
        }));
    }

    protected processToChucUpload(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(<any>null);
    }

    /**
     * @return Success
     */
    loaiTaiSanUpload(): Observable<string[]> {
        let url_ = this.baseUrl + "/api/Upload/LoaiTaiSanUpload";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLoaiTaiSanUpload(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLoaiTaiSanUpload(<any>response_);
                } catch (e) {
                    return <Observable<string[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<string[]>><any>_observableThrow(response_);
        }));
    }

    protected processLoaiTaiSanUpload(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(<any>null);
    }

    /**
     * @return Success
     */
    viTriDiaLyUpload(): Observable<string[]> {
        let url_ = this.baseUrl + "/api/Upload/ViTriDiaLyUpload";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processViTriDiaLyUpload(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processViTriDiaLyUpload(<any>response_);
                } catch (e) {
                    return <Observable<string[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<string[]>><any>_observableThrow(response_);
        }));
    }

    protected processViTriDiaLyUpload(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(<any>null);
    }
}

@Injectable()
export class UserServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    private ssoUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
        this.ssoUrl = "https://devaccount.smart-office.vn";
    }

    /**
     * @return Success
     */

        // get tenant SSO
        getTenant(headers: IAuthenticateSSOModel): Observable<TenantSSOResultModel> {
            let url_ = this.ssoUrl + "/account/tenantApp/getTenant";
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ : any = {
                observe: "response",
                responseType: "blob",
                headers: new HttpHeaders({
                    "SessionId": headers.SessionId,
                    "TenantCode": headers.TenantCode,
                    "Authorization": headers.Authorization,
                })
            };
    
            return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
                return this.processGetTenantSSOProviders(response_);
            })).pipe(_observableCatch((response_: any) => {
                if (response_ instanceof HttpResponseBase) {
                    try {
                        return this.processGetTenantSSOProviders(<any>response_);
                    } catch (e) {
                        return <Observable<TenantSSOResultModel>><any>_observableThrow(e);
                    }
                } else
                    return <Observable<TenantSSOResultModel>><any>_observableThrow(response_);
            }));
        }
    
        protected processGetTenantSSOProviders(response: HttpResponseBase): Observable<TenantSSOResultModel> {
            const status = response.status;
            const responseBlob =
                response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;
    
            let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
            if (status === 200) {
                return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = TenantSSOResultModel.fromJS(resultData200);
                return _observableOf(result200);
                }));
            } else if (status !== 200 && status !== 204) {
                return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                }));
            }
            return _observableOf<TenantSSOResultModel>(<any>null);
        }

    getAllDonVi(): Observable<LookupTableDto[]> {
        let url_ = this.baseUrl + "/api/services/app/User/GetAllDonVi";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllDonVi(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllDonVi(<any>response_);
                } catch (e) {
                    return <Observable<LookupTableDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<LookupTableDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllDonVi(response: HttpResponseBase): Observable<LookupTableDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(LookupTableDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LookupTableDto[]>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @param isActive (optional) 
     * @param toChucIdList (optional) 
     * @param isSearch (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, isActive: boolean | null | undefined, toChucIdList: number[] | null | undefined, isSearch: boolean | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<UserDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/User/GetAll?";
        if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (toChucIdList !== undefined)
            toChucIdList && toChucIdList.forEach(item => { url_ += "ToChucIdList=" + encodeURIComponent("" + item) + "&"; });
        if (isSearch !== undefined)
            url_ += "IsSearch=" + encodeURIComponent("" + isSearch) + "&";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<UserDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<UserDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDtoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateUserDto | undefined): Observable<UserDto> {
        let url_ = this.baseUrl + "/api/services/app/User/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<UserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<UserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UserDto | undefined): Observable<UserDto> {
        let url_ = this.baseUrl + "/api/services/app/User/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<UserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<UserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDto>(<any>null);
    }

    /**
     * @param userName (optional) 
     * @param emailAddress (optional) 
     * @param id (optional) 
     * @return Success
     */
    checkExist(userName: string | null | undefined, emailAddress: string | null | undefined, id: number | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/User/CheckExist?";
        if (userName !== undefined)
            url_ += "userName=" + encodeURIComponent("" + userName) + "&";
        if (emailAddress !== undefined)
            url_ += "emailAddress=" + encodeURIComponent("" + emailAddress) + "&";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckExist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckExist(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCheckExist(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getRoles(): Observable<RoleDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/User/GetRoles";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoles(<any>response_);
                } catch (e) {
                    return <Observable<RoleDtoListResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoleDtoListResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetRoles(response: HttpResponseBase): Observable<RoleDtoListResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDtoListResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleDtoListResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changeLanguage(body: ChangeUserLanguageDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/ChangeLanguage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeLanguage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeLanguage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processChangeLanguage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changePassword(body: ChangePasswordDto | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/User/ChangePassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangePassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangePassword(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processChangePassword(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    resetPassword(body: ResetPasswordDto | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/User/ResetPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetPassword(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processResetPassword(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param isView (optional) 
     * @return Success
     */
    getForEdit(id: number | undefined, isView: boolean | undefined): Observable<UserDto> {
        let url_ = this.baseUrl + "/api/services/app/User/GetForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (isView === null)
            throw new Error("The parameter 'isView' cannot be null.");
        else if (isView !== undefined)
            url_ += "isView=" + encodeURIComponent("" + isView) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(<any>response_);
                } catch (e) {
                    return <Observable<UserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<UserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<UserDto> {
        let url_ = this.baseUrl + "/api/services/app/User/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<UserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<UserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDto>(<any>null);
    }
}

@Injectable()
export class ViTriDiaLyServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param fillter (optional) 
     * @param tinhThanh (optional) 
     * @param quanHuyen (optional) 
     * @param isSearch (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(fillter: string | null | undefined, tinhThanh: number | null | undefined, quanHuyen: number | null | undefined, isSearch: boolean | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<GetAllDtosPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/ViTriDiaLy/GetAll?";
        if (fillter !== undefined)
            url_ += "Fillter=" + encodeURIComponent("" + fillter) + "&";
        if (tinhThanh !== undefined)
            url_ += "TinhThanh=" + encodeURIComponent("" + tinhThanh) + "&";
        if (quanHuyen !== undefined)
            url_ += "QuanHuyen=" + encodeURIComponent("" + quanHuyen) + "&";
        if (isSearch !== undefined)
            url_ += "IsSearch=" + encodeURIComponent("" + isSearch) + "&";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<GetAllDtosPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetAllDtosPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<GetAllDtosPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAllDtosPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAllDtosPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditDtos | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/ViTriDiaLy/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param input (optional) 
     * @param isView (optional) 
     * @return Success
     */
    getForEdit(input: number | undefined, isView: boolean | undefined): Observable<GetValueForView> {
        let url_ = this.baseUrl + "/api/services/app/ViTriDiaLy/GetForEdit?";
        if (input === null)
            throw new Error("The parameter 'input' cannot be null.");
        else if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        if (isView === null)
            throw new Error("The parameter 'isView' cannot be null.");
        else if (isView !== undefined)
            url_ += "isView=" + encodeURIComponent("" + isView) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetValueForView>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetValueForView>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<GetValueForView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetValueForView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetValueForView>(<any>null);
    }

    /**
     * @return Success
     */
    getAllDtoTinhThanh(): Observable<LookupTableDto[]> {
        let url_ = this.baseUrl + "/api/services/app/ViTriDiaLy/GetAllDtoTinhThanh";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllDtoTinhThanh(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllDtoTinhThanh(<any>response_);
                } catch (e) {
                    return <Observable<LookupTableDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<LookupTableDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllDtoTinhThanh(response: HttpResponseBase): Observable<LookupTableDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(LookupTableDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LookupTableDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllDtoQuanHuyen(): Observable<LookupTableDto[]> {
        let url_ = this.baseUrl + "/api/services/app/ViTriDiaLy/GetAllDtoQuanHuyen";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllDtoQuanHuyen(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllDtoQuanHuyen(<any>response_);
                } catch (e) {
                    return <Observable<LookupTableDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<LookupTableDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllDtoQuanHuyen(response: HttpResponseBase): Observable<LookupTableDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(LookupTableDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LookupTableDto[]>(<any>null);
    }

    /**
     * @param tinhthanhId (optional) 
     * @return Success
     */
    getAllDtoQuanHuyenFromTT(tinhthanhId: number | undefined): Observable<LookupTableDto[]> {
        let url_ = this.baseUrl + "/api/services/app/ViTriDiaLy/GetAllDtoQuanHuyenFromTT?";
        if (tinhthanhId === null)
            throw new Error("The parameter 'tinhthanhId' cannot be null.");
        else if (tinhthanhId !== undefined)
            url_ += "tinhthanhId=" + encodeURIComponent("" + tinhthanhId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllDtoQuanHuyenFromTT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllDtoQuanHuyenFromTT(<any>response_);
                } catch (e) {
                    return <Observable<LookupTableDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<LookupTableDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllDtoQuanHuyenFromTT(response: HttpResponseBase): Observable<LookupTableDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(LookupTableDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LookupTableDto[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    exportToExcel(body: GetAllInPutDtos | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/ViTriDiaLy/ExportToExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processExportToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @return Success
     */
    downloadFileMau(): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/ViTriDiaLy/DownloadFileMau";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadFileMau(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadFileMau(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processDownloadFileMau(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param filePath (optional) 
     * @return Success
     */
    importFileExcel(filePath: string | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/ViTriDiaLy/ImportFileExcel?";
        if (filePath !== undefined)
            url_ += "filePath=" + encodeURIComponent("" + filePath) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImportFileExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImportFileExcel(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processImportFileExcel(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    deleted(input: number | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/ViTriDiaLy/Deleted?";
        if (input === null)
            throw new Error("The parameter 'input' cannot be null.");
        else if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleted(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleted(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processDeleted(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }
}

export class IsTenantAvailableInput implements IIsTenantAvailableInput {
    tenancyName: string;

    constructor(data?: IIsTenantAvailableInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
        }
    }

    static fromJS(data: any): IsTenantAvailableInput {
        data = typeof data === 'object' ? data : {};
        let result = new IsTenantAvailableInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        return data; 
    }

    clone(): IsTenantAvailableInput {
        const json = this.toJSON();
        let result = new IsTenantAvailableInput();
        result.init(json);
        return result;
    }
}

export interface IIsTenantAvailableInput {
    tenancyName: string;
}

export enum TenantAvailabilityState {
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export class IsTenantAvailableOutput implements IIsTenantAvailableOutput {
    state: TenantAvailabilityState;
    tenantId: number | undefined;

    constructor(data?: IIsTenantAvailableOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.state = _data["state"];
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): IsTenantAvailableOutput {
        data = typeof data === 'object' ? data : {};
        let result = new IsTenantAvailableOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["state"] = this.state;
        data["tenantId"] = this.tenantId;
        return data; 
    }

    clone(): IsTenantAvailableOutput {
        const json = this.toJSON();
        let result = new IsTenantAvailableOutput();
        result.init(json);
        return result;
    }
}

export interface IIsTenantAvailableOutput {
    state: TenantAvailabilityState;
    tenantId: number | undefined;
}

export class RegisterInput implements IRegisterInput {
    name: string;
    surname: string;
    userName: string;
    emailAddress: string;
    password: string;
    captchaResponse: string | undefined;

    constructor(data?: IRegisterInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.userName = _data["userName"];
            this.emailAddress = _data["emailAddress"];
            this.password = _data["password"];
            this.captchaResponse = _data["captchaResponse"];
        }
    }

    static fromJS(data: any): RegisterInput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["password"] = this.password;
        data["captchaResponse"] = this.captchaResponse;
        return data; 
    }

    clone(): RegisterInput {
        const json = this.toJSON();
        let result = new RegisterInput();
        result.init(json);
        return result;
    }
}

export interface IRegisterInput {
    name: string;
    surname: string;
    userName: string;
    emailAddress: string;
    password: string;
    captchaResponse: string | undefined;
}

export class RegisterOutput implements IRegisterOutput {
    canLogin: boolean;

    constructor(data?: IRegisterOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.canLogin = _data["canLogin"];
        }
    }

    static fromJS(data: any): RegisterOutput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canLogin"] = this.canLogin;
        return data; 
    }

    clone(): RegisterOutput {
        const json = this.toJSON();
        let result = new RegisterOutput();
        result.init(json);
        return result;
    }
}

export interface IRegisterOutput {
    canLogin: boolean;
}

export class GetAllOutputDto implements IGetAllOutputDto {
    id: number;
    tenTS: string | undefined;
    loaiTS: string | undefined;
    serialNumber: string | undefined;
    productNumber: string | undefined;
    nhaCungCap: string | undefined;
    ngayMua: string | undefined;
    ngayMuaDateTime: moment.Moment | undefined;
    nguyenGia: number | undefined;
    phongBanQL: string | undefined;
    tinhTrangSDRFID: string | undefined;
    tinhTrangSDBarCode: string | undefined;
    tinhTrangSDQRCode: string | undefined;
    maSD: string | undefined;
    viTriTS: string | undefined;
    ngayTao: moment.Moment | undefined;
    trangThai: string | undefined;
    tinhTrangSuDung: string | undefined;
    trangThaiId: number | undefined;
    tinhTrangRFID: boolean | undefined;
    tinhTrangQRCode: boolean | undefined;
    tinhTrangBarCode: boolean | undefined;
    maEPC: string | undefined;
    nguonKinhPhiId: number | undefined;

    constructor(data?: IGetAllOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenTS = _data["tenTS"];
            this.loaiTS = _data["loaiTS"];
            this.serialNumber = _data["serialNumber"];
            this.productNumber = _data["productNumber"];
            this.nhaCungCap = _data["nhaCungCap"];
            this.ngayMua = _data["ngayMua"];
            this.ngayMuaDateTime = _data["ngayMuaDateTime"] ? moment(_data["ngayMuaDateTime"].toString()) : <any>undefined;
            this.nguyenGia = _data["nguyenGia"];
            this.phongBanQL = _data["phongBanQL"];
            this.tinhTrangSDRFID = _data["tinhTrangSDRFID"];
            this.tinhTrangSDBarCode = _data["tinhTrangSDBarCode"];
            this.tinhTrangSDQRCode = _data["tinhTrangSDQRCode"];
            this.maSD = _data["maSD"];
            this.viTriTS = _data["viTriTS"];
            this.ngayTao = _data["ngayTao"] ? moment(_data["ngayTao"].toString()) : <any>undefined;
            this.trangThai = _data["trangThai"];
            this.tinhTrangSuDung = _data["tinhTrangSuDung"];
            this.trangThaiId = _data["trangThaiId"];
            this.tinhTrangRFID = _data["tinhTrangRFID"];
            this.tinhTrangQRCode = _data["tinhTrangQRCode"];
            this.tinhTrangBarCode = _data["tinhTrangBarCode"];
            this.maEPC = _data["maEPC"];
            this.nguonKinhPhiId = _data["nguonKinhPhiId"];
        }
    }

    static fromJS(data: any): GetAllOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenTS"] = this.tenTS;
        data["loaiTS"] = this.loaiTS;
        data["serialNumber"] = this.serialNumber;
        data["productNumber"] = this.productNumber;
        data["nhaCungCap"] = this.nhaCungCap;
        data["ngayMua"] = this.ngayMua;
        data["ngayMuaDateTime"] = this.ngayMuaDateTime ? this.ngayMuaDateTime.toISOString() : <any>undefined;
        data["nguyenGia"] = this.nguyenGia;
        data["phongBanQL"] = this.phongBanQL;
        data["tinhTrangSDRFID"] = this.tinhTrangSDRFID;
        data["tinhTrangSDBarCode"] = this.tinhTrangSDBarCode;
        data["tinhTrangSDQRCode"] = this.tinhTrangSDQRCode;
        data["maSD"] = this.maSD;
        data["viTriTS"] = this.viTriTS;
        data["ngayTao"] = this.ngayTao ? this.ngayTao.toISOString() : <any>undefined;
        data["trangThai"] = this.trangThai;
        data["tinhTrangSuDung"] = this.tinhTrangSuDung;
        data["trangThaiId"] = this.trangThaiId;
        data["tinhTrangRFID"] = this.tinhTrangRFID;
        data["tinhTrangQRCode"] = this.tinhTrangQRCode;
        data["tinhTrangBarCode"] = this.tinhTrangBarCode;
        data["maEPC"] = this.maEPC;
        data["nguonKinhPhiId"] = this.nguonKinhPhiId;
        return data; 
    }

    clone(): GetAllOutputDto {
        const json = this.toJSON();
        let result = new GetAllOutputDto();
        result.init(json);
        return result;
    }
}

export interface IGetAllOutputDto {
    id: number;
    tenTS: string | undefined;
    loaiTS: string | undefined;
    serialNumber: string | undefined;
    productNumber: string | undefined;
    nhaCungCap: string | undefined;
    ngayMua: string | undefined;
    ngayMuaDateTime: moment.Moment | undefined;
    nguyenGia: number | undefined;
    phongBanQL: string | undefined;
    tinhTrangSDRFID: string | undefined;
    tinhTrangSDBarCode: string | undefined;
    tinhTrangSDQRCode: string | undefined;
    maSD: string | undefined;
    viTriTS: string | undefined;
    ngayTao: moment.Moment | undefined;
    trangThai: string | undefined;
    tinhTrangSuDung: string | undefined;
    trangThaiId: number | undefined;
    tinhTrangRFID: boolean | undefined;
    tinhTrangQRCode: boolean | undefined;
    tinhTrangBarCode: boolean | undefined;
    maEPC: string | undefined;
    nguonKinhPhiId: number | undefined;
}

export class GetAllOutputDtoPagedResultDto implements IGetAllOutputDtoPagedResultDto {
    totalCount: number;
    items: GetAllOutputDto[] | undefined;

    constructor(data?: IGetAllOutputDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(GetAllOutputDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetAllOutputDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllOutputDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): GetAllOutputDtoPagedResultDto {
        const json = this.toJSON();
        let result = new GetAllOutputDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IGetAllOutputDtoPagedResultDto {
    totalCount: number;
    items: GetAllOutputDto[] | undefined;
}

export class LookupTableDto implements ILookupTableDto {
    id: number;
    displayName: string | undefined;

    constructor(data?: ILookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): LookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new LookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }

    clone(): LookupTableDto {
        const json = this.toJSON();
        let result = new LookupTableDto();
        result.init(json);
        return result;
    }
}

export interface ILookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class TaiSanDinhKemFile implements ITaiSanDinhKemFile {
    tenantId: number | undefined;
    taiSanId: number | undefined;
    tenFile: string | undefined;
    linkFile: string | undefined;
    phanLoaiId: number | undefined;
    ghiChu: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: ITaiSanDinhKemFile) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.taiSanId = _data["taiSanId"];
            this.tenFile = _data["tenFile"];
            this.linkFile = _data["linkFile"];
            this.phanLoaiId = _data["phanLoaiId"];
            this.ghiChu = _data["ghiChu"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TaiSanDinhKemFile {
        data = typeof data === 'object' ? data : {};
        let result = new TaiSanDinhKemFile();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["taiSanId"] = this.taiSanId;
        data["tenFile"] = this.tenFile;
        data["linkFile"] = this.linkFile;
        data["phanLoaiId"] = this.phanLoaiId;
        data["ghiChu"] = this.ghiChu;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): TaiSanDinhKemFile {
        const json = this.toJSON();
        let result = new TaiSanDinhKemFile();
        result.init(json);
        return result;
    }
}

export interface ITaiSanDinhKemFile {
    tenantId: number | undefined;
    taiSanId: number | undefined;
    tenFile: string | undefined;
    linkFile: string | undefined;
    phanLoaiId: number | undefined;
    ghiChu: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class CreateInputDto implements ICreateInputDto {
    id: number | undefined;
    tenTS: string | undefined;
    loaiTS: number | undefined;
    serialNumber: string | undefined;
    productNumber: string | undefined;
    readerMACId: string | undefined;
    nhaCC: number | undefined;
    hangSanXuat: string | undefined;
    nguyenGia: number | undefined;
    ngayMua: moment.Moment | undefined;
    ngayBaoHanh: moment.Moment | undefined;
    hanSD: moment.Moment | undefined;
    ghiChu: string | undefined;
    nguoiChotGia: number | undefined;
    thoiDiemChotGia: moment.Moment | undefined;
    giaCuoiTS: number | undefined;
    noiDungChotGia: string | undefined;
    dropdownMultiple: string | undefined;
    thoiGianChietKhauHao: number | undefined;
    nguonKinhPhiId: number | undefined;
    listHA: TaiSanDinhKemFile[] | undefined;
    listFile: TaiSanDinhKemFile[] | undefined;

    constructor(data?: ICreateInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenTS = _data["tenTS"];
            this.loaiTS = _data["loaiTS"];
            this.serialNumber = _data["serialNumber"];
            this.productNumber = _data["productNumber"];
            this.readerMACId = _data["readerMACId"];
            this.nhaCC = _data["nhaCC"];
            this.hangSanXuat = _data["hangSanXuat"];
            this.nguyenGia = _data["nguyenGia"];
            this.ngayMua = _data["ngayMua"] ? moment(_data["ngayMua"].toString()) : <any>undefined;
            this.ngayBaoHanh = _data["ngayBaoHanh"] ? moment(_data["ngayBaoHanh"].toString()) : <any>undefined;
            this.hanSD = _data["hanSD"] ? moment(_data["hanSD"].toString()) : <any>undefined;
            this.ghiChu = _data["ghiChu"];
            this.nguoiChotGia = _data["nguoiChotGia"];
            this.thoiDiemChotGia = _data["thoiDiemChotGia"] ? moment(_data["thoiDiemChotGia"].toString()) : <any>undefined;
            this.giaCuoiTS = _data["giaCuoiTS"];
            this.noiDungChotGia = _data["noiDungChotGia"];
            this.dropdownMultiple = _data["dropdownMultiple"];
            this.thoiGianChietKhauHao = _data["thoiGianChietKhauHao"];
            this.nguonKinhPhiId = _data["nguonKinhPhiId"];
            if (Array.isArray(_data["listHA"])) {
                this.listHA = [] as any;
                for (let item of _data["listHA"])
                    this.listHA.push(TaiSanDinhKemFile.fromJS(item));
            }
            if (Array.isArray(_data["listFile"])) {
                this.listFile = [] as any;
                for (let item of _data["listFile"])
                    this.listFile.push(TaiSanDinhKemFile.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenTS"] = this.tenTS;
        data["loaiTS"] = this.loaiTS;
        data["serialNumber"] = this.serialNumber;
        data["productNumber"] = this.productNumber;
        data["readerMACId"] = this.readerMACId;
        data["nhaCC"] = this.nhaCC;
        data["hangSanXuat"] = this.hangSanXuat;
        data["nguyenGia"] = this.nguyenGia;
        data["ngayMua"] = this.ngayMua ? this.ngayMua.toISOString() : <any>undefined;
        data["ngayBaoHanh"] = this.ngayBaoHanh ? this.ngayBaoHanh.toISOString() : <any>undefined;
        data["hanSD"] = this.hanSD ? this.hanSD.toISOString() : <any>undefined;
        data["ghiChu"] = this.ghiChu;
        data["nguoiChotGia"] = this.nguoiChotGia;
        data["thoiDiemChotGia"] = this.thoiDiemChotGia ? this.thoiDiemChotGia.toISOString() : <any>undefined;
        data["giaCuoiTS"] = this.giaCuoiTS;
        data["noiDungChotGia"] = this.noiDungChotGia;
        data["dropdownMultiple"] = this.dropdownMultiple;
        data["thoiGianChietKhauHao"] = this.thoiGianChietKhauHao;
        data["nguonKinhPhiId"] = this.nguonKinhPhiId;
        if (Array.isArray(this.listHA)) {
            data["listHA"] = [];
            for (let item of this.listHA)
                data["listHA"].push(item.toJSON());
        }
        if (Array.isArray(this.listFile)) {
            data["listFile"] = [];
            for (let item of this.listFile)
                data["listFile"].push(item.toJSON());
        }
        return data; 
    }

    clone(): CreateInputDto {
        const json = this.toJSON();
        let result = new CreateInputDto();
        result.init(json);
        return result;
    }
}

export interface ICreateInputDto {
    id: number | undefined;
    tenTS: string | undefined;
    loaiTS: number | undefined;
    serialNumber: string | undefined;
    productNumber: string | undefined;
    readerMACId: string | undefined;
    nhaCC: number | undefined;
    hangSanXuat: string | undefined;
    nguyenGia: number | undefined;
    ngayMua: moment.Moment | undefined;
    ngayBaoHanh: moment.Moment | undefined;
    hanSD: moment.Moment | undefined;
    ghiChu: string | undefined;
    nguoiChotGia: number | undefined;
    thoiDiemChotGia: moment.Moment | undefined;
    giaCuoiTS: number | undefined;
    noiDungChotGia: string | undefined;
    dropdownMultiple: string | undefined;
    thoiGianChietKhauHao: number | undefined;
    nguonKinhPhiId: number | undefined;
    listHA: TaiSanDinhKemFile[] | undefined;
    listFile: TaiSanDinhKemFile[] | undefined;
}

export class ViTriTSDto implements IViTriTSDto {
    ngayThucHien: string | undefined;
    phongBanQuanLy: string | undefined;
    hanhDong: string | undefined;

    constructor(data?: IViTriTSDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ngayThucHien = _data["ngayThucHien"];
            this.phongBanQuanLy = _data["phongBanQuanLy"];
            this.hanhDong = _data["hanhDong"];
        }
    }

    static fromJS(data: any): ViTriTSDto {
        data = typeof data === 'object' ? data : {};
        let result = new ViTriTSDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ngayThucHien"] = this.ngayThucHien;
        data["phongBanQuanLy"] = this.phongBanQuanLy;
        data["hanhDong"] = this.hanhDong;
        return data; 
    }

    clone(): ViTriTSDto {
        const json = this.toJSON();
        let result = new ViTriTSDto();
        result.init(json);
        return result;
    }
}

export interface IViTriTSDto {
    ngayThucHien: string | undefined;
    phongBanQuanLy: string | undefined;
    hanhDong: string | undefined;
}

export class ThongTinSDDto implements IThongTinSDDto {
    tuNgay: string | undefined;
    denNgay: string | undefined;
    phongBanQuanLy: string | undefined;
    ndSuDung: string | undefined;

    constructor(data?: IThongTinSDDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tuNgay = _data["tuNgay"];
            this.denNgay = _data["denNgay"];
            this.phongBanQuanLy = _data["phongBanQuanLy"];
            this.ndSuDung = _data["ndSuDung"];
        }
    }

    static fromJS(data: any): ThongTinSDDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThongTinSDDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tuNgay"] = this.tuNgay;
        data["denNgay"] = this.denNgay;
        data["phongBanQuanLy"] = this.phongBanQuanLy;
        data["ndSuDung"] = this.ndSuDung;
        return data; 
    }

    clone(): ThongTinSDDto {
        const json = this.toJSON();
        let result = new ThongTinSDDto();
        result.init(json);
        return result;
    }
}

export interface IThongTinSDDto {
    tuNgay: string | undefined;
    denNgay: string | undefined;
    phongBanQuanLy: string | undefined;
    ndSuDung: string | undefined;
}

export class ThongTinSCBDDto implements IThongTinSCBDDto {
    ngayBatDau: string | undefined;
    ngayHoanThanh: string | undefined;
    phongBanQuanLy: string | undefined;
    noiDung: string | undefined;
    ketQua: string | undefined;

    constructor(data?: IThongTinSCBDDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ngayBatDau = _data["ngayBatDau"];
            this.ngayHoanThanh = _data["ngayHoanThanh"];
            this.phongBanQuanLy = _data["phongBanQuanLy"];
            this.noiDung = _data["noiDung"];
            this.ketQua = _data["ketQua"];
        }
    }

    static fromJS(data: any): ThongTinSCBDDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThongTinSCBDDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ngayBatDau"] = this.ngayBatDau;
        data["ngayHoanThanh"] = this.ngayHoanThanh;
        data["phongBanQuanLy"] = this.phongBanQuanLy;
        data["noiDung"] = this.noiDung;
        data["ketQua"] = this.ketQua;
        return data; 
    }

    clone(): ThongTinSCBDDto {
        const json = this.toJSON();
        let result = new ThongTinSCBDDto();
        result.init(json);
        return result;
    }
}

export interface IThongTinSCBDDto {
    ngayBatDau: string | undefined;
    ngayHoanThanh: string | undefined;
    phongBanQuanLy: string | undefined;
    noiDung: string | undefined;
    ketQua: string | undefined;
}

export class ThongTinHongDto implements IThongTinHongDto {
    ngayKhaiBao: string | undefined;
    phongBanQuanLy: string | undefined;
    noiDung: string | undefined;

    constructor(data?: IThongTinHongDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ngayKhaiBao = _data["ngayKhaiBao"];
            this.phongBanQuanLy = _data["phongBanQuanLy"];
            this.noiDung = _data["noiDung"];
        }
    }

    static fromJS(data: any): ThongTinHongDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThongTinHongDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ngayKhaiBao"] = this.ngayKhaiBao;
        data["phongBanQuanLy"] = this.phongBanQuanLy;
        data["noiDung"] = this.noiDung;
        return data; 
    }

    clone(): ThongTinHongDto {
        const json = this.toJSON();
        let result = new ThongTinHongDto();
        result.init(json);
        return result;
    }
}

export interface IThongTinHongDto {
    ngayKhaiBao: string | undefined;
    phongBanQuanLy: string | undefined;
    noiDung: string | undefined;
}

export class ThongTinMatDto implements IThongTinMatDto {
    ngayKhaiBao: string | undefined;
    phongBanQuanLy: string | undefined;
    noiDung: string | undefined;

    constructor(data?: IThongTinMatDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ngayKhaiBao = _data["ngayKhaiBao"];
            this.phongBanQuanLy = _data["phongBanQuanLy"];
            this.noiDung = _data["noiDung"];
        }
    }

    static fromJS(data: any): ThongTinMatDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThongTinMatDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ngayKhaiBao"] = this.ngayKhaiBao;
        data["phongBanQuanLy"] = this.phongBanQuanLy;
        data["noiDung"] = this.noiDung;
        return data; 
    }

    clone(): ThongTinMatDto {
        const json = this.toJSON();
        let result = new ThongTinMatDto();
        result.init(json);
        return result;
    }
}

export interface IThongTinMatDto {
    ngayKhaiBao: string | undefined;
    phongBanQuanLy: string | undefined;
    noiDung: string | undefined;
}

export class ThongTinHuyDto implements IThongTinHuyDto {
    ngayKhaiBao: string | undefined;
    phongBanQuanLy: string | undefined;
    noiDung: string | undefined;

    constructor(data?: IThongTinHuyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ngayKhaiBao = _data["ngayKhaiBao"];
            this.phongBanQuanLy = _data["phongBanQuanLy"];
            this.noiDung = _data["noiDung"];
        }
    }

    static fromJS(data: any): ThongTinHuyDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThongTinHuyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ngayKhaiBao"] = this.ngayKhaiBao;
        data["phongBanQuanLy"] = this.phongBanQuanLy;
        data["noiDung"] = this.noiDung;
        return data; 
    }

    clone(): ThongTinHuyDto {
        const json = this.toJSON();
        let result = new ThongTinHuyDto();
        result.init(json);
        return result;
    }
}

export interface IThongTinHuyDto {
    ngayKhaiBao: string | undefined;
    phongBanQuanLy: string | undefined;
    noiDung: string | undefined;
}

export class ThongTinThanhLyDto implements IThongTinThanhLyDto {
    ngayKhaiBao: string | undefined;
    phongBanQuanLy: string | undefined;
    noiDung: string | undefined;

    constructor(data?: IThongTinThanhLyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ngayKhaiBao = _data["ngayKhaiBao"];
            this.phongBanQuanLy = _data["phongBanQuanLy"];
            this.noiDung = _data["noiDung"];
        }
    }

    static fromJS(data: any): ThongTinThanhLyDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThongTinThanhLyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ngayKhaiBao"] = this.ngayKhaiBao;
        data["phongBanQuanLy"] = this.phongBanQuanLy;
        data["noiDung"] = this.noiDung;
        return data; 
    }

    clone(): ThongTinThanhLyDto {
        const json = this.toJSON();
        let result = new ThongTinThanhLyDto();
        result.init(json);
        return result;
    }
}

export interface IThongTinThanhLyDto {
    ngayKhaiBao: string | undefined;
    phongBanQuanLy: string | undefined;
    noiDung: string | undefined;
}

export class GetForViewDto implements IGetForViewDto {
    id: number | undefined;
    tenTS: string | undefined;
    loaiTS: number | undefined;
    loaiTaiSan: string | undefined;
    serialNumber: string | undefined;
    productNumber: string | undefined;
    readerMacId: string | undefined;
    nhaCC: number | undefined;
    hangSanXuat: string | undefined;
    nguyenGia: string | undefined;
    ngayMua: moment.Moment | undefined;
    ngayBaoHanh: moment.Moment | undefined;
    hanSD: moment.Moment | undefined;
    ghiChu: string | undefined;
    nguoiChotGia: string | undefined;
    thoiDiemChotGia: moment.Moment | undefined;
    giaCuoiTS: number;
    noiDungChotGia: string | undefined;
    maRFID: string | undefined;
    tinhTrangMaRFID: string | undefined;
    maQRCode: string | undefined;
    tinhTrangMaQRCode: string | undefined;
    maBarCode: string | undefined;
    tinhTrangMaBarCode: string | undefined;
    epcCode: string | undefined;
    maQuanLy: string | undefined;
    tinhTrangRFID: boolean | undefined;
    tinhTrangQRCode: boolean | undefined;
    tinhTrangBarCode: boolean | undefined;
    dropdownMultiple: string | undefined;
    thoiGianChietKhauHao: number | undefined;
    nguonKinhPhiId: number | undefined;
    listHinhAnh: TaiSanDinhKemFile[] | undefined;
    listFile: TaiSanDinhKemFile[] | undefined;
    listViTriTS: ViTriTSDto[] | undefined;
    listThongTinSD: ThongTinSDDto[] | undefined;
    listThongTinSCBD: ThongTinSCBDDto[] | undefined;
    listThongTinHong: ThongTinHongDto[] | undefined;
    listThongTinMat: ThongTinMatDto[] | undefined;
    listThongTinHuy: ThongTinHuyDto[] | undefined;
    listThongTinThanhLy: ThongTinThanhLyDto[] | undefined;

    constructor(data?: IGetForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenTS = _data["tenTS"];
            this.loaiTS = _data["loaiTS"];
            this.loaiTaiSan = _data["loaiTaiSan"];
            this.serialNumber = _data["serialNumber"];
            this.productNumber = _data["productNumber"];
            this.readerMacId = _data["readerMacId"];
            this.nhaCC = _data["nhaCC"];
            this.hangSanXuat = _data["hangSanXuat"];
            this.nguyenGia = _data["nguyenGia"];
            this.ngayMua = _data["ngayMua"] ? moment(_data["ngayMua"].toString()) : <any>undefined;
            this.ngayBaoHanh = _data["ngayBaoHanh"] ? moment(_data["ngayBaoHanh"].toString()) : <any>undefined;
            this.hanSD = _data["hanSD"] ? moment(_data["hanSD"].toString()) : <any>undefined;
            this.ghiChu = _data["ghiChu"];
            this.nguoiChotGia = _data["nguoiChotGia"];
            this.thoiDiemChotGia = _data["thoiDiemChotGia"] ? moment(_data["thoiDiemChotGia"].toString()) : <any>undefined;
            this.giaCuoiTS = _data["giaCuoiTS"];
            this.noiDungChotGia = _data["noiDungChotGia"];
            this.maRFID = _data["maRFID"];
            this.tinhTrangMaRFID = _data["tinhTrangMaRFID"];
            this.maQRCode = _data["maQRCode"];
            this.tinhTrangMaQRCode = _data["tinhTrangMaQRCode"];
            this.maBarCode = _data["maBarCode"];
            this.tinhTrangMaBarCode = _data["tinhTrangMaBarCode"];
            this.epcCode = _data["epcCode"];
            this.maQuanLy = _data["maQuanLy"];
            this.tinhTrangRFID = _data["tinhTrangRFID"];
            this.tinhTrangQRCode = _data["tinhTrangQRCode"];
            this.tinhTrangBarCode = _data["tinhTrangBarCode"];
            this.dropdownMultiple = _data["dropdownMultiple"];
            this.thoiGianChietKhauHao = _data["thoiGianChietKhauHao"];
            this.nguonKinhPhiId = _data["nguonKinhPhiId"];
            if (Array.isArray(_data["listHinhAnh"])) {
                this.listHinhAnh = [] as any;
                for (let item of _data["listHinhAnh"])
                    this.listHinhAnh.push(TaiSanDinhKemFile.fromJS(item));
            }
            if (Array.isArray(_data["listFile"])) {
                this.listFile = [] as any;
                for (let item of _data["listFile"])
                    this.listFile.push(TaiSanDinhKemFile.fromJS(item));
            }
            if (Array.isArray(_data["listViTriTS"])) {
                this.listViTriTS = [] as any;
                for (let item of _data["listViTriTS"])
                    this.listViTriTS.push(ViTriTSDto.fromJS(item));
            }
            if (Array.isArray(_data["listThongTinSD"])) {
                this.listThongTinSD = [] as any;
                for (let item of _data["listThongTinSD"])
                    this.listThongTinSD.push(ThongTinSDDto.fromJS(item));
            }
            if (Array.isArray(_data["listThongTinSCBD"])) {
                this.listThongTinSCBD = [] as any;
                for (let item of _data["listThongTinSCBD"])
                    this.listThongTinSCBD.push(ThongTinSCBDDto.fromJS(item));
            }
            if (Array.isArray(_data["listThongTinHong"])) {
                this.listThongTinHong = [] as any;
                for (let item of _data["listThongTinHong"])
                    this.listThongTinHong.push(ThongTinHongDto.fromJS(item));
            }
            if (Array.isArray(_data["listThongTinMat"])) {
                this.listThongTinMat = [] as any;
                for (let item of _data["listThongTinMat"])
                    this.listThongTinMat.push(ThongTinMatDto.fromJS(item));
            }
            if (Array.isArray(_data["listThongTinHuy"])) {
                this.listThongTinHuy = [] as any;
                for (let item of _data["listThongTinHuy"])
                    this.listThongTinHuy.push(ThongTinHuyDto.fromJS(item));
            }
            if (Array.isArray(_data["listThongTinThanhLy"])) {
                this.listThongTinThanhLy = [] as any;
                for (let item of _data["listThongTinThanhLy"])
                    this.listThongTinThanhLy.push(ThongTinThanhLyDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenTS"] = this.tenTS;
        data["loaiTS"] = this.loaiTS;
        data["loaiTaiSan"] = this.loaiTaiSan;
        data["serialNumber"] = this.serialNumber;
        data["productNumber"] = this.productNumber;
        data["readerMacId"] = this.readerMacId;
        data["nhaCC"] = this.nhaCC;
        data["hangSanXuat"] = this.hangSanXuat;
        data["nguyenGia"] = this.nguyenGia;
        data["ngayMua"] = this.ngayMua ? this.ngayMua.toISOString() : <any>undefined;
        data["ngayBaoHanh"] = this.ngayBaoHanh ? this.ngayBaoHanh.toISOString() : <any>undefined;
        data["hanSD"] = this.hanSD ? this.hanSD.toISOString() : <any>undefined;
        data["ghiChu"] = this.ghiChu;
        data["nguoiChotGia"] = this.nguoiChotGia;
        data["thoiDiemChotGia"] = this.thoiDiemChotGia ? this.thoiDiemChotGia.toISOString() : <any>undefined;
        data["giaCuoiTS"] = this.giaCuoiTS;
        data["noiDungChotGia"] = this.noiDungChotGia;
        data["maRFID"] = this.maRFID;
        data["tinhTrangMaRFID"] = this.tinhTrangMaRFID;
        data["maQRCode"] = this.maQRCode;
        data["tinhTrangMaQRCode"] = this.tinhTrangMaQRCode;
        data["maBarCode"] = this.maBarCode;
        data["tinhTrangMaBarCode"] = this.tinhTrangMaBarCode;
        data["epcCode"] = this.epcCode;
        data["maQuanLy"] = this.maQuanLy;
        data["tinhTrangRFID"] = this.tinhTrangRFID;
        data["tinhTrangQRCode"] = this.tinhTrangQRCode;
        data["tinhTrangBarCode"] = this.tinhTrangBarCode;
        data["dropdownMultiple"] = this.dropdownMultiple;
        data["thoiGianChietKhauHao"] = this.thoiGianChietKhauHao;
        data["nguonKinhPhiId"] = this.nguonKinhPhiId;
        if (Array.isArray(this.listHinhAnh)) {
            data["listHinhAnh"] = [];
            for (let item of this.listHinhAnh)
                data["listHinhAnh"].push(item.toJSON());
        }
        if (Array.isArray(this.listFile)) {
            data["listFile"] = [];
            for (let item of this.listFile)
                data["listFile"].push(item.toJSON());
        }
        if (Array.isArray(this.listViTriTS)) {
            data["listViTriTS"] = [];
            for (let item of this.listViTriTS)
                data["listViTriTS"].push(item.toJSON());
        }
        if (Array.isArray(this.listThongTinSD)) {
            data["listThongTinSD"] = [];
            for (let item of this.listThongTinSD)
                data["listThongTinSD"].push(item.toJSON());
        }
        if (Array.isArray(this.listThongTinSCBD)) {
            data["listThongTinSCBD"] = [];
            for (let item of this.listThongTinSCBD)
                data["listThongTinSCBD"].push(item.toJSON());
        }
        if (Array.isArray(this.listThongTinHong)) {
            data["listThongTinHong"] = [];
            for (let item of this.listThongTinHong)
                data["listThongTinHong"].push(item.toJSON());
        }
        if (Array.isArray(this.listThongTinMat)) {
            data["listThongTinMat"] = [];
            for (let item of this.listThongTinMat)
                data["listThongTinMat"].push(item.toJSON());
        }
        if (Array.isArray(this.listThongTinHuy)) {
            data["listThongTinHuy"] = [];
            for (let item of this.listThongTinHuy)
                data["listThongTinHuy"].push(item.toJSON());
        }
        if (Array.isArray(this.listThongTinThanhLy)) {
            data["listThongTinThanhLy"] = [];
            for (let item of this.listThongTinThanhLy)
                data["listThongTinThanhLy"].push(item.toJSON());
        }
        return data; 
    }

    clone(): GetForViewDto {
        const json = this.toJSON();
        let result = new GetForViewDto();
        result.init(json);
        return result;
    }
}

export interface IGetForViewDto {
    id: number | undefined;
    tenTS: string | undefined;
    loaiTS: number | undefined;
    loaiTaiSan: string | undefined;
    serialNumber: string | undefined;
    productNumber: string | undefined;
    readerMacId: string | undefined;
    nhaCC: number | undefined;
    hangSanXuat: string | undefined;
    nguyenGia: string | undefined;
    ngayMua: moment.Moment | undefined;
    ngayBaoHanh: moment.Moment | undefined;
    hanSD: moment.Moment | undefined;
    ghiChu: string | undefined;
    nguoiChotGia: string | undefined;
    thoiDiemChotGia: moment.Moment | undefined;
    giaCuoiTS: number;
    noiDungChotGia: string | undefined;
    maRFID: string | undefined;
    tinhTrangMaRFID: string | undefined;
    maQRCode: string | undefined;
    tinhTrangMaQRCode: string | undefined;
    maBarCode: string | undefined;
    tinhTrangMaBarCode: string | undefined;
    epcCode: string | undefined;
    maQuanLy: string | undefined;
    tinhTrangRFID: boolean | undefined;
    tinhTrangQRCode: boolean | undefined;
    tinhTrangBarCode: boolean | undefined;
    dropdownMultiple: string | undefined;
    thoiGianChietKhauHao: number | undefined;
    nguonKinhPhiId: number | undefined;
    listHinhAnh: TaiSanDinhKemFile[] | undefined;
    listFile: TaiSanDinhKemFile[] | undefined;
    listViTriTS: ViTriTSDto[] | undefined;
    listThongTinSD: ThongTinSDDto[] | undefined;
    listThongTinSCBD: ThongTinSCBDDto[] | undefined;
    listThongTinHong: ThongTinHongDto[] | undefined;
    listThongTinMat: ThongTinMatDto[] | undefined;
    listThongTinHuy: ThongTinHuyDto[] | undefined;
    listThongTinThanhLy: ThongTinThanhLyDto[] | undefined;
}

export class FileDto implements IFileDto {
    fileName: string;
    fileType: string;
    fileToken: string;

    constructor(data?: IFileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fileName = _data["fileName"];
            this.fileType = _data["fileType"];
            this.fileToken = _data["fileToken"];
        }
    }

    static fromJS(data: any): FileDto {
        data = typeof data === 'object' ? data : {};
        let result = new FileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileName"] = this.fileName;
        data["fileType"] = this.fileType;
        data["fileToken"] = this.fileToken;
        return data; 
    }

    clone(): FileDto {
        const json = this.toJSON();
        let result = new FileDto();
        result.init(json);
        return result;
    }
}

export interface IFileDto {
    fileName: string;
    fileType: string;
    fileToken: string;
}

export class InputRFIDDto implements IInputRFIDDto {
    tenTS: string | undefined;
    phongBanSuDung: number[] | undefined;
    tinhTrangSuDung: number | undefined;
    isSearch: boolean | undefined;
    sorting: string | undefined;
    skipCount: number;
    maxResultCount: number;

    constructor(data?: IInputRFIDDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenTS = _data["tenTS"];
            if (Array.isArray(_data["phongBanSuDung"])) {
                this.phongBanSuDung = [] as any;
                for (let item of _data["phongBanSuDung"])
                    this.phongBanSuDung.push(item);
            }
            this.tinhTrangSuDung = _data["tinhTrangSuDung"];
            this.isSearch = _data["isSearch"];
            this.sorting = _data["sorting"];
            this.skipCount = _data["skipCount"];
            this.maxResultCount = _data["maxResultCount"];
        }
    }

    static fromJS(data: any): InputRFIDDto {
        data = typeof data === 'object' ? data : {};
        let result = new InputRFIDDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenTS"] = this.tenTS;
        if (Array.isArray(this.phongBanSuDung)) {
            data["phongBanSuDung"] = [];
            for (let item of this.phongBanSuDung)
                data["phongBanSuDung"].push(item);
        }
        data["tinhTrangSuDung"] = this.tinhTrangSuDung;
        data["isSearch"] = this.isSearch;
        data["sorting"] = this.sorting;
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        return data; 
    }

    clone(): InputRFIDDto {
        const json = this.toJSON();
        let result = new InputRFIDDto();
        result.init(json);
        return result;
    }
}

export interface IInputRFIDDto {
    tenTS: string | undefined;
    phongBanSuDung: number[] | undefined;
    tinhTrangSuDung: number | undefined;
    isSearch: boolean | undefined;
    sorting: string | undefined;
    skipCount: number;
    maxResultCount: number;
}

export class AuditLogListDto implements IAuditLogListDto {
    userId: number | undefined;
    userName: string | undefined;
    impersonatorTenantId: number | undefined;
    impersonatorUserId: number | undefined;
    serviceName: string | undefined;
    serviceNameForView: string | undefined;
    methodName: string | undefined;
    parameters: string | undefined;
    executionTime: moment.Moment;
    executionDuration: number;
    clientIpAddress: string | undefined;
    clientName: string | undefined;
    browserInfo: string | undefined;
    exception: string | undefined;
    customData: string | undefined;
    id: number;

    constructor(data?: IAuditLogListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.userName = _data["userName"];
            this.impersonatorTenantId = _data["impersonatorTenantId"];
            this.impersonatorUserId = _data["impersonatorUserId"];
            this.serviceName = _data["serviceName"];
            this.serviceNameForView = _data["serviceNameForView"];
            this.methodName = _data["methodName"];
            this.parameters = _data["parameters"];
            this.executionTime = _data["executionTime"] ? moment(_data["executionTime"].toString()) : <any>undefined;
            this.executionDuration = _data["executionDuration"];
            this.clientIpAddress = _data["clientIpAddress"];
            this.clientName = _data["clientName"];
            this.browserInfo = _data["browserInfo"];
            this.exception = _data["exception"];
            this.customData = _data["customData"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AuditLogListDto {
        data = typeof data === 'object' ? data : {};
        let result = new AuditLogListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["impersonatorTenantId"] = this.impersonatorTenantId;
        data["impersonatorUserId"] = this.impersonatorUserId;
        data["serviceName"] = this.serviceName;
        data["serviceNameForView"] = this.serviceNameForView;
        data["methodName"] = this.methodName;
        data["parameters"] = this.parameters;
        data["executionTime"] = this.executionTime ? this.executionTime.toISOString() : <any>undefined;
        data["executionDuration"] = this.executionDuration;
        data["clientIpAddress"] = this.clientIpAddress;
        data["clientName"] = this.clientName;
        data["browserInfo"] = this.browserInfo;
        data["exception"] = this.exception;
        data["customData"] = this.customData;
        data["id"] = this.id;
        return data; 
    }

    clone(): AuditLogListDto {
        const json = this.toJSON();
        let result = new AuditLogListDto();
        result.init(json);
        return result;
    }
}

export interface IAuditLogListDto {
    userId: number | undefined;
    userName: string | undefined;
    impersonatorTenantId: number | undefined;
    impersonatorUserId: number | undefined;
    serviceName: string | undefined;
    serviceNameForView: string | undefined;
    methodName: string | undefined;
    parameters: string | undefined;
    executionTime: moment.Moment;
    executionDuration: number;
    clientIpAddress: string | undefined;
    clientName: string | undefined;
    browserInfo: string | undefined;
    exception: string | undefined;
    customData: string | undefined;
    id: number;
}

export class AuditLogListDtoPagedResultDto implements IAuditLogListDtoPagedResultDto {
    totalCount: number;
    items: AuditLogListDto[] | undefined;

    constructor(data?: IAuditLogListDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(AuditLogListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AuditLogListDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new AuditLogListDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): AuditLogListDtoPagedResultDto {
        const json = this.toJSON();
        let result = new AuditLogListDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IAuditLogListDtoPagedResultDto {
    totalCount: number;
    items: AuditLogListDto[] | undefined;
}

export class GetAuditLogsInput implements IGetAuditLogsInput {
    startDate: moment.Moment | undefined;
    endDate: moment.Moment | undefined;
    userName: string | undefined;
    serviceName: string | undefined;
    isSearch: boolean | undefined;
    sorting: string | undefined;
    skipCount: number;
    maxResultCount: number;

    constructor(data?: IGetAuditLogsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.userName = _data["userName"];
            this.serviceName = _data["serviceName"];
            this.isSearch = _data["isSearch"];
            this.sorting = _data["sorting"];
            this.skipCount = _data["skipCount"];
            this.maxResultCount = _data["maxResultCount"];
        }
    }

    static fromJS(data: any): GetAuditLogsInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAuditLogsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["userName"] = this.userName;
        data["serviceName"] = this.serviceName;
        data["isSearch"] = this.isSearch;
        data["sorting"] = this.sorting;
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        return data; 
    }

    clone(): GetAuditLogsInput {
        const json = this.toJSON();
        let result = new GetAuditLogsInput();
        result.init(json);
        return result;
    }
}

export interface IGetAuditLogsInput {
    startDate: moment.Moment | undefined;
    endDate: moment.Moment | undefined;
    userName: string | undefined;
    serviceName: string | undefined;
    isSearch: boolean | undefined;
    sorting: string | undefined;
    skipCount: number;
    maxResultCount: number;
}

export class StringLookupTableDto implements IStringLookupTableDto {
    id: string | undefined;
    displayName: string | undefined;

    constructor(data?: IStringLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): StringLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new StringLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }

    clone(): StringLookupTableDto {
        const json = this.toJSON();
        let result = new StringLookupTableDto();
        result.init(json);
        return result;
    }
}

export interface IStringLookupTableDto {
    id: string | undefined;
    displayName: string | undefined;
}

export class ListBaoCaoCanhBaoOutputDto implements IListBaoCaoCanhBaoOutputDto {
    ngayKhaiBao: moment.Moment | undefined;
    taiSanRa: number | undefined;
    taiSanVao: number | undefined;
    batDauKiemKe: number | undefined;
    ketThucKiemKe: number | undefined;
    toTal: string | undefined;
    isCheck: boolean;

    constructor(data?: IListBaoCaoCanhBaoOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ngayKhaiBao = _data["ngayKhaiBao"] ? moment(_data["ngayKhaiBao"].toString()) : <any>undefined;
            this.taiSanRa = _data["taiSanRa"];
            this.taiSanVao = _data["taiSanVao"];
            this.batDauKiemKe = _data["batDauKiemKe"];
            this.ketThucKiemKe = _data["ketThucKiemKe"];
            this.toTal = _data["toTal"];
            this.isCheck = _data["isCheck"];
        }
    }

    static fromJS(data: any): ListBaoCaoCanhBaoOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListBaoCaoCanhBaoOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ngayKhaiBao"] = this.ngayKhaiBao ? this.ngayKhaiBao.toISOString() : <any>undefined;
        data["taiSanRa"] = this.taiSanRa;
        data["taiSanVao"] = this.taiSanVao;
        data["batDauKiemKe"] = this.batDauKiemKe;
        data["ketThucKiemKe"] = this.ketThucKiemKe;
        data["toTal"] = this.toTal;
        data["isCheck"] = this.isCheck;
        return data; 
    }

    clone(): ListBaoCaoCanhBaoOutputDto {
        const json = this.toJSON();
        let result = new ListBaoCaoCanhBaoOutputDto();
        result.init(json);
        return result;
    }
}

export interface IListBaoCaoCanhBaoOutputDto {
    ngayKhaiBao: moment.Moment | undefined;
    taiSanRa: number | undefined;
    taiSanVao: number | undefined;
    batDauKiemKe: number | undefined;
    ketThucKiemKe: number | undefined;
    toTal: string | undefined;
    isCheck: boolean;
}

export class ListViewDto implements IListViewDto {
    ngayKhaiBao: moment.Moment | undefined;
    listLogin: number | undefined;
    listLogout: number | undefined;
    listCreate: number | undefined;
    listDelete: number | undefined;
    listHoanTac: number | undefined;
    listEdit: number | undefined;
    listView: number | undefined;
    listCapPhat: number | undefined;
    listKhaiBaoSuDung: number | undefined;
    listThuHoi: number | undefined;
    listDieuChuyen: number | undefined;
    listHongMatTaiSan: number | undefined;
    listDownLoad: number | undefined;
    listUpload: number | undefined;
    listSearch: number | undefined;
    toTal: string | undefined;
    isCheck: boolean;

    constructor(data?: IListViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ngayKhaiBao = _data["ngayKhaiBao"] ? moment(_data["ngayKhaiBao"].toString()) : <any>undefined;
            this.listLogin = _data["listLogin"];
            this.listLogout = _data["listLogout"];
            this.listCreate = _data["listCreate"];
            this.listDelete = _data["listDelete"];
            this.listHoanTac = _data["listHoanTac"];
            this.listEdit = _data["listEdit"];
            this.listView = _data["listView"];
            this.listCapPhat = _data["listCapPhat"];
            this.listKhaiBaoSuDung = _data["listKhaiBaoSuDung"];
            this.listThuHoi = _data["listThuHoi"];
            this.listDieuChuyen = _data["listDieuChuyen"];
            this.listHongMatTaiSan = _data["listHongMatTaiSan"];
            this.listDownLoad = _data["listDownLoad"];
            this.listUpload = _data["listUpload"];
            this.listSearch = _data["listSearch"];
            this.toTal = _data["toTal"];
            this.isCheck = _data["isCheck"];
        }
    }

    static fromJS(data: any): ListViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ngayKhaiBao"] = this.ngayKhaiBao ? this.ngayKhaiBao.toISOString() : <any>undefined;
        data["listLogin"] = this.listLogin;
        data["listLogout"] = this.listLogout;
        data["listCreate"] = this.listCreate;
        data["listDelete"] = this.listDelete;
        data["listHoanTac"] = this.listHoanTac;
        data["listEdit"] = this.listEdit;
        data["listView"] = this.listView;
        data["listCapPhat"] = this.listCapPhat;
        data["listKhaiBaoSuDung"] = this.listKhaiBaoSuDung;
        data["listThuHoi"] = this.listThuHoi;
        data["listDieuChuyen"] = this.listDieuChuyen;
        data["listHongMatTaiSan"] = this.listHongMatTaiSan;
        data["listDownLoad"] = this.listDownLoad;
        data["listUpload"] = this.listUpload;
        data["listSearch"] = this.listSearch;
        data["toTal"] = this.toTal;
        data["isCheck"] = this.isCheck;
        return data; 
    }

    clone(): ListViewDto {
        const json = this.toJSON();
        let result = new ListViewDto();
        result.init(json);
        return result;
    }
}

export interface IListViewDto {
    ngayKhaiBao: moment.Moment | undefined;
    listLogin: number | undefined;
    listLogout: number | undefined;
    listCreate: number | undefined;
    listDelete: number | undefined;
    listHoanTac: number | undefined;
    listEdit: number | undefined;
    listView: number | undefined;
    listCapPhat: number | undefined;
    listKhaiBaoSuDung: number | undefined;
    listThuHoi: number | undefined;
    listDieuChuyen: number | undefined;
    listHongMatTaiSan: number | undefined;
    listDownLoad: number | undefined;
    listUpload: number | undefined;
    listSearch: number | undefined;
    toTal: string | undefined;
    isCheck: boolean;
}

export class ListBaoCaoChiTietDto implements IListBaoCaoChiTietDto {
    ngayKhaiBao: moment.Moment | undefined;
    listDangSuDung: number | undefined;
    listCapPhat: number | undefined;
    listThuHoi: number | undefined;
    listDieuChuyen: number | undefined;
    listBaoMat: number | undefined;
    listBaoHong: number | undefined;
    listBaoHuy: number | undefined;
    listThanhLy: number | undefined;
    listDuTruMuaSam: number | undefined;
    listSuaChua: number | undefined;
    listBaoDuong: number | undefined;
    toTal: string | undefined;
    isCheck: boolean;

    constructor(data?: IListBaoCaoChiTietDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ngayKhaiBao = _data["ngayKhaiBao"] ? moment(_data["ngayKhaiBao"].toString()) : <any>undefined;
            this.listDangSuDung = _data["listDangSuDung"];
            this.listCapPhat = _data["listCapPhat"];
            this.listThuHoi = _data["listThuHoi"];
            this.listDieuChuyen = _data["listDieuChuyen"];
            this.listBaoMat = _data["listBaoMat"];
            this.listBaoHong = _data["listBaoHong"];
            this.listBaoHuy = _data["listBaoHuy"];
            this.listThanhLy = _data["listThanhLy"];
            this.listDuTruMuaSam = _data["listDuTruMuaSam"];
            this.listSuaChua = _data["listSuaChua"];
            this.listBaoDuong = _data["listBaoDuong"];
            this.toTal = _data["toTal"];
            this.isCheck = _data["isCheck"];
        }
    }

    static fromJS(data: any): ListBaoCaoChiTietDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListBaoCaoChiTietDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ngayKhaiBao"] = this.ngayKhaiBao ? this.ngayKhaiBao.toISOString() : <any>undefined;
        data["listDangSuDung"] = this.listDangSuDung;
        data["listCapPhat"] = this.listCapPhat;
        data["listThuHoi"] = this.listThuHoi;
        data["listDieuChuyen"] = this.listDieuChuyen;
        data["listBaoMat"] = this.listBaoMat;
        data["listBaoHong"] = this.listBaoHong;
        data["listBaoHuy"] = this.listBaoHuy;
        data["listThanhLy"] = this.listThanhLy;
        data["listDuTruMuaSam"] = this.listDuTruMuaSam;
        data["listSuaChua"] = this.listSuaChua;
        data["listBaoDuong"] = this.listBaoDuong;
        data["toTal"] = this.toTal;
        data["isCheck"] = this.isCheck;
        return data; 
    }

    clone(): ListBaoCaoChiTietDto {
        const json = this.toJSON();
        let result = new ListBaoCaoChiTietDto();
        result.init(json);
        return result;
    }
}

export interface IListBaoCaoChiTietDto {
    ngayKhaiBao: moment.Moment | undefined;
    listDangSuDung: number | undefined;
    listCapPhat: number | undefined;
    listThuHoi: number | undefined;
    listDieuChuyen: number | undefined;
    listBaoMat: number | undefined;
    listBaoHong: number | undefined;
    listBaoHuy: number | undefined;
    listThanhLy: number | undefined;
    listDuTruMuaSam: number | undefined;
    listSuaChua: number | undefined;
    listBaoDuong: number | undefined;
    toTal: string | undefined;
    isCheck: boolean;
}

export class CanhBaoForViewDto implements ICanhBaoForViewDto {
    id: number;
    noiDung: string | undefined;
    toChucId: number | undefined;
    toChuc: string | undefined;
    taiKhoanId: number | undefined;
    thoiGian: string | undefined;
    date: moment.Moment;

    constructor(data?: ICanhBaoForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.noiDung = _data["noiDung"];
            this.toChucId = _data["toChucId"];
            this.toChuc = _data["toChuc"];
            this.taiKhoanId = _data["taiKhoanId"];
            this.thoiGian = _data["thoiGian"];
            this.date = _data["date"] ? moment(_data["date"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CanhBaoForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new CanhBaoForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["noiDung"] = this.noiDung;
        data["toChucId"] = this.toChucId;
        data["toChuc"] = this.toChuc;
        data["taiKhoanId"] = this.taiKhoanId;
        data["thoiGian"] = this.thoiGian;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        return data; 
    }

    clone(): CanhBaoForViewDto {
        const json = this.toJSON();
        let result = new CanhBaoForViewDto();
        result.init(json);
        return result;
    }
}

export interface ICanhBaoForViewDto {
    id: number;
    noiDung: string | undefined;
    toChucId: number | undefined;
    toChuc: string | undefined;
    taiKhoanId: number | undefined;
    thoiGian: string | undefined;
    date: moment.Moment;
}

export class CanhBaoForViewDtoPagedResultDto implements ICanhBaoForViewDtoPagedResultDto {
    totalCount: number;
    items: CanhBaoForViewDto[] | undefined;

    constructor(data?: ICanhBaoForViewDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(CanhBaoForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CanhBaoForViewDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new CanhBaoForViewDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): CanhBaoForViewDtoPagedResultDto {
        const json = this.toJSON();
        let result = new CanhBaoForViewDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface ICanhBaoForViewDtoPagedResultDto {
    totalCount: number;
    items: CanhBaoForViewDto[] | undefined;
}

export class ThongBaoOutput implements IThongBaoOutput {
    noiDung: string | undefined;
    thoiGian: string | undefined;
    ngay: moment.Moment;

    constructor(data?: IThongBaoOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.noiDung = _data["noiDung"];
            this.thoiGian = _data["thoiGian"];
            this.ngay = _data["ngay"] ? moment(_data["ngay"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ThongBaoOutput {
        data = typeof data === 'object' ? data : {};
        let result = new ThongBaoOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["noiDung"] = this.noiDung;
        data["thoiGian"] = this.thoiGian;
        data["ngay"] = this.ngay ? this.ngay.toISOString() : <any>undefined;
        return data; 
    }

    clone(): ThongBaoOutput {
        const json = this.toJSON();
        let result = new ThongBaoOutput();
        result.init(json);
        return result;
    }
}

export interface IThongBaoOutput {
    noiDung: string | undefined;
    thoiGian: string | undefined;
    ngay: moment.Moment;
}

export class ThongBaoOutputPagedResultDto implements IThongBaoOutputPagedResultDto {
    totalCount: number;
    items: ThongBaoOutput[] | undefined;

    constructor(data?: IThongBaoOutputPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(ThongBaoOutput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ThongBaoOutputPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThongBaoOutputPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ThongBaoOutputPagedResultDto {
        const json = this.toJSON();
        let result = new ThongBaoOutputPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IThongBaoOutputPagedResultDto {
    totalCount: number;
    items: ThongBaoOutput[] | undefined;
}

export class CanhBaoInputDto implements ICanhBaoInputDto {
    taiKhoanId: number | undefined;
    toChucId: number[] | undefined;
    noiDung: string | undefined;
    hoatDong: number | undefined;
    thoiGianFrom: moment.Moment | undefined;
    thoiGianTo: moment.Moment | undefined;
    isSearch: boolean | undefined;
    sorting: string | undefined;
    skipCount: number;
    maxResultCount: number;

    constructor(data?: ICanhBaoInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.taiKhoanId = _data["taiKhoanId"];
            if (Array.isArray(_data["toChucId"])) {
                this.toChucId = [] as any;
                for (let item of _data["toChucId"])
                    this.toChucId.push(item);
            }
            this.noiDung = _data["noiDung"];
            this.hoatDong = _data["hoatDong"];
            this.thoiGianFrom = _data["thoiGianFrom"] ? moment(_data["thoiGianFrom"].toString()) : <any>undefined;
            this.thoiGianTo = _data["thoiGianTo"] ? moment(_data["thoiGianTo"].toString()) : <any>undefined;
            this.isSearch = _data["isSearch"];
            this.sorting = _data["sorting"];
            this.skipCount = _data["skipCount"];
            this.maxResultCount = _data["maxResultCount"];
        }
    }

    static fromJS(data: any): CanhBaoInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new CanhBaoInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["taiKhoanId"] = this.taiKhoanId;
        if (Array.isArray(this.toChucId)) {
            data["toChucId"] = [];
            for (let item of this.toChucId)
                data["toChucId"].push(item);
        }
        data["noiDung"] = this.noiDung;
        data["hoatDong"] = this.hoatDong;
        data["thoiGianFrom"] = this.thoiGianFrom ? this.thoiGianFrom.toISOString() : <any>undefined;
        data["thoiGianTo"] = this.thoiGianTo ? this.thoiGianTo.toISOString() : <any>undefined;
        data["isSearch"] = this.isSearch;
        data["sorting"] = this.sorting;
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        return data; 
    }

    clone(): CanhBaoInputDto {
        const json = this.toJSON();
        let result = new CanhBaoInputDto();
        result.init(json);
        return result;
    }
}

export interface ICanhBaoInputDto {
    taiKhoanId: number | undefined;
    toChucId: number[] | undefined;
    noiDung: string | undefined;
    hoatDong: number | undefined;
    thoiGianFrom: moment.Moment | undefined;
    thoiGianTo: moment.Moment | undefined;
    isSearch: boolean | undefined;
    sorting: string | undefined;
    skipCount: number;
    maxResultCount: number;
}

export class InputFromServiceDto implements IInputFromServiceDto {
    taiKhoanId: number | undefined;
    phongBanNhanId: number | undefined;
    noiDung: string | undefined;
    loaiCanhBao: number | undefined;
    idLichSu: number | undefined;

    constructor(data?: IInputFromServiceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.taiKhoanId = _data["taiKhoanId"];
            this.phongBanNhanId = _data["phongBanNhanId"];
            this.noiDung = _data["noiDung"];
            this.loaiCanhBao = _data["loaiCanhBao"];
            this.idLichSu = _data["idLichSu"];
        }
    }

    static fromJS(data: any): InputFromServiceDto {
        data = typeof data === 'object' ? data : {};
        let result = new InputFromServiceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["taiKhoanId"] = this.taiKhoanId;
        data["phongBanNhanId"] = this.phongBanNhanId;
        data["noiDung"] = this.noiDung;
        data["loaiCanhBao"] = this.loaiCanhBao;
        data["idLichSu"] = this.idLichSu;
        return data; 
    }

    clone(): InputFromServiceDto {
        const json = this.toJSON();
        let result = new InputFromServiceDto();
        result.init(json);
        return result;
    }
}

export interface IInputFromServiceDto {
    taiKhoanId: number | undefined;
    phongBanNhanId: number | undefined;
    noiDung: string | undefined;
    loaiCanhBao: number | undefined;
    idLichSu: number | undefined;
}

export class ChangeUiThemeInput implements IChangeUiThemeInput {
    theme: string;

    constructor(data?: IChangeUiThemeInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.theme = _data["theme"];
        }
    }

    static fromJS(data: any): ChangeUiThemeInput {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeUiThemeInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["theme"] = this.theme;
        return data; 
    }

    clone(): ChangeUiThemeInput {
        const json = this.toJSON();
        let result = new ChangeUiThemeInput();
        result.init(json);
        return result;
    }
}

export interface IChangeUiThemeInput {
    theme: string;
}

export class GetAllDatLichBCDtos implements IGetAllDatLichBCDtos {
    id: number | undefined;
    tenBaoCao: string | undefined;
    lapLai: string | undefined;
    gioGuiBC: string | undefined;
    ngayGio: string | undefined;
    ngayGuiTuan: number | undefined;
    ngayGuiThang: number | undefined;
    ngayGuiNam: string | undefined;
    ngayTao: moment.Moment;
    ngayCapNhat: moment.Moment | undefined;

    constructor(data?: IGetAllDatLichBCDtos) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenBaoCao = _data["tenBaoCao"];
            this.lapLai = _data["lapLai"];
            this.gioGuiBC = _data["gioGuiBC"];
            this.ngayGio = _data["ngayGio"];
            this.ngayGuiTuan = _data["ngayGuiTuan"];
            this.ngayGuiThang = _data["ngayGuiThang"];
            this.ngayGuiNam = _data["ngayGuiNam"];
            this.ngayTao = _data["ngayTao"] ? moment(_data["ngayTao"].toString()) : <any>undefined;
            this.ngayCapNhat = _data["ngayCapNhat"] ? moment(_data["ngayCapNhat"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): GetAllDatLichBCDtos {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllDatLichBCDtos();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenBaoCao"] = this.tenBaoCao;
        data["lapLai"] = this.lapLai;
        data["gioGuiBC"] = this.gioGuiBC;
        data["ngayGio"] = this.ngayGio;
        data["ngayGuiTuan"] = this.ngayGuiTuan;
        data["ngayGuiThang"] = this.ngayGuiThang;
        data["ngayGuiNam"] = this.ngayGuiNam;
        data["ngayTao"] = this.ngayTao ? this.ngayTao.toISOString() : <any>undefined;
        data["ngayCapNhat"] = this.ngayCapNhat ? this.ngayCapNhat.toISOString() : <any>undefined;
        return data; 
    }

    clone(): GetAllDatLichBCDtos {
        const json = this.toJSON();
        let result = new GetAllDatLichBCDtos();
        result.init(json);
        return result;
    }
}

export interface IGetAllDatLichBCDtos {
    id: number | undefined;
    tenBaoCao: string | undefined;
    lapLai: string | undefined;
    gioGuiBC: string | undefined;
    ngayGio: string | undefined;
    ngayGuiTuan: number | undefined;
    ngayGuiThang: number | undefined;
    ngayGuiNam: string | undefined;
    ngayTao: moment.Moment;
    ngayCapNhat: moment.Moment | undefined;
}

export class GetAllDatLichBCDtosPagedResultDto implements IGetAllDatLichBCDtosPagedResultDto {
    totalCount: number;
    items: GetAllDatLichBCDtos[] | undefined;

    constructor(data?: IGetAllDatLichBCDtosPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(GetAllDatLichBCDtos.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetAllDatLichBCDtosPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllDatLichBCDtosPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): GetAllDatLichBCDtosPagedResultDto {
        const json = this.toJSON();
        let result = new GetAllDatLichBCDtosPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IGetAllDatLichBCDtosPagedResultDto {
    totalCount: number;
    items: GetAllDatLichBCDtos[] | undefined;
}

export class CreateOrEditDatLichDtos implements ICreateOrEditDatLichDtos {
    baoCaoId: number;
    tenBaoCao: string | undefined;
    lapLaiId: number | undefined;
    gioGuiBaoCao: moment.Moment;
    ngayGuiBaoCao: string | undefined;
    phongBanNhanId: number;
    nguoiNhanBaoCaoId: string | undefined;
    ghiChu: string | undefined;
    id: number | undefined;

    constructor(data?: ICreateOrEditDatLichDtos) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.baoCaoId = _data["baoCaoId"];
            this.tenBaoCao = _data["tenBaoCao"];
            this.lapLaiId = _data["lapLaiId"];
            this.gioGuiBaoCao = _data["gioGuiBaoCao"] ? moment(_data["gioGuiBaoCao"].toString()) : <any>undefined;
            this.ngayGuiBaoCao = _data["ngayGuiBaoCao"];
            this.phongBanNhanId = _data["phongBanNhanId"];
            this.nguoiNhanBaoCaoId = _data["nguoiNhanBaoCaoId"];
            this.ghiChu = _data["ghiChu"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditDatLichDtos {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditDatLichDtos();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["baoCaoId"] = this.baoCaoId;
        data["tenBaoCao"] = this.tenBaoCao;
        data["lapLaiId"] = this.lapLaiId;
        data["gioGuiBaoCao"] = this.gioGuiBaoCao ? this.gioGuiBaoCao.toISOString() : <any>undefined;
        data["ngayGuiBaoCao"] = this.ngayGuiBaoCao;
        data["phongBanNhanId"] = this.phongBanNhanId;
        data["nguoiNhanBaoCaoId"] = this.nguoiNhanBaoCaoId;
        data["ghiChu"] = this.ghiChu;
        data["id"] = this.id;
        return data; 
    }

    clone(): CreateOrEditDatLichDtos {
        const json = this.toJSON();
        let result = new CreateOrEditDatLichDtos();
        result.init(json);
        return result;
    }
}

export interface ICreateOrEditDatLichDtos {
    baoCaoId: number;
    tenBaoCao: string | undefined;
    lapLaiId: number | undefined;
    gioGuiBaoCao: moment.Moment;
    ngayGuiBaoCao: string | undefined;
    phongBanNhanId: number;
    nguoiNhanBaoCaoId: string | undefined;
    ghiChu: string | undefined;
    id: number | undefined;
}

export class GetValueForViewDatLich implements IGetValueForViewDatLich {
    baoCaoId: number;
    tenBaoCao: string | undefined;
    lapLaiId: number | undefined;
    gioBaoCao: moment.Moment;
    ngayGuiBaoCao: string | undefined;
    phongBanNhan: number;
    nguoiNhan: string | undefined;
    ghiChu: string | undefined;

    constructor(data?: IGetValueForViewDatLich) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.baoCaoId = _data["baoCaoId"];
            this.tenBaoCao = _data["tenBaoCao"];
            this.lapLaiId = _data["lapLaiId"];
            this.gioBaoCao = _data["gioBaoCao"] ? moment(_data["gioBaoCao"].toString()) : <any>undefined;
            this.ngayGuiBaoCao = _data["ngayGuiBaoCao"];
            this.phongBanNhan = _data["phongBanNhan"];
            this.nguoiNhan = _data["nguoiNhan"];
            this.ghiChu = _data["ghiChu"];
        }
    }

    static fromJS(data: any): GetValueForViewDatLich {
        data = typeof data === 'object' ? data : {};
        let result = new GetValueForViewDatLich();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["baoCaoId"] = this.baoCaoId;
        data["tenBaoCao"] = this.tenBaoCao;
        data["lapLaiId"] = this.lapLaiId;
        data["gioBaoCao"] = this.gioBaoCao ? this.gioBaoCao.toISOString() : <any>undefined;
        data["ngayGuiBaoCao"] = this.ngayGuiBaoCao;
        data["phongBanNhan"] = this.phongBanNhan;
        data["nguoiNhan"] = this.nguoiNhan;
        data["ghiChu"] = this.ghiChu;
        return data; 
    }

    clone(): GetValueForViewDatLich {
        const json = this.toJSON();
        let result = new GetValueForViewDatLich();
        result.init(json);
        return result;
    }
}

export interface IGetValueForViewDatLich {
    baoCaoId: number;
    tenBaoCao: string | undefined;
    lapLaiId: number | undefined;
    gioBaoCao: moment.Moment;
    ngayGuiBaoCao: string | undefined;
    phongBanNhan: number;
    nguoiNhan: string | undefined;
    ghiChu: string | undefined;
}

export class DemoDto implements IDemoDto {
    ma: string | undefined;
    ten: string | undefined;
    checkbox: string | undefined;
    checkboxTrueFalse: boolean | undefined;
    radioButton: number | undefined;
    inputSwitch: boolean | undefined;
    inputMask: string | undefined;
    slider: number | undefined;
    description: string | undefined;
    inputTextarea: string | undefined;
    integerOnly: number | undefined;
    decimal: number | undefined;
    dateBasic: moment.Moment | undefined;
    dateTime: moment.Moment | undefined;
    dateDisable: moment.Moment | undefined;
    dateMinMax: moment.Moment | undefined;
    dateFrom: moment.Moment | undefined;
    dateTo: moment.Moment | undefined;
    dateMultiple: string | undefined;
    dateMultipleMonth: moment.Moment | undefined;
    monthOnly: moment.Moment | undefined;
    timeOnly: string | undefined;
    autoCompleteSingle: number | undefined;
    autoCompleteMultiple: string | undefined;
    dropdownSingle: number | undefined;
    dropdownMultiple: string | undefined;
    id: number;

    constructor(data?: IDemoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ma = _data["ma"];
            this.ten = _data["ten"];
            this.checkbox = _data["checkbox"];
            this.checkboxTrueFalse = _data["checkboxTrueFalse"];
            this.radioButton = _data["radioButton"];
            this.inputSwitch = _data["inputSwitch"];
            this.inputMask = _data["inputMask"];
            this.slider = _data["slider"];
            this.description = _data["description"];
            this.inputTextarea = _data["inputTextarea"];
            this.integerOnly = _data["integerOnly"];
            this.decimal = _data["decimal"];
            this.dateBasic = _data["dateBasic"] ? moment(_data["dateBasic"].toString()) : <any>undefined;
            this.dateTime = _data["dateTime"] ? moment(_data["dateTime"].toString()) : <any>undefined;
            this.dateDisable = _data["dateDisable"] ? moment(_data["dateDisable"].toString()) : <any>undefined;
            this.dateMinMax = _data["dateMinMax"] ? moment(_data["dateMinMax"].toString()) : <any>undefined;
            this.dateFrom = _data["dateFrom"] ? moment(_data["dateFrom"].toString()) : <any>undefined;
            this.dateTo = _data["dateTo"] ? moment(_data["dateTo"].toString()) : <any>undefined;
            this.dateMultiple = _data["dateMultiple"];
            this.dateMultipleMonth = _data["dateMultipleMonth"] ? moment(_data["dateMultipleMonth"].toString()) : <any>undefined;
            this.monthOnly = _data["monthOnly"] ? moment(_data["monthOnly"].toString()) : <any>undefined;
            this.timeOnly = _data["timeOnly"];
            this.autoCompleteSingle = _data["autoCompleteSingle"];
            this.autoCompleteMultiple = _data["autoCompleteMultiple"];
            this.dropdownSingle = _data["dropdownSingle"];
            this.dropdownMultiple = _data["dropdownMultiple"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DemoDto {
        data = typeof data === 'object' ? data : {};
        let result = new DemoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ma"] = this.ma;
        data["ten"] = this.ten;
        data["checkbox"] = this.checkbox;
        data["checkboxTrueFalse"] = this.checkboxTrueFalse;
        data["radioButton"] = this.radioButton;
        data["inputSwitch"] = this.inputSwitch;
        data["inputMask"] = this.inputMask;
        data["slider"] = this.slider;
        data["description"] = this.description;
        data["inputTextarea"] = this.inputTextarea;
        data["integerOnly"] = this.integerOnly;
        data["decimal"] = this.decimal;
        data["dateBasic"] = this.dateBasic ? this.dateBasic.toISOString() : <any>undefined;
        data["dateTime"] = this.dateTime ? this.dateTime.toISOString() : <any>undefined;
        data["dateDisable"] = this.dateDisable ? this.dateDisable.toISOString() : <any>undefined;
        data["dateMinMax"] = this.dateMinMax ? this.dateMinMax.toISOString() : <any>undefined;
        data["dateFrom"] = this.dateFrom ? this.dateFrom.toISOString() : <any>undefined;
        data["dateTo"] = this.dateTo ? this.dateTo.toISOString() : <any>undefined;
        data["dateMultiple"] = this.dateMultiple;
        data["dateMultipleMonth"] = this.dateMultipleMonth ? this.dateMultipleMonth.toISOString() : <any>undefined;
        data["monthOnly"] = this.monthOnly ? this.monthOnly.toISOString() : <any>undefined;
        data["timeOnly"] = this.timeOnly;
        data["autoCompleteSingle"] = this.autoCompleteSingle;
        data["autoCompleteMultiple"] = this.autoCompleteMultiple;
        data["dropdownSingle"] = this.dropdownSingle;
        data["dropdownMultiple"] = this.dropdownMultiple;
        data["id"] = this.id;
        return data; 
    }

    clone(): DemoDto {
        const json = this.toJSON();
        let result = new DemoDto();
        result.init(json);
        return result;
    }
}

export interface IDemoDto {
    ma: string | undefined;
    ten: string | undefined;
    checkbox: string | undefined;
    checkboxTrueFalse: boolean | undefined;
    radioButton: number | undefined;
    inputSwitch: boolean | undefined;
    inputMask: string | undefined;
    slider: number | undefined;
    description: string | undefined;
    inputTextarea: string | undefined;
    integerOnly: number | undefined;
    decimal: number | undefined;
    dateBasic: moment.Moment | undefined;
    dateTime: moment.Moment | undefined;
    dateDisable: moment.Moment | undefined;
    dateMinMax: moment.Moment | undefined;
    dateFrom: moment.Moment | undefined;
    dateTo: moment.Moment | undefined;
    dateMultiple: string | undefined;
    dateMultipleMonth: moment.Moment | undefined;
    monthOnly: moment.Moment | undefined;
    timeOnly: string | undefined;
    autoCompleteSingle: number | undefined;
    autoCompleteMultiple: string | undefined;
    dropdownSingle: number | undefined;
    dropdownMultiple: string | undefined;
    id: number;
}

export class DemoForView implements IDemoForView {
    demo: DemoDto;
    trangThai: string | undefined;
    trangThaiDuyet: string | undefined;

    constructor(data?: IDemoForView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.demo = _data["demo"] ? DemoDto.fromJS(_data["demo"]) : <any>undefined;
            this.trangThai = _data["trangThai"];
            this.trangThaiDuyet = _data["trangThaiDuyet"];
        }
    }

    static fromJS(data: any): DemoForView {
        data = typeof data === 'object' ? data : {};
        let result = new DemoForView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["demo"] = this.demo ? this.demo.toJSON() : <any>undefined;
        data["trangThai"] = this.trangThai;
        data["trangThaiDuyet"] = this.trangThaiDuyet;
        return data; 
    }

    clone(): DemoForView {
        const json = this.toJSON();
        let result = new DemoForView();
        result.init(json);
        return result;
    }
}

export interface IDemoForView {
    demo: DemoDto;
    trangThai: string | undefined;
    trangThaiDuyet: string | undefined;
}

export class DemoForViewPagedResultDto implements IDemoForViewPagedResultDto {
    totalCount: number;
    items: DemoForView[] | undefined;

    constructor(data?: IDemoForViewPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(DemoForView.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DemoForViewPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new DemoForViewPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): DemoForViewPagedResultDto {
        const json = this.toJSON();
        let result = new DemoForViewPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IDemoForViewPagedResultDto {
    totalCount: number;
    items: DemoForView[] | undefined;
}

export class Demo_File implements IDemo_File {
    tenantId: number | undefined;
    demoId: number | undefined;
    tenFile: string | undefined;
    linkFile: string | undefined;
    loaiFile: number | undefined;
    ghiChu: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IDemo_File) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.demoId = _data["demoId"];
            this.tenFile = _data["tenFile"];
            this.linkFile = _data["linkFile"];
            this.loaiFile = _data["loaiFile"];
            this.ghiChu = _data["ghiChu"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Demo_File {
        data = typeof data === 'object' ? data : {};
        let result = new Demo_File();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["demoId"] = this.demoId;
        data["tenFile"] = this.tenFile;
        data["linkFile"] = this.linkFile;
        data["loaiFile"] = this.loaiFile;
        data["ghiChu"] = this.ghiChu;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): Demo_File {
        const json = this.toJSON();
        let result = new Demo_File();
        result.init(json);
        return result;
    }
}

export interface IDemo_File {
    tenantId: number | undefined;
    demoId: number | undefined;
    tenFile: string | undefined;
    linkFile: string | undefined;
    loaiFile: number | undefined;
    ghiChu: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class DemoCreateInput implements IDemoCreateInput {
    ma: string | undefined;
    ten: string | undefined;
    checkbox: string | undefined;
    checkboxTrueFalse: boolean | undefined;
    radioButton: number | undefined;
    inputSwitch: boolean | undefined;
    inputMask: string | undefined;
    slider: number | undefined;
    description: string | undefined;
    inputTextarea: string | undefined;
    integerOnly: number | undefined;
    decimal: number | undefined;
    dateBasic: moment.Moment | undefined;
    dateTime: moment.Moment | undefined;
    dateDisable: moment.Moment | undefined;
    dateMinMax: moment.Moment | undefined;
    dateFrom: moment.Moment | undefined;
    dateTo: moment.Moment | undefined;
    dateMultiple: string | undefined;
    dateMultipleMonth: moment.Moment | undefined;
    monthOnly: moment.Moment | undefined;
    timeOnly: string | undefined;
    autoCompleteSingle: number | undefined;
    autoCompleteMultiple: string | undefined;
    dropdownSingle: number | undefined;
    dropdownMultiple: string | undefined;
    listDemoFile: Demo_File[] | undefined;
    id: number | undefined;

    constructor(data?: IDemoCreateInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ma = _data["ma"];
            this.ten = _data["ten"];
            this.checkbox = _data["checkbox"];
            this.checkboxTrueFalse = _data["checkboxTrueFalse"];
            this.radioButton = _data["radioButton"];
            this.inputSwitch = _data["inputSwitch"];
            this.inputMask = _data["inputMask"];
            this.slider = _data["slider"];
            this.description = _data["description"];
            this.inputTextarea = _data["inputTextarea"];
            this.integerOnly = _data["integerOnly"];
            this.decimal = _data["decimal"];
            this.dateBasic = _data["dateBasic"] ? moment(_data["dateBasic"].toString()) : <any>undefined;
            this.dateTime = _data["dateTime"] ? moment(_data["dateTime"].toString()) : <any>undefined;
            this.dateDisable = _data["dateDisable"] ? moment(_data["dateDisable"].toString()) : <any>undefined;
            this.dateMinMax = _data["dateMinMax"] ? moment(_data["dateMinMax"].toString()) : <any>undefined;
            this.dateFrom = _data["dateFrom"] ? moment(_data["dateFrom"].toString()) : <any>undefined;
            this.dateTo = _data["dateTo"] ? moment(_data["dateTo"].toString()) : <any>undefined;
            this.dateMultiple = _data["dateMultiple"];
            this.dateMultipleMonth = _data["dateMultipleMonth"] ? moment(_data["dateMultipleMonth"].toString()) : <any>undefined;
            this.monthOnly = _data["monthOnly"] ? moment(_data["monthOnly"].toString()) : <any>undefined;
            this.timeOnly = _data["timeOnly"];
            this.autoCompleteSingle = _data["autoCompleteSingle"];
            this.autoCompleteMultiple = _data["autoCompleteMultiple"];
            this.dropdownSingle = _data["dropdownSingle"];
            this.dropdownMultiple = _data["dropdownMultiple"];
            if (Array.isArray(_data["listDemoFile"])) {
                this.listDemoFile = [] as any;
                for (let item of _data["listDemoFile"])
                    this.listDemoFile.push(Demo_File.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DemoCreateInput {
        data = typeof data === 'object' ? data : {};
        let result = new DemoCreateInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ma"] = this.ma;
        data["ten"] = this.ten;
        data["checkbox"] = this.checkbox;
        data["checkboxTrueFalse"] = this.checkboxTrueFalse;
        data["radioButton"] = this.radioButton;
        data["inputSwitch"] = this.inputSwitch;
        data["inputMask"] = this.inputMask;
        data["slider"] = this.slider;
        data["description"] = this.description;
        data["inputTextarea"] = this.inputTextarea;
        data["integerOnly"] = this.integerOnly;
        data["decimal"] = this.decimal;
        data["dateBasic"] = this.dateBasic ? this.dateBasic.toISOString() : <any>undefined;
        data["dateTime"] = this.dateTime ? this.dateTime.toISOString() : <any>undefined;
        data["dateDisable"] = this.dateDisable ? this.dateDisable.toISOString() : <any>undefined;
        data["dateMinMax"] = this.dateMinMax ? this.dateMinMax.toISOString() : <any>undefined;
        data["dateFrom"] = this.dateFrom ? this.dateFrom.toISOString() : <any>undefined;
        data["dateTo"] = this.dateTo ? this.dateTo.toISOString() : <any>undefined;
        data["dateMultiple"] = this.dateMultiple;
        data["dateMultipleMonth"] = this.dateMultipleMonth ? this.dateMultipleMonth.toISOString() : <any>undefined;
        data["monthOnly"] = this.monthOnly ? this.monthOnly.toISOString() : <any>undefined;
        data["timeOnly"] = this.timeOnly;
        data["autoCompleteSingle"] = this.autoCompleteSingle;
        data["autoCompleteMultiple"] = this.autoCompleteMultiple;
        data["dropdownSingle"] = this.dropdownSingle;
        data["dropdownMultiple"] = this.dropdownMultiple;
        if (Array.isArray(this.listDemoFile)) {
            data["listDemoFile"] = [];
            for (let item of this.listDemoFile)
                data["listDemoFile"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data; 
    }

    clone(): DemoCreateInput {
        const json = this.toJSON();
        let result = new DemoCreateInput();
        result.init(json);
        return result;
    }
}

export interface IDemoCreateInput {
    ma: string | undefined;
    ten: string | undefined;
    checkbox: string | undefined;
    checkboxTrueFalse: boolean | undefined;
    radioButton: number | undefined;
    inputSwitch: boolean | undefined;
    inputMask: string | undefined;
    slider: number | undefined;
    description: string | undefined;
    inputTextarea: string | undefined;
    integerOnly: number | undefined;
    decimal: number | undefined;
    dateBasic: moment.Moment | undefined;
    dateTime: moment.Moment | undefined;
    dateDisable: moment.Moment | undefined;
    dateMinMax: moment.Moment | undefined;
    dateFrom: moment.Moment | undefined;
    dateTo: moment.Moment | undefined;
    dateMultiple: string | undefined;
    dateMultipleMonth: moment.Moment | undefined;
    monthOnly: moment.Moment | undefined;
    timeOnly: string | undefined;
    autoCompleteSingle: number | undefined;
    autoCompleteMultiple: string | undefined;
    dropdownSingle: number | undefined;
    dropdownMultiple: string | undefined;
    listDemoFile: Demo_File[] | undefined;
    id: number | undefined;
}

export class DemoGetAllInputDto implements IDemoGetAllInputDto {
    keyword: string | undefined;
    skipCount: number;
    maxResultCount: number;

    constructor(data?: IDemoGetAllInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.keyword = _data["keyword"];
            this.skipCount = _data["skipCount"];
            this.maxResultCount = _data["maxResultCount"];
        }
    }

    static fromJS(data: any): DemoGetAllInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new DemoGetAllInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["keyword"] = this.keyword;
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        return data; 
    }

    clone(): DemoGetAllInputDto {
        const json = this.toJSON();
        let result = new DemoGetAllInputDto();
        result.init(json);
        return result;
    }
}

export interface IDemoGetAllInputDto {
    keyword: string | undefined;
    skipCount: number;
    maxResultCount: number;
}

export class KiemKe_DoiKiemKe implements IKiemKe_DoiKiemKe {
    tenantId: number | undefined;
    kiemKeTaiSanId: number | undefined;
    nguoiKiemKeId: number | undefined;
    ghiChu: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IKiemKe_DoiKiemKe) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.kiemKeTaiSanId = _data["kiemKeTaiSanId"];
            this.nguoiKiemKeId = _data["nguoiKiemKeId"];
            this.ghiChu = _data["ghiChu"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): KiemKe_DoiKiemKe {
        data = typeof data === 'object' ? data : {};
        let result = new KiemKe_DoiKiemKe();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["kiemKeTaiSanId"] = this.kiemKeTaiSanId;
        data["nguoiKiemKeId"] = this.nguoiKiemKeId;
        data["ghiChu"] = this.ghiChu;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): KiemKe_DoiKiemKe {
        const json = this.toJSON();
        let result = new KiemKe_DoiKiemKe();
        result.init(json);
        return result;
    }
}

export interface IKiemKe_DoiKiemKe {
    tenantId: number | undefined;
    kiemKeTaiSanId: number | undefined;
    nguoiKiemKeId: number | undefined;
    ghiChu: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class KiemKeTaiSan implements IKiemKeTaiSan {
    tenantId: number | undefined;
    maKiemKe: string | undefined;
    tenKiemKe: string | undefined;
    thoiGianBatDauDuKien: moment.Moment | undefined;
    thoiGianBatDauThucTe: moment.Moment | undefined;
    thoiGianKetThucDuKien: moment.Moment | undefined;
    thoiGianKetThucThucTe: moment.Moment | undefined;
    boPhanDuocKiemKeId: number | undefined;
    trangThaiId: number | undefined;
    ghiChu: string | undefined;
    doiKiemKeList: KiemKe_DoiKiemKe[] | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IKiemKeTaiSan) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.maKiemKe = _data["maKiemKe"];
            this.tenKiemKe = _data["tenKiemKe"];
            this.thoiGianBatDauDuKien = _data["thoiGianBatDauDuKien"] ? moment(_data["thoiGianBatDauDuKien"].toString()) : <any>undefined;
            this.thoiGianBatDauThucTe = _data["thoiGianBatDauThucTe"] ? moment(_data["thoiGianBatDauThucTe"].toString()) : <any>undefined;
            this.thoiGianKetThucDuKien = _data["thoiGianKetThucDuKien"] ? moment(_data["thoiGianKetThucDuKien"].toString()) : <any>undefined;
            this.thoiGianKetThucThucTe = _data["thoiGianKetThucThucTe"] ? moment(_data["thoiGianKetThucThucTe"].toString()) : <any>undefined;
            this.boPhanDuocKiemKeId = _data["boPhanDuocKiemKeId"];
            this.trangThaiId = _data["trangThaiId"];
            this.ghiChu = _data["ghiChu"];
            if (Array.isArray(_data["doiKiemKeList"])) {
                this.doiKiemKeList = [] as any;
                for (let item of _data["doiKiemKeList"])
                    this.doiKiemKeList.push(KiemKe_DoiKiemKe.fromJS(item));
            }
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): KiemKeTaiSan {
        data = typeof data === 'object' ? data : {};
        let result = new KiemKeTaiSan();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["maKiemKe"] = this.maKiemKe;
        data["tenKiemKe"] = this.tenKiemKe;
        data["thoiGianBatDauDuKien"] = this.thoiGianBatDauDuKien ? this.thoiGianBatDauDuKien.toISOString() : <any>undefined;
        data["thoiGianBatDauThucTe"] = this.thoiGianBatDauThucTe ? this.thoiGianBatDauThucTe.toISOString() : <any>undefined;
        data["thoiGianKetThucDuKien"] = this.thoiGianKetThucDuKien ? this.thoiGianKetThucDuKien.toISOString() : <any>undefined;
        data["thoiGianKetThucThucTe"] = this.thoiGianKetThucThucTe ? this.thoiGianKetThucThucTe.toISOString() : <any>undefined;
        data["boPhanDuocKiemKeId"] = this.boPhanDuocKiemKeId;
        data["trangThaiId"] = this.trangThaiId;
        data["ghiChu"] = this.ghiChu;
        if (Array.isArray(this.doiKiemKeList)) {
            data["doiKiemKeList"] = [];
            for (let item of this.doiKiemKeList)
                data["doiKiemKeList"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): KiemKeTaiSan {
        const json = this.toJSON();
        let result = new KiemKeTaiSan();
        result.init(json);
        return result;
    }
}

export interface IKiemKeTaiSan {
    tenantId: number | undefined;
    maKiemKe: string | undefined;
    tenKiemKe: string | undefined;
    thoiGianBatDauDuKien: moment.Moment | undefined;
    thoiGianBatDauThucTe: moment.Moment | undefined;
    thoiGianKetThucDuKien: moment.Moment | undefined;
    thoiGianKetThucThucTe: moment.Moment | undefined;
    boPhanDuocKiemKeId: number | undefined;
    trangThaiId: number | undefined;
    ghiChu: string | undefined;
    doiKiemKeList: KiemKe_DoiKiemKe[] | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class KiemKeTaiSanForViewDto implements IKiemKeTaiSanForViewDto {
    kiemKeTaiSan: KiemKeTaiSan;
    phongBan: string | undefined;

    constructor(data?: IKiemKeTaiSanForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.kiemKeTaiSan = _data["kiemKeTaiSan"] ? KiemKeTaiSan.fromJS(_data["kiemKeTaiSan"]) : <any>undefined;
            this.phongBan = _data["phongBan"];
        }
    }

    static fromJS(data: any): KiemKeTaiSanForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new KiemKeTaiSanForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["kiemKeTaiSan"] = this.kiemKeTaiSan ? this.kiemKeTaiSan.toJSON() : <any>undefined;
        data["phongBan"] = this.phongBan;
        return data; 
    }

    clone(): KiemKeTaiSanForViewDto {
        const json = this.toJSON();
        let result = new KiemKeTaiSanForViewDto();
        result.init(json);
        return result;
    }
}

export interface IKiemKeTaiSanForViewDto {
    kiemKeTaiSan: KiemKeTaiSan;
    phongBan: string | undefined;
}

export class KiemKeTaiSanForViewDtoPagedResultDto implements IKiemKeTaiSanForViewDtoPagedResultDto {
    totalCount: number;
    items: KiemKeTaiSanForViewDto[] | undefined;

    constructor(data?: IKiemKeTaiSanForViewDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(KiemKeTaiSanForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): KiemKeTaiSanForViewDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new KiemKeTaiSanForViewDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): KiemKeTaiSanForViewDtoPagedResultDto {
        const json = this.toJSON();
        let result = new KiemKeTaiSanForViewDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IKiemKeTaiSanForViewDtoPagedResultDto {
    totalCount: number;
    items: KiemKeTaiSanForViewDto[] | undefined;
}

export class KetQuaKiemKeForViewDto implements IKetQuaKiemKeForViewDto {
    id: number;
    maTaiSan: string | undefined;
    tenTaiSan: string | undefined;
    taiSanId: number;
    loaiTaiSan: string | undefined;
    viTri: string | undefined;
    tinhTrang: string | undefined;
    trangThai: string | undefined;
    trangThaiId: number;
    tinhTrangId: number;

    constructor(data?: IKetQuaKiemKeForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.maTaiSan = _data["maTaiSan"];
            this.tenTaiSan = _data["tenTaiSan"];
            this.taiSanId = _data["taiSanId"];
            this.loaiTaiSan = _data["loaiTaiSan"];
            this.viTri = _data["viTri"];
            this.tinhTrang = _data["tinhTrang"];
            this.trangThai = _data["trangThai"];
            this.trangThaiId = _data["trangThaiId"];
            this.tinhTrangId = _data["tinhTrangId"];
        }
    }

    static fromJS(data: any): KetQuaKiemKeForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new KetQuaKiemKeForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["maTaiSan"] = this.maTaiSan;
        data["tenTaiSan"] = this.tenTaiSan;
        data["taiSanId"] = this.taiSanId;
        data["loaiTaiSan"] = this.loaiTaiSan;
        data["viTri"] = this.viTri;
        data["tinhTrang"] = this.tinhTrang;
        data["trangThai"] = this.trangThai;
        data["trangThaiId"] = this.trangThaiId;
        data["tinhTrangId"] = this.tinhTrangId;
        return data; 
    }

    clone(): KetQuaKiemKeForViewDto {
        const json = this.toJSON();
        let result = new KetQuaKiemKeForViewDto();
        result.init(json);
        return result;
    }
}

export interface IKetQuaKiemKeForViewDto {
    id: number;
    maTaiSan: string | undefined;
    tenTaiSan: string | undefined;
    taiSanId: number;
    loaiTaiSan: string | undefined;
    viTri: string | undefined;
    tinhTrang: string | undefined;
    trangThai: string | undefined;
    trangThaiId: number;
    tinhTrangId: number;
}

export class KetQuaKiemKeForUpdateDto implements IKetQuaKiemKeForUpdateDto {
    id: number;
    tinhTrang: number;

    constructor(data?: IKetQuaKiemKeForUpdateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tinhTrang = _data["tinhTrang"];
        }
    }

    static fromJS(data: any): KetQuaKiemKeForUpdateDto {
        data = typeof data === 'object' ? data : {};
        let result = new KetQuaKiemKeForUpdateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tinhTrang"] = this.tinhTrang;
        return data; 
    }

    clone(): KetQuaKiemKeForUpdateDto {
        const json = this.toJSON();
        let result = new KetQuaKiemKeForUpdateDto();
        result.init(json);
        return result;
    }
}

export interface IKetQuaKiemKeForUpdateDto {
    id: number;
    tinhTrang: number;
}

export class TrangThaiKiemKeForUpdateDto implements ITrangThaiKiemKeForUpdateDto {
    id: number;
    trangThai: boolean;

    constructor(data?: ITrangThaiKiemKeForUpdateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.trangThai = _data["trangThai"];
        }
    }

    static fromJS(data: any): TrangThaiKiemKeForUpdateDto {
        data = typeof data === 'object' ? data : {};
        let result = new TrangThaiKiemKeForUpdateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["trangThai"] = this.trangThai;
        return data; 
    }

    clone(): TrangThaiKiemKeForUpdateDto {
        const json = this.toJSON();
        let result = new TrangThaiKiemKeForUpdateDto();
        result.init(json);
        return result;
    }
}

export interface ITrangThaiKiemKeForUpdateDto {
    id: number;
    trangThai: boolean;
}

export class KiemKeTaiSanCreateInputDto implements IKiemKeTaiSanCreateInputDto {
    maKiemKe: string | undefined;
    tenKiemKe: string | undefined;
    thoiGianBatDauDuKien: moment.Moment | undefined;
    thoiGianBatDauThucTe: moment.Moment | undefined;
    thoiGianKetThucDuKien: moment.Moment | undefined;
    thoiGianKetThucThucTe: moment.Moment | undefined;
    boPhanDuocKiemKeId: number | undefined;
    trangThaiId: number | undefined;
    doiKiemKeIdList: number[] | undefined;
    id: number;

    constructor(data?: IKiemKeTaiSanCreateInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.maKiemKe = _data["maKiemKe"];
            this.tenKiemKe = _data["tenKiemKe"];
            this.thoiGianBatDauDuKien = _data["thoiGianBatDauDuKien"] ? moment(_data["thoiGianBatDauDuKien"].toString()) : <any>undefined;
            this.thoiGianBatDauThucTe = _data["thoiGianBatDauThucTe"] ? moment(_data["thoiGianBatDauThucTe"].toString()) : <any>undefined;
            this.thoiGianKetThucDuKien = _data["thoiGianKetThucDuKien"] ? moment(_data["thoiGianKetThucDuKien"].toString()) : <any>undefined;
            this.thoiGianKetThucThucTe = _data["thoiGianKetThucThucTe"] ? moment(_data["thoiGianKetThucThucTe"].toString()) : <any>undefined;
            this.boPhanDuocKiemKeId = _data["boPhanDuocKiemKeId"];
            this.trangThaiId = _data["trangThaiId"];
            if (Array.isArray(_data["doiKiemKeIdList"])) {
                this.doiKiemKeIdList = [] as any;
                for (let item of _data["doiKiemKeIdList"])
                    this.doiKiemKeIdList.push(item);
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): KiemKeTaiSanCreateInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new KiemKeTaiSanCreateInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maKiemKe"] = this.maKiemKe;
        data["tenKiemKe"] = this.tenKiemKe;
        data["thoiGianBatDauDuKien"] = this.thoiGianBatDauDuKien ? this.thoiGianBatDauDuKien.toISOString() : <any>undefined;
        data["thoiGianBatDauThucTe"] = this.thoiGianBatDauThucTe ? this.thoiGianBatDauThucTe.toISOString() : <any>undefined;
        data["thoiGianKetThucDuKien"] = this.thoiGianKetThucDuKien ? this.thoiGianKetThucDuKien.toISOString() : <any>undefined;
        data["thoiGianKetThucThucTe"] = this.thoiGianKetThucThucTe ? this.thoiGianKetThucThucTe.toISOString() : <any>undefined;
        data["boPhanDuocKiemKeId"] = this.boPhanDuocKiemKeId;
        data["trangThaiId"] = this.trangThaiId;
        if (Array.isArray(this.doiKiemKeIdList)) {
            data["doiKiemKeIdList"] = [];
            for (let item of this.doiKiemKeIdList)
                data["doiKiemKeIdList"].push(item);
        }
        data["id"] = this.id;
        return data; 
    }

    clone(): KiemKeTaiSanCreateInputDto {
        const json = this.toJSON();
        let result = new KiemKeTaiSanCreateInputDto();
        result.init(json);
        return result;
    }
}

export interface IKiemKeTaiSanCreateInputDto {
    maKiemKe: string | undefined;
    tenKiemKe: string | undefined;
    thoiGianBatDauDuKien: moment.Moment | undefined;
    thoiGianBatDauThucTe: moment.Moment | undefined;
    thoiGianKetThucDuKien: moment.Moment | undefined;
    thoiGianKetThucThucTe: moment.Moment | undefined;
    boPhanDuocKiemKeId: number | undefined;
    trangThaiId: number | undefined;
    doiKiemKeIdList: number[] | undefined;
    id: number;
}

export class KetQuaKiemKeCreateDto implements IKetQuaKiemKeCreateDto {
    kiemKeTaiSanId: number;
    dauDocId: number;
    code: string[] | undefined;
    id: number;

    constructor(data?: IKetQuaKiemKeCreateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.kiemKeTaiSanId = _data["kiemKeTaiSanId"];
            this.dauDocId = _data["dauDocId"];
            if (Array.isArray(_data["code"])) {
                this.code = [] as any;
                for (let item of _data["code"])
                    this.code.push(item);
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): KetQuaKiemKeCreateDto {
        data = typeof data === 'object' ? data : {};
        let result = new KetQuaKiemKeCreateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["kiemKeTaiSanId"] = this.kiemKeTaiSanId;
        data["dauDocId"] = this.dauDocId;
        if (Array.isArray(this.code)) {
            data["code"] = [];
            for (let item of this.code)
                data["code"].push(item);
        }
        data["id"] = this.id;
        return data; 
    }

    clone(): KetQuaKiemKeCreateDto {
        const json = this.toJSON();
        let result = new KetQuaKiemKeCreateDto();
        result.init(json);
        return result;
    }
}

export interface IKetQuaKiemKeCreateDto {
    kiemKeTaiSanId: number;
    dauDocId: number;
    code: string[] | undefined;
    id: number;
}

export class UserDto implements IUserDto {
    userName: string;
    name: string;
    surname: string;
    emailAddress: string;
    isActive: boolean;
    fullName: string | undefined;
    lastLoginTime: moment.Moment | undefined;
    creationTime: moment.Moment;
    roleNames: string[] | undefined;
    toChucId: number | undefined;
    chucVu: string | undefined;
    phoneNumber: string | undefined;
    ghiChu: string | undefined;
    id: number;

    constructor(data?: IUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.emailAddress = _data["emailAddress"];
            this.isActive = _data["isActive"];
            this.fullName = _data["fullName"];
            this.lastLoginTime = _data["lastLoginTime"] ? moment(_data["lastLoginTime"].toString()) : <any>undefined;
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            if (Array.isArray(_data["roleNames"])) {
                this.roleNames = [] as any;
                for (let item of _data["roleNames"])
                    this.roleNames.push(item);
            }
            this.toChucId = _data["toChucId"];
            this.chucVu = _data["chucVu"];
            this.phoneNumber = _data["phoneNumber"];
            this.ghiChu = _data["ghiChu"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["emailAddress"] = this.emailAddress;
        data["isActive"] = this.isActive;
        data["fullName"] = this.fullName;
        data["lastLoginTime"] = this.lastLoginTime ? this.lastLoginTime.toISOString() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        if (Array.isArray(this.roleNames)) {
            data["roleNames"] = [];
            for (let item of this.roleNames)
                data["roleNames"].push(item);
        }
        data["toChucId"] = this.toChucId;
        data["chucVu"] = this.chucVu;
        data["phoneNumber"] = this.phoneNumber;
        data["ghiChu"] = this.ghiChu;
        data["id"] = this.id;
        return data; 
    }

    clone(): UserDto {
        const json = this.toJSON();
        let result = new UserDto();
        result.init(json);
        return result;
    }
}

export interface IUserDto {
    userName: string;
    name: string;
    surname: string;
    emailAddress: string;
    isActive: boolean;
    fullName: string | undefined;
    lastLoginTime: moment.Moment | undefined;
    creationTime: moment.Moment;
    roleNames: string[] | undefined;
    toChucId: number | undefined;
    chucVu: string | undefined;
    phoneNumber: string | undefined;
    ghiChu: string | undefined;
    id: number;
}

export class UserForViewDto implements IUserForViewDto {
    user: UserDto;
    tenToChuc: string | undefined;

    constructor(data?: IUserForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.user = _data["user"] ? UserDto.fromJS(_data["user"]) : <any>undefined;
            this.tenToChuc = _data["tenToChuc"];
        }
    }

    static fromJS(data: any): UserForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["tenToChuc"] = this.tenToChuc;
        return data; 
    }

    clone(): UserForViewDto {
        const json = this.toJSON();
        let result = new UserForViewDto();
        result.init(json);
        return result;
    }
}

export interface IUserForViewDto {
    user: UserDto;
    tenToChuc: string | undefined;
}

export class ViewKhaiBaoHongMat implements IViewKhaiBaoHongMat {
    phongBanKhaiBao: string | undefined;
    phongBanKhaiBaoId: number | undefined;
    nguoiKhaiBao: string | undefined;
    nguoiKhaiBaoId: number | undefined;
    ngayKhaiBao: moment.Moment | undefined;
    noiDungKhaiBao: string | undefined;
    khaiBao: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IViewKhaiBaoHongMat) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.phongBanKhaiBao = _data["phongBanKhaiBao"];
            this.phongBanKhaiBaoId = _data["phongBanKhaiBaoId"];
            this.nguoiKhaiBao = _data["nguoiKhaiBao"];
            this.nguoiKhaiBaoId = _data["nguoiKhaiBaoId"];
            this.ngayKhaiBao = _data["ngayKhaiBao"] ? moment(_data["ngayKhaiBao"].toString()) : <any>undefined;
            this.noiDungKhaiBao = _data["noiDungKhaiBao"];
            this.khaiBao = _data["khaiBao"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ViewKhaiBaoHongMat {
        data = typeof data === 'object' ? data : {};
        let result = new ViewKhaiBaoHongMat();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["phongBanKhaiBao"] = this.phongBanKhaiBao;
        data["phongBanKhaiBaoId"] = this.phongBanKhaiBaoId;
        data["nguoiKhaiBao"] = this.nguoiKhaiBao;
        data["nguoiKhaiBaoId"] = this.nguoiKhaiBaoId;
        data["ngayKhaiBao"] = this.ngayKhaiBao ? this.ngayKhaiBao.toISOString() : <any>undefined;
        data["noiDungKhaiBao"] = this.noiDungKhaiBao;
        data["khaiBao"] = this.khaiBao;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): ViewKhaiBaoHongMat {
        const json = this.toJSON();
        let result = new ViewKhaiBaoHongMat();
        result.init(json);
        return result;
    }
}

export interface IViewKhaiBaoHongMat {
    phongBanKhaiBao: string | undefined;
    phongBanKhaiBaoId: number | undefined;
    nguoiKhaiBao: string | undefined;
    nguoiKhaiBaoId: number | undefined;
    ngayKhaiBao: moment.Moment | undefined;
    noiDungKhaiBao: string | undefined;
    khaiBao: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class ViewKhaiBaoHongMatPagedResultDto implements IViewKhaiBaoHongMatPagedResultDto {
    totalCount: number;
    items: ViewKhaiBaoHongMat[] | undefined;

    constructor(data?: IViewKhaiBaoHongMatPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(ViewKhaiBaoHongMat.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ViewKhaiBaoHongMatPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ViewKhaiBaoHongMatPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ViewKhaiBaoHongMatPagedResultDto {
        const json = this.toJSON();
        let result = new ViewKhaiBaoHongMatPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IViewKhaiBaoHongMatPagedResultDto {
    totalCount: number;
    items: ViewKhaiBaoHongMat[] | undefined;
}

export class ViewKhaiBaoHongMatChiTiet implements IViewKhaiBaoHongMatChiTiet {
    phongBanKhaiBao: string | undefined;
    phongBanKhaiBaoId: number | undefined;
    nguoiKhaiBao: string | undefined;
    nguoiKhaiBaoId: number | undefined;
    ngayKhaiBao: moment.Moment | undefined;
    noiDungKhaiBao: string | undefined;
    khaiBao: number | undefined;
    phieuTaiSanId: number | undefined;
    taiSanId: number | undefined;
    trangThaiId: number | undefined;
    viTriLapDat: number | undefined;
    ghiChu: string | undefined;
    tenTaiSan: string | undefined;
    loaiTaiSanId: number | undefined;
    loaiTaiSan: string | undefined;
    serialNumber: string | undefined;
    nhaCungCapId: number | undefined;
    nhaCungCap: string | undefined;
    ngayMua: moment.Moment | undefined;
    nguyenGia: number | undefined;
    phongBanQuanLyId: number | undefined;
    phongBanQuanLy: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IViewKhaiBaoHongMatChiTiet) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.phongBanKhaiBao = _data["phongBanKhaiBao"];
            this.phongBanKhaiBaoId = _data["phongBanKhaiBaoId"];
            this.nguoiKhaiBao = _data["nguoiKhaiBao"];
            this.nguoiKhaiBaoId = _data["nguoiKhaiBaoId"];
            this.ngayKhaiBao = _data["ngayKhaiBao"] ? moment(_data["ngayKhaiBao"].toString()) : <any>undefined;
            this.noiDungKhaiBao = _data["noiDungKhaiBao"];
            this.khaiBao = _data["khaiBao"];
            this.phieuTaiSanId = _data["phieuTaiSanId"];
            this.taiSanId = _data["taiSanId"];
            this.trangThaiId = _data["trangThaiId"];
            this.viTriLapDat = _data["viTriLapDat"];
            this.ghiChu = _data["ghiChu"];
            this.tenTaiSan = _data["tenTaiSan"];
            this.loaiTaiSanId = _data["loaiTaiSanId"];
            this.loaiTaiSan = _data["loaiTaiSan"];
            this.serialNumber = _data["serialNumber"];
            this.nhaCungCapId = _data["nhaCungCapId"];
            this.nhaCungCap = _data["nhaCungCap"];
            this.ngayMua = _data["ngayMua"] ? moment(_data["ngayMua"].toString()) : <any>undefined;
            this.nguyenGia = _data["nguyenGia"];
            this.phongBanQuanLyId = _data["phongBanQuanLyId"];
            this.phongBanQuanLy = _data["phongBanQuanLy"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ViewKhaiBaoHongMatChiTiet {
        data = typeof data === 'object' ? data : {};
        let result = new ViewKhaiBaoHongMatChiTiet();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["phongBanKhaiBao"] = this.phongBanKhaiBao;
        data["phongBanKhaiBaoId"] = this.phongBanKhaiBaoId;
        data["nguoiKhaiBao"] = this.nguoiKhaiBao;
        data["nguoiKhaiBaoId"] = this.nguoiKhaiBaoId;
        data["ngayKhaiBao"] = this.ngayKhaiBao ? this.ngayKhaiBao.toISOString() : <any>undefined;
        data["noiDungKhaiBao"] = this.noiDungKhaiBao;
        data["khaiBao"] = this.khaiBao;
        data["phieuTaiSanId"] = this.phieuTaiSanId;
        data["taiSanId"] = this.taiSanId;
        data["trangThaiId"] = this.trangThaiId;
        data["viTriLapDat"] = this.viTriLapDat;
        data["ghiChu"] = this.ghiChu;
        data["tenTaiSan"] = this.tenTaiSan;
        data["loaiTaiSanId"] = this.loaiTaiSanId;
        data["loaiTaiSan"] = this.loaiTaiSan;
        data["serialNumber"] = this.serialNumber;
        data["nhaCungCapId"] = this.nhaCungCapId;
        data["nhaCungCap"] = this.nhaCungCap;
        data["ngayMua"] = this.ngayMua ? this.ngayMua.toISOString() : <any>undefined;
        data["nguyenGia"] = this.nguyenGia;
        data["phongBanQuanLyId"] = this.phongBanQuanLyId;
        data["phongBanQuanLy"] = this.phongBanQuanLy;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): ViewKhaiBaoHongMatChiTiet {
        const json = this.toJSON();
        let result = new ViewKhaiBaoHongMatChiTiet();
        result.init(json);
        return result;
    }
}

export interface IViewKhaiBaoHongMatChiTiet {
    phongBanKhaiBao: string | undefined;
    phongBanKhaiBaoId: number | undefined;
    nguoiKhaiBao: string | undefined;
    nguoiKhaiBaoId: number | undefined;
    ngayKhaiBao: moment.Moment | undefined;
    noiDungKhaiBao: string | undefined;
    khaiBao: number | undefined;
    phieuTaiSanId: number | undefined;
    taiSanId: number | undefined;
    trangThaiId: number | undefined;
    viTriLapDat: number | undefined;
    ghiChu: string | undefined;
    tenTaiSan: string | undefined;
    loaiTaiSanId: number | undefined;
    loaiTaiSan: string | undefined;
    serialNumber: string | undefined;
    nhaCungCapId: number | undefined;
    nhaCungCap: string | undefined;
    ngayMua: moment.Moment | undefined;
    nguyenGia: number | undefined;
    phongBanQuanLyId: number | undefined;
    phongBanQuanLy: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class ViewKhaiBaoHongMatChiTietPagedResultDto implements IViewKhaiBaoHongMatChiTietPagedResultDto {
    totalCount: number;
    items: ViewKhaiBaoHongMatChiTiet[] | undefined;

    constructor(data?: IViewKhaiBaoHongMatChiTietPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(ViewKhaiBaoHongMatChiTiet.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ViewKhaiBaoHongMatChiTietPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ViewKhaiBaoHongMatChiTietPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ViewKhaiBaoHongMatChiTietPagedResultDto {
        const json = this.toJSON();
        let result = new ViewKhaiBaoHongMatChiTietPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IViewKhaiBaoHongMatChiTietPagedResultDto {
    totalCount: number;
    items: ViewKhaiBaoHongMatChiTiet[] | undefined;
}

export class LichSuRaVaoForViewDto implements ILichSuRaVaoForViewDto {
    id: number;
    maRFID: string | undefined;
    tenTaiSan: string | undefined;
    taiSanId: number;
    donViSuDung: string | undefined;
    toChucId: number;
    phongBanSuDungId: number;
    loaiTaiSan: string | undefined;
    loaiTaiSanId: number;
    chieuDiChuyenId: number;
    chieuDiChuyen: string | undefined;
    ngayDiChuyen: moment.Moment;
    phanLoai: string | undefined;

    constructor(data?: ILichSuRaVaoForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.maRFID = _data["maRFID"];
            this.tenTaiSan = _data["tenTaiSan"];
            this.taiSanId = _data["taiSanId"];
            this.donViSuDung = _data["donViSuDung"];
            this.toChucId = _data["toChucId"];
            this.phongBanSuDungId = _data["phongBanSuDungId"];
            this.loaiTaiSan = _data["loaiTaiSan"];
            this.loaiTaiSanId = _data["loaiTaiSanId"];
            this.chieuDiChuyenId = _data["chieuDiChuyenId"];
            this.chieuDiChuyen = _data["chieuDiChuyen"];
            this.ngayDiChuyen = _data["ngayDiChuyen"] ? moment(_data["ngayDiChuyen"].toString()) : <any>undefined;
            this.phanLoai = _data["phanLoai"];
        }
    }

    static fromJS(data: any): LichSuRaVaoForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new LichSuRaVaoForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["maRFID"] = this.maRFID;
        data["tenTaiSan"] = this.tenTaiSan;
        data["taiSanId"] = this.taiSanId;
        data["donViSuDung"] = this.donViSuDung;
        data["toChucId"] = this.toChucId;
        data["phongBanSuDungId"] = this.phongBanSuDungId;
        data["loaiTaiSan"] = this.loaiTaiSan;
        data["loaiTaiSanId"] = this.loaiTaiSanId;
        data["chieuDiChuyenId"] = this.chieuDiChuyenId;
        data["chieuDiChuyen"] = this.chieuDiChuyen;
        data["ngayDiChuyen"] = this.ngayDiChuyen ? this.ngayDiChuyen.toISOString() : <any>undefined;
        data["phanLoai"] = this.phanLoai;
        return data; 
    }

    clone(): LichSuRaVaoForViewDto {
        const json = this.toJSON();
        let result = new LichSuRaVaoForViewDto();
        result.init(json);
        return result;
    }
}

export interface ILichSuRaVaoForViewDto {
    id: number;
    maRFID: string | undefined;
    tenTaiSan: string | undefined;
    taiSanId: number;
    donViSuDung: string | undefined;
    toChucId: number;
    phongBanSuDungId: number;
    loaiTaiSan: string | undefined;
    loaiTaiSanId: number;
    chieuDiChuyenId: number;
    chieuDiChuyen: string | undefined;
    ngayDiChuyen: moment.Moment;
    phanLoai: string | undefined;
}

export class LichSuRaVaoForViewDtoPagedResultDto implements ILichSuRaVaoForViewDtoPagedResultDto {
    totalCount: number;
    items: LichSuRaVaoForViewDto[] | undefined;

    constructor(data?: ILichSuRaVaoForViewDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(LichSuRaVaoForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LichSuRaVaoForViewDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new LichSuRaVaoForViewDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): LichSuRaVaoForViewDtoPagedResultDto {
        const json = this.toJSON();
        let result = new LichSuRaVaoForViewDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface ILichSuRaVaoForViewDtoPagedResultDto {
    totalCount: number;
    items: LichSuRaVaoForViewDto[] | undefined;
}

export class InputLichSuRaVaoDto implements IInputLichSuRaVaoDto {
    keyword: string | undefined;
    startDate: moment.Moment | undefined;
    endDate: moment.Moment | undefined;
    chieuDiChuyen: string | undefined;
    boPhanId: number[] | undefined;
    phanLoaiId: number | undefined;
    isSearch: boolean | undefined;
    sorting: string | undefined;
    skipCount: number;
    maxResultCount: number;

    constructor(data?: IInputLichSuRaVaoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.keyword = _data["keyword"];
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.chieuDiChuyen = _data["chieuDiChuyen"];
            if (Array.isArray(_data["boPhanId"])) {
                this.boPhanId = [] as any;
                for (let item of _data["boPhanId"])
                    this.boPhanId.push(item);
            }
            this.phanLoaiId = _data["phanLoaiId"];
            this.isSearch = _data["isSearch"];
            this.sorting = _data["sorting"];
            this.skipCount = _data["skipCount"];
            this.maxResultCount = _data["maxResultCount"];
        }
    }

    static fromJS(data: any): InputLichSuRaVaoDto {
        data = typeof data === 'object' ? data : {};
        let result = new InputLichSuRaVaoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["keyword"] = this.keyword;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["chieuDiChuyen"] = this.chieuDiChuyen;
        if (Array.isArray(this.boPhanId)) {
            data["boPhanId"] = [];
            for (let item of this.boPhanId)
                data["boPhanId"].push(item);
        }
        data["phanLoaiId"] = this.phanLoaiId;
        data["isSearch"] = this.isSearch;
        data["sorting"] = this.sorting;
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        return data; 
    }

    clone(): InputLichSuRaVaoDto {
        const json = this.toJSON();
        let result = new InputLichSuRaVaoDto();
        result.init(json);
        return result;
    }
}

export interface IInputLichSuRaVaoDto {
    keyword: string | undefined;
    startDate: moment.Moment | undefined;
    endDate: moment.Moment | undefined;
    chieuDiChuyen: string | undefined;
    boPhanId: number[] | undefined;
    phanLoaiId: number | undefined;
    isSearch: boolean | undefined;
    sorting: string | undefined;
    skipCount: number;
    maxResultCount: number;
}

export class UpdateInputDto implements IUpdateInputDto {
    taiSanId: number | undefined;
    rfid: string | undefined;

    constructor(data?: IUpdateInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.taiSanId = _data["taiSanId"];
            this.rfid = _data["rfid"];
        }
    }

    static fromJS(data: any): UpdateInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["taiSanId"] = this.taiSanId;
        data["rfid"] = this.rfid;
        return data; 
    }

    clone(): UpdateInputDto {
        const json = this.toJSON();
        let result = new UpdateInputDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateInputDto {
    taiSanId: number | undefined;
    rfid: string | undefined;
}

export class LoaiTaiSan implements ILoaiTaiSan {
    tenantId: number | undefined;
    taiSanChaId: number | undefined;
    ma: string | undefined;
    ten: string | undefined;
    ghiChu: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: ILoaiTaiSan) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.taiSanChaId = _data["taiSanChaId"];
            this.ma = _data["ma"];
            this.ten = _data["ten"];
            this.ghiChu = _data["ghiChu"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): LoaiTaiSan {
        data = typeof data === 'object' ? data : {};
        let result = new LoaiTaiSan();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["taiSanChaId"] = this.taiSanChaId;
        data["ma"] = this.ma;
        data["ten"] = this.ten;
        data["ghiChu"] = this.ghiChu;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): LoaiTaiSan {
        const json = this.toJSON();
        let result = new LoaiTaiSan();
        result.init(json);
        return result;
    }
}

export interface ILoaiTaiSan {
    tenantId: number | undefined;
    taiSanChaId: number | undefined;
    ma: string | undefined;
    ten: string | undefined;
    ghiChu: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class LoaiTaiSanForViewDto implements ILoaiTaiSanForViewDto {
    loaiTaiSan: LoaiTaiSan;
    maHexa: string | undefined;

    constructor(data?: ILoaiTaiSanForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.loaiTaiSan = _data["loaiTaiSan"] ? LoaiTaiSan.fromJS(_data["loaiTaiSan"]) : <any>undefined;
            this.maHexa = _data["maHexa"];
        }
    }

    static fromJS(data: any): LoaiTaiSanForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new LoaiTaiSanForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["loaiTaiSan"] = this.loaiTaiSan ? this.loaiTaiSan.toJSON() : <any>undefined;
        data["maHexa"] = this.maHexa;
        return data; 
    }

    clone(): LoaiTaiSanForViewDto {
        const json = this.toJSON();
        let result = new LoaiTaiSanForViewDto();
        result.init(json);
        return result;
    }
}

export interface ILoaiTaiSanForViewDto {
    loaiTaiSan: LoaiTaiSan;
    maHexa: string | undefined;
}

export class LoaiTaiSanTreeTableForViewDto implements ILoaiTaiSanTreeTableForViewDto {
    data: LoaiTaiSanForViewDto;
    children: LoaiTaiSanTreeTableForViewDto[] | undefined;
    expanded: boolean;

    constructor(data?: ILoaiTaiSanTreeTableForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? LoaiTaiSanForViewDto.fromJS(_data["data"]) : <any>undefined;
            if (Array.isArray(_data["children"])) {
                this.children = [] as any;
                for (let item of _data["children"])
                    this.children.push(LoaiTaiSanTreeTableForViewDto.fromJS(item));
            }
            this.expanded = _data["expanded"];
        }
    }

    static fromJS(data: any): LoaiTaiSanTreeTableForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new LoaiTaiSanTreeTableForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        if (Array.isArray(this.children)) {
            data["children"] = [];
            for (let item of this.children)
                data["children"].push(item.toJSON());
        }
        data["expanded"] = this.expanded;
        return data; 
    }

    clone(): LoaiTaiSanTreeTableForViewDto {
        const json = this.toJSON();
        let result = new LoaiTaiSanTreeTableForViewDto();
        result.init(json);
        return result;
    }
}

export interface ILoaiTaiSanTreeTableForViewDto {
    data: LoaiTaiSanForViewDto;
    children: LoaiTaiSanTreeTableForViewDto[] | undefined;
    expanded: boolean;
}

export class LoaiTaiSanCreateInputDto implements ILoaiTaiSanCreateInputDto {
    taiSanChaId: number | undefined;
    ma: string | undefined;
    ten: string | undefined;
    ghiChu: string | undefined;
    id: number | undefined;

    constructor(data?: ILoaiTaiSanCreateInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.taiSanChaId = _data["taiSanChaId"];
            this.ma = _data["ma"];
            this.ten = _data["ten"];
            this.ghiChu = _data["ghiChu"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): LoaiTaiSanCreateInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new LoaiTaiSanCreateInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["taiSanChaId"] = this.taiSanChaId;
        data["ma"] = this.ma;
        data["ten"] = this.ten;
        data["ghiChu"] = this.ghiChu;
        data["id"] = this.id;
        return data; 
    }

    clone(): LoaiTaiSanCreateInputDto {
        const json = this.toJSON();
        let result = new LoaiTaiSanCreateInputDto();
        result.init(json);
        return result;
    }
}

export interface ILoaiTaiSanCreateInputDto {
    taiSanChaId: number | undefined;
    ma: string | undefined;
    ten: string | undefined;
    ghiChu: string | undefined;
    id: number | undefined;
}

export class LoaiTaiSanGetAllInputDto implements ILoaiTaiSanGetAllInputDto {
    keyword: string | undefined;
    isSearch: boolean | undefined;

    constructor(data?: ILoaiTaiSanGetAllInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.keyword = _data["keyword"];
            this.isSearch = _data["isSearch"];
        }
    }

    static fromJS(data: any): LoaiTaiSanGetAllInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new LoaiTaiSanGetAllInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["keyword"] = this.keyword;
        data["isSearch"] = this.isSearch;
        return data; 
    }

    clone(): LoaiTaiSanGetAllInputDto {
        const json = this.toJSON();
        let result = new LoaiTaiSanGetAllInputDto();
        result.init(json);
        return result;
    }
}

export interface ILoaiTaiSanGetAllInputDto {
    keyword: string | undefined;
    isSearch: boolean | undefined;
}

export class Int64LookupTableDto implements IInt64LookupTableDto {
    id: number;
    displayName: string | undefined;

    constructor(data?: IInt64LookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): Int64LookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new Int64LookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }

    clone(): Int64LookupTableDto {
        const json = this.toJSON();
        let result = new Int64LookupTableDto();
        result.init(json);
        return result;
    }
}

export interface IInt64LookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class TreeviewItemDto implements ITreeviewItemDto {
    text: string | undefined;
    value: number | undefined;
    collapsed: boolean | undefined;
    checked: boolean | undefined;
    disabled: boolean | undefined;
    children: TreeviewItemDto[] | undefined;

    constructor(data?: ITreeviewItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.text = _data["text"];
            this.value = _data["value"];
            this.collapsed = _data["collapsed"];
            this.checked = _data["checked"];
            this.disabled = _data["disabled"];
            if (Array.isArray(_data["children"])) {
                this.children = [] as any;
                for (let item of _data["children"])
                    this.children.push(TreeviewItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TreeviewItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new TreeviewItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["text"] = this.text;
        data["value"] = this.value;
        data["collapsed"] = this.collapsed;
        data["checked"] = this.checked;
        data["disabled"] = this.disabled;
        if (Array.isArray(this.children)) {
            data["children"] = [];
            for (let item of this.children)
                data["children"].push(item.toJSON());
        }
        return data; 
    }

    clone(): TreeviewItemDto {
        const json = this.toJSON();
        let result = new TreeviewItemDto();
        result.init(json);
        return result;
    }
}

export interface ITreeviewItemDto {
    text: string | undefined;
    value: number | undefined;
    collapsed: boolean | undefined;
    checked: boolean | undefined;
    disabled: boolean | undefined;
    children: TreeviewItemDto[] | undefined;
}

export class ChangePasswordDto implements IChangePasswordDto {
    currentPassword: string;
    newPassword: string;

    constructor(data?: IChangePasswordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currentPassword = _data["currentPassword"];
            this.newPassword = _data["newPassword"];
        }
    }

    static fromJS(data: any): ChangePasswordDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChangePasswordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentPassword"] = this.currentPassword;
        data["newPassword"] = this.newPassword;
        return data; 
    }

    clone(): ChangePasswordDto {
        const json = this.toJSON();
        let result = new ChangePasswordDto();
        result.init(json);
        return result;
    }
}

export interface IChangePasswordDto {
    currentPassword: string;
    newPassword: string;
}

export class GetEPCCodeDto implements IGetEPCCodeDto {
    taiSanId: number;
    epcCode: string | undefined;
    tenTaiSan: string | undefined;
    trangThaiId: number;

    constructor(data?: IGetEPCCodeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.taiSanId = _data["taiSanId"];
            this.epcCode = _data["epcCode"];
            this.tenTaiSan = _data["tenTaiSan"];
            this.trangThaiId = _data["trangThaiId"];
        }
    }

    static fromJS(data: any): GetEPCCodeDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetEPCCodeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["taiSanId"] = this.taiSanId;
        data["epcCode"] = this.epcCode;
        data["tenTaiSan"] = this.tenTaiSan;
        data["trangThaiId"] = this.trangThaiId;
        return data; 
    }

    clone(): GetEPCCodeDto {
        const json = this.toJSON();
        let result = new GetEPCCodeDto();
        result.init(json);
        return result;
    }
}

export interface IGetEPCCodeDto {
    taiSanId: number;
    epcCode: string | undefined;
    tenTaiSan: string | undefined;
    trangThaiId: number;
}

export class ThongTinKiemKeForMobileDto implements IThongTinKiemKeForMobileDto {
    kiemKeId: number;
    ngayKiemKe: moment.Moment;
    phongBanKiemKe: string | undefined;
    trangThaiKiemKe: number;
    thanhVienKiemKe: string[] | undefined;
    viTriDiaLyId: number;

    constructor(data?: IThongTinKiemKeForMobileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.kiemKeId = _data["kiemKeId"];
            this.ngayKiemKe = _data["ngayKiemKe"] ? moment(_data["ngayKiemKe"].toString()) : <any>undefined;
            this.phongBanKiemKe = _data["phongBanKiemKe"];
            this.trangThaiKiemKe = _data["trangThaiKiemKe"];
            if (Array.isArray(_data["thanhVienKiemKe"])) {
                this.thanhVienKiemKe = [] as any;
                for (let item of _data["thanhVienKiemKe"])
                    this.thanhVienKiemKe.push(item);
            }
            this.viTriDiaLyId = _data["viTriDiaLyId"];
        }
    }

    static fromJS(data: any): ThongTinKiemKeForMobileDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThongTinKiemKeForMobileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["kiemKeId"] = this.kiemKeId;
        data["ngayKiemKe"] = this.ngayKiemKe ? this.ngayKiemKe.toISOString() : <any>undefined;
        data["phongBanKiemKe"] = this.phongBanKiemKe;
        data["trangThaiKiemKe"] = this.trangThaiKiemKe;
        if (Array.isArray(this.thanhVienKiemKe)) {
            data["thanhVienKiemKe"] = [];
            for (let item of this.thanhVienKiemKe)
                data["thanhVienKiemKe"].push(item);
        }
        data["viTriDiaLyId"] = this.viTriDiaLyId;
        return data; 
    }

    clone(): ThongTinKiemKeForMobileDto {
        const json = this.toJSON();
        let result = new ThongTinKiemKeForMobileDto();
        result.init(json);
        return result;
    }
}

export interface IThongTinKiemKeForMobileDto {
    kiemKeId: number;
    ngayKiemKe: moment.Moment;
    phongBanKiemKe: string | undefined;
    trangThaiKiemKe: number;
    thanhVienKiemKe: string[] | undefined;
    viTriDiaLyId: number;
}

export class FlatTreeSelectDto implements IFlatTreeSelectDto {
    id: number;
    parentId: number | undefined;
    displayName: string | undefined;

    constructor(data?: IFlatTreeSelectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.parentId = _data["parentId"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): FlatTreeSelectDto {
        data = typeof data === 'object' ? data : {};
        let result = new FlatTreeSelectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["parentId"] = this.parentId;
        data["displayName"] = this.displayName;
        return data; 
    }

    clone(): FlatTreeSelectDto {
        const json = this.toJSON();
        let result = new FlatTreeSelectDto();
        result.init(json);
        return result;
    }
}

export interface IFlatTreeSelectDto {
    id: number;
    parentId: number | undefined;
    displayName: string | undefined;
}

export class MailServer implements IMailServer {
    tenantId: number | undefined;
    email: string | undefined;
    password: string | undefined;
    host: string | undefined;
    port: string | undefined;
    capPhat: boolean;
    thuHoi: boolean;
    dieuChuyen: boolean;
    baoMat: boolean;
    baoHong: boolean;
    thanhLy: boolean;
    suaChuaBaoDuong: boolean;
    batDauKiemKe: boolean;
    ketThucKiemKe: boolean;
    hoanThanhPhieuDuTruMuaSam: boolean;
    huyBoPhieuDuTruMuaSam: boolean;
    ghiChu: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IMailServer) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.email = _data["email"];
            this.password = _data["password"];
            this.host = _data["host"];
            this.port = _data["port"];
            this.capPhat = _data["capPhat"];
            this.thuHoi = _data["thuHoi"];
            this.dieuChuyen = _data["dieuChuyen"];
            this.baoMat = _data["baoMat"];
            this.baoHong = _data["baoHong"];
            this.thanhLy = _data["thanhLy"];
            this.suaChuaBaoDuong = _data["suaChuaBaoDuong"];
            this.batDauKiemKe = _data["batDauKiemKe"];
            this.ketThucKiemKe = _data["ketThucKiemKe"];
            this.hoanThanhPhieuDuTruMuaSam = _data["hoanThanhPhieuDuTruMuaSam"];
            this.huyBoPhieuDuTruMuaSam = _data["huyBoPhieuDuTruMuaSam"];
            this.ghiChu = _data["ghiChu"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): MailServer {
        data = typeof data === 'object' ? data : {};
        let result = new MailServer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["email"] = this.email;
        data["password"] = this.password;
        data["host"] = this.host;
        data["port"] = this.port;
        data["capPhat"] = this.capPhat;
        data["thuHoi"] = this.thuHoi;
        data["dieuChuyen"] = this.dieuChuyen;
        data["baoMat"] = this.baoMat;
        data["baoHong"] = this.baoHong;
        data["thanhLy"] = this.thanhLy;
        data["suaChuaBaoDuong"] = this.suaChuaBaoDuong;
        data["batDauKiemKe"] = this.batDauKiemKe;
        data["ketThucKiemKe"] = this.ketThucKiemKe;
        data["hoanThanhPhieuDuTruMuaSam"] = this.hoanThanhPhieuDuTruMuaSam;
        data["huyBoPhieuDuTruMuaSam"] = this.huyBoPhieuDuTruMuaSam;
        data["ghiChu"] = this.ghiChu;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): MailServer {
        const json = this.toJSON();
        let result = new MailServer();
        result.init(json);
        return result;
    }
}

export interface IMailServer {
    tenantId: number | undefined;
    email: string | undefined;
    password: string | undefined;
    host: string | undefined;
    port: string | undefined;
    capPhat: boolean;
    thuHoi: boolean;
    dieuChuyen: boolean;
    baoMat: boolean;
    baoHong: boolean;
    thanhLy: boolean;
    suaChuaBaoDuong: boolean;
    batDauKiemKe: boolean;
    ketThucKiemKe: boolean;
    hoanThanhPhieuDuTruMuaSam: boolean;
    huyBoPhieuDuTruMuaSam: boolean;
    ghiChu: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class MailServerDto implements IMailServerDto {
    email: string | undefined;
    password: string | undefined;
    host: string | undefined;
    port: string | undefined;
    capPhat: boolean;
    thuHoi: boolean;
    dieuChuyen: boolean;
    baoMat: boolean;
    baoHong: boolean;
    thanhLy: boolean;
    suaChuaBaoDuong: boolean;
    batDauKiemKe: boolean;
    ketThucKiemKe: boolean;
    hoanThanhPhieuDuTruMuaSam: boolean;
    huyBoPhieuDuTruMuaSam: boolean;
    ghiChu: string | undefined;
    id: number;

    constructor(data?: IMailServerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.password = _data["password"];
            this.host = _data["host"];
            this.port = _data["port"];
            this.capPhat = _data["capPhat"];
            this.thuHoi = _data["thuHoi"];
            this.dieuChuyen = _data["dieuChuyen"];
            this.baoMat = _data["baoMat"];
            this.baoHong = _data["baoHong"];
            this.thanhLy = _data["thanhLy"];
            this.suaChuaBaoDuong = _data["suaChuaBaoDuong"];
            this.batDauKiemKe = _data["batDauKiemKe"];
            this.ketThucKiemKe = _data["ketThucKiemKe"];
            this.hoanThanhPhieuDuTruMuaSam = _data["hoanThanhPhieuDuTruMuaSam"];
            this.huyBoPhieuDuTruMuaSam = _data["huyBoPhieuDuTruMuaSam"];
            this.ghiChu = _data["ghiChu"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): MailServerDto {
        data = typeof data === 'object' ? data : {};
        let result = new MailServerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        data["host"] = this.host;
        data["port"] = this.port;
        data["capPhat"] = this.capPhat;
        data["thuHoi"] = this.thuHoi;
        data["dieuChuyen"] = this.dieuChuyen;
        data["baoMat"] = this.baoMat;
        data["baoHong"] = this.baoHong;
        data["thanhLy"] = this.thanhLy;
        data["suaChuaBaoDuong"] = this.suaChuaBaoDuong;
        data["batDauKiemKe"] = this.batDauKiemKe;
        data["ketThucKiemKe"] = this.ketThucKiemKe;
        data["hoanThanhPhieuDuTruMuaSam"] = this.hoanThanhPhieuDuTruMuaSam;
        data["huyBoPhieuDuTruMuaSam"] = this.huyBoPhieuDuTruMuaSam;
        data["ghiChu"] = this.ghiChu;
        data["id"] = this.id;
        return data; 
    }

    clone(): MailServerDto {
        const json = this.toJSON();
        let result = new MailServerDto();
        result.init(json);
        return result;
    }
}

export interface IMailServerDto {
    email: string | undefined;
    password: string | undefined;
    host: string | undefined;
    port: string | undefined;
    capPhat: boolean;
    thuHoi: boolean;
    dieuChuyen: boolean;
    baoMat: boolean;
    baoHong: boolean;
    thanhLy: boolean;
    suaChuaBaoDuong: boolean;
    batDauKiemKe: boolean;
    ketThucKiemKe: boolean;
    hoanThanhPhieuDuTruMuaSam: boolean;
    huyBoPhieuDuTruMuaSam: boolean;
    ghiChu: string | undefined;
    id: number;
}

export class TaiSanChuaSuDungForViewDto implements ITaiSanChuaSuDungForViewDto {
    tenTaiSan: string | undefined;
    loaiTaiSan: string | undefined;
    serialNumber: string | undefined;
    nhaCungCap: string | undefined;
    ngayMua: moment.Moment | undefined;
    nguyenGia: number | undefined;
    phongBanQuanLy: string | undefined;
    toChucId: number | undefined;
    maSuDung: string | undefined;
    viTriTaiSan: string | undefined;
    timeSort: moment.Moment | undefined;
    capPhat: boolean | undefined;
    dieuChuyen: boolean | undefined;
    thuHoi: boolean | undefined;
    ngayKhaiBao: moment.Moment | undefined;
    epcCode: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: ITaiSanChuaSuDungForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenTaiSan = _data["tenTaiSan"];
            this.loaiTaiSan = _data["loaiTaiSan"];
            this.serialNumber = _data["serialNumber"];
            this.nhaCungCap = _data["nhaCungCap"];
            this.ngayMua = _data["ngayMua"] ? moment(_data["ngayMua"].toString()) : <any>undefined;
            this.nguyenGia = _data["nguyenGia"];
            this.phongBanQuanLy = _data["phongBanQuanLy"];
            this.toChucId = _data["toChucId"];
            this.maSuDung = _data["maSuDung"];
            this.viTriTaiSan = _data["viTriTaiSan"];
            this.timeSort = _data["timeSort"] ? moment(_data["timeSort"].toString()) : <any>undefined;
            this.capPhat = _data["capPhat"];
            this.dieuChuyen = _data["dieuChuyen"];
            this.thuHoi = _data["thuHoi"];
            this.ngayKhaiBao = _data["ngayKhaiBao"] ? moment(_data["ngayKhaiBao"].toString()) : <any>undefined;
            this.epcCode = _data["epcCode"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TaiSanChuaSuDungForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new TaiSanChuaSuDungForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenTaiSan"] = this.tenTaiSan;
        data["loaiTaiSan"] = this.loaiTaiSan;
        data["serialNumber"] = this.serialNumber;
        data["nhaCungCap"] = this.nhaCungCap;
        data["ngayMua"] = this.ngayMua ? this.ngayMua.toISOString() : <any>undefined;
        data["nguyenGia"] = this.nguyenGia;
        data["phongBanQuanLy"] = this.phongBanQuanLy;
        data["toChucId"] = this.toChucId;
        data["maSuDung"] = this.maSuDung;
        data["viTriTaiSan"] = this.viTriTaiSan;
        data["timeSort"] = this.timeSort ? this.timeSort.toISOString() : <any>undefined;
        data["capPhat"] = this.capPhat;
        data["dieuChuyen"] = this.dieuChuyen;
        data["thuHoi"] = this.thuHoi;
        data["ngayKhaiBao"] = this.ngayKhaiBao ? this.ngayKhaiBao.toISOString() : <any>undefined;
        data["epcCode"] = this.epcCode;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): TaiSanChuaSuDungForViewDto {
        const json = this.toJSON();
        let result = new TaiSanChuaSuDungForViewDto();
        result.init(json);
        return result;
    }
}

export interface ITaiSanChuaSuDungForViewDto {
    tenTaiSan: string | undefined;
    loaiTaiSan: string | undefined;
    serialNumber: string | undefined;
    nhaCungCap: string | undefined;
    ngayMua: moment.Moment | undefined;
    nguyenGia: number | undefined;
    phongBanQuanLy: string | undefined;
    toChucId: number | undefined;
    maSuDung: string | undefined;
    viTriTaiSan: string | undefined;
    timeSort: moment.Moment | undefined;
    capPhat: boolean | undefined;
    dieuChuyen: boolean | undefined;
    thuHoi: boolean | undefined;
    ngayKhaiBao: moment.Moment | undefined;
    epcCode: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class ViewTaiSanHong implements IViewTaiSanHong {
    epcCode: string | undefined;
    tenTaiSan: string | undefined;
    loaiTaiSan: string | undefined;
    loaiTaiSanId: number | undefined;
    serialNumber: string | undefined;
    nhaCungCap: string | undefined;
    ngayMua: moment.Moment | undefined;
    ngayMuaStr: string | undefined;
    nguyenGia: number | undefined;
    nguyenGiaStr: string | undefined;
    phongBanQuanLy: string | undefined;
    phongBanQuanLyId: number | undefined;
    ngayKhaiBao: moment.Moment | undefined;
    nguyenNhan: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IViewTaiSanHong) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.epcCode = _data["epcCode"];
            this.tenTaiSan = _data["tenTaiSan"];
            this.loaiTaiSan = _data["loaiTaiSan"];
            this.loaiTaiSanId = _data["loaiTaiSanId"];
            this.serialNumber = _data["serialNumber"];
            this.nhaCungCap = _data["nhaCungCap"];
            this.ngayMua = _data["ngayMua"] ? moment(_data["ngayMua"].toString()) : <any>undefined;
            this.ngayMuaStr = _data["ngayMuaStr"];
            this.nguyenGia = _data["nguyenGia"];
            this.nguyenGiaStr = _data["nguyenGiaStr"];
            this.phongBanQuanLy = _data["phongBanQuanLy"];
            this.phongBanQuanLyId = _data["phongBanQuanLyId"];
            this.ngayKhaiBao = _data["ngayKhaiBao"] ? moment(_data["ngayKhaiBao"].toString()) : <any>undefined;
            this.nguyenNhan = _data["nguyenNhan"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ViewTaiSanHong {
        data = typeof data === 'object' ? data : {};
        let result = new ViewTaiSanHong();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["epcCode"] = this.epcCode;
        data["tenTaiSan"] = this.tenTaiSan;
        data["loaiTaiSan"] = this.loaiTaiSan;
        data["loaiTaiSanId"] = this.loaiTaiSanId;
        data["serialNumber"] = this.serialNumber;
        data["nhaCungCap"] = this.nhaCungCap;
        data["ngayMua"] = this.ngayMua ? this.ngayMua.toISOString() : <any>undefined;
        data["ngayMuaStr"] = this.ngayMuaStr;
        data["nguyenGia"] = this.nguyenGia;
        data["nguyenGiaStr"] = this.nguyenGiaStr;
        data["phongBanQuanLy"] = this.phongBanQuanLy;
        data["phongBanQuanLyId"] = this.phongBanQuanLyId;
        data["ngayKhaiBao"] = this.ngayKhaiBao ? this.ngayKhaiBao.toISOString() : <any>undefined;
        data["nguyenNhan"] = this.nguyenNhan;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): ViewTaiSanHong {
        const json = this.toJSON();
        let result = new ViewTaiSanHong();
        result.init(json);
        return result;
    }
}

export interface IViewTaiSanHong {
    epcCode: string | undefined;
    tenTaiSan: string | undefined;
    loaiTaiSan: string | undefined;
    loaiTaiSanId: number | undefined;
    serialNumber: string | undefined;
    nhaCungCap: string | undefined;
    ngayMua: moment.Moment | undefined;
    ngayMuaStr: string | undefined;
    nguyenGia: number | undefined;
    nguyenGiaStr: string | undefined;
    phongBanQuanLy: string | undefined;
    phongBanQuanLyId: number | undefined;
    ngayKhaiBao: moment.Moment | undefined;
    nguyenNhan: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class ViewTaiSanSuaChuaBaoDuong implements IViewTaiSanSuaChuaBaoDuong {
    epcCode: string | undefined;
    tenTaiSan: string | undefined;
    loaiTaiSan: string | undefined;
    loaiTaiSanId: number | undefined;
    nhaCungCap: string | undefined;
    nguyenGia: number | undefined;
    nguyenGiaStr: string | undefined;
    phongBanQuanLy: string | undefined;
    phongBanQuanLyId: number | undefined;
    hinhThuc: number | undefined;
    liDoSuaChuaBaoDuong: string | undefined;
    diaChiSuaChuaBaoDuong: string | undefined;
    thoiGianBatDau: moment.Moment | undefined;
    trangThai: number | undefined;
    phieuTaiSanChiTietId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IViewTaiSanSuaChuaBaoDuong) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.epcCode = _data["epcCode"];
            this.tenTaiSan = _data["tenTaiSan"];
            this.loaiTaiSan = _data["loaiTaiSan"];
            this.loaiTaiSanId = _data["loaiTaiSanId"];
            this.nhaCungCap = _data["nhaCungCap"];
            this.nguyenGia = _data["nguyenGia"];
            this.nguyenGiaStr = _data["nguyenGiaStr"];
            this.phongBanQuanLy = _data["phongBanQuanLy"];
            this.phongBanQuanLyId = _data["phongBanQuanLyId"];
            this.hinhThuc = _data["hinhThuc"];
            this.liDoSuaChuaBaoDuong = _data["liDoSuaChuaBaoDuong"];
            this.diaChiSuaChuaBaoDuong = _data["diaChiSuaChuaBaoDuong"];
            this.thoiGianBatDau = _data["thoiGianBatDau"] ? moment(_data["thoiGianBatDau"].toString()) : <any>undefined;
            this.trangThai = _data["trangThai"];
            this.phieuTaiSanChiTietId = _data["phieuTaiSanChiTietId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ViewTaiSanSuaChuaBaoDuong {
        data = typeof data === 'object' ? data : {};
        let result = new ViewTaiSanSuaChuaBaoDuong();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["epcCode"] = this.epcCode;
        data["tenTaiSan"] = this.tenTaiSan;
        data["loaiTaiSan"] = this.loaiTaiSan;
        data["loaiTaiSanId"] = this.loaiTaiSanId;
        data["nhaCungCap"] = this.nhaCungCap;
        data["nguyenGia"] = this.nguyenGia;
        data["nguyenGiaStr"] = this.nguyenGiaStr;
        data["phongBanQuanLy"] = this.phongBanQuanLy;
        data["phongBanQuanLyId"] = this.phongBanQuanLyId;
        data["hinhThuc"] = this.hinhThuc;
        data["liDoSuaChuaBaoDuong"] = this.liDoSuaChuaBaoDuong;
        data["diaChiSuaChuaBaoDuong"] = this.diaChiSuaChuaBaoDuong;
        data["thoiGianBatDau"] = this.thoiGianBatDau ? this.thoiGianBatDau.toISOString() : <any>undefined;
        data["trangThai"] = this.trangThai;
        data["phieuTaiSanChiTietId"] = this.phieuTaiSanChiTietId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): ViewTaiSanSuaChuaBaoDuong {
        const json = this.toJSON();
        let result = new ViewTaiSanSuaChuaBaoDuong();
        result.init(json);
        return result;
    }
}

export interface IViewTaiSanSuaChuaBaoDuong {
    epcCode: string | undefined;
    tenTaiSan: string | undefined;
    loaiTaiSan: string | undefined;
    loaiTaiSanId: number | undefined;
    nhaCungCap: string | undefined;
    nguyenGia: number | undefined;
    nguyenGiaStr: string | undefined;
    phongBanQuanLy: string | undefined;
    phongBanQuanLyId: number | undefined;
    hinhThuc: number | undefined;
    liDoSuaChuaBaoDuong: string | undefined;
    diaChiSuaChuaBaoDuong: string | undefined;
    thoiGianBatDau: moment.Moment | undefined;
    trangThai: number | undefined;
    phieuTaiSanChiTietId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class DuTruMuaSamOutPut implements IDuTruMuaSamOutPut {
    id: number;
    toChucId: number | undefined;
    tenPhongBan: string | undefined;
    maPhieu: string | undefined;
    tenPhieu: string | undefined;
    soLuongDeXuat: number | undefined;
    chiPhiDeXuat: number | undefined;
    nguoiLapPhieuId: number | undefined;
    nguoiLap: string | undefined;
    ngayLap: string | undefined;
    ngayLapDate: moment.Moment;
    ngayCapNhat: string | undefined;
    ngayCapNhatDate: moment.Moment | undefined;
    trangThai: string | undefined;
    trangThaiId: number | undefined;

    constructor(data?: IDuTruMuaSamOutPut) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.toChucId = _data["toChucId"];
            this.tenPhongBan = _data["tenPhongBan"];
            this.maPhieu = _data["maPhieu"];
            this.tenPhieu = _data["tenPhieu"];
            this.soLuongDeXuat = _data["soLuongDeXuat"];
            this.chiPhiDeXuat = _data["chiPhiDeXuat"];
            this.nguoiLapPhieuId = _data["nguoiLapPhieuId"];
            this.nguoiLap = _data["nguoiLap"];
            this.ngayLap = _data["ngayLap"];
            this.ngayLapDate = _data["ngayLapDate"] ? moment(_data["ngayLapDate"].toString()) : <any>undefined;
            this.ngayCapNhat = _data["ngayCapNhat"];
            this.ngayCapNhatDate = _data["ngayCapNhatDate"] ? moment(_data["ngayCapNhatDate"].toString()) : <any>undefined;
            this.trangThai = _data["trangThai"];
            this.trangThaiId = _data["trangThaiId"];
        }
    }

    static fromJS(data: any): DuTruMuaSamOutPut {
        data = typeof data === 'object' ? data : {};
        let result = new DuTruMuaSamOutPut();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["toChucId"] = this.toChucId;
        data["tenPhongBan"] = this.tenPhongBan;
        data["maPhieu"] = this.maPhieu;
        data["tenPhieu"] = this.tenPhieu;
        data["soLuongDeXuat"] = this.soLuongDeXuat;
        data["chiPhiDeXuat"] = this.chiPhiDeXuat;
        data["nguoiLapPhieuId"] = this.nguoiLapPhieuId;
        data["nguoiLap"] = this.nguoiLap;
        data["ngayLap"] = this.ngayLap;
        data["ngayLapDate"] = this.ngayLapDate ? this.ngayLapDate.toISOString() : <any>undefined;
        data["ngayCapNhat"] = this.ngayCapNhat;
        data["ngayCapNhatDate"] = this.ngayCapNhatDate ? this.ngayCapNhatDate.toISOString() : <any>undefined;
        data["trangThai"] = this.trangThai;
        data["trangThaiId"] = this.trangThaiId;
        return data; 
    }

    clone(): DuTruMuaSamOutPut {
        const json = this.toJSON();
        let result = new DuTruMuaSamOutPut();
        result.init(json);
        return result;
    }
}

export interface IDuTruMuaSamOutPut {
    id: number;
    toChucId: number | undefined;
    tenPhongBan: string | undefined;
    maPhieu: string | undefined;
    tenPhieu: string | undefined;
    soLuongDeXuat: number | undefined;
    chiPhiDeXuat: number | undefined;
    nguoiLapPhieuId: number | undefined;
    nguoiLap: string | undefined;
    ngayLap: string | undefined;
    ngayLapDate: moment.Moment;
    ngayCapNhat: string | undefined;
    ngayCapNhatDate: moment.Moment | undefined;
    trangThai: string | undefined;
    trangThaiId: number | undefined;
}

export class ViewTaiSanThanhLy implements IViewTaiSanThanhLy {
    epcCode: string | undefined;
    tenTaiSan: string | undefined;
    loaiTaiSan: string | undefined;
    loaiTaiSanId: number | undefined;
    serialNumber: string | undefined;
    nhaCungCap: string | undefined;
    ngayMua: moment.Moment | undefined;
    ngayMuaStr: string | undefined;
    nguyenGia: number | undefined;
    nguyenGiaStr: string | undefined;
    phongBanQuanLy: string | undefined;
    phongBanQuanLyId: number | undefined;
    ngayKhaiBao: moment.Moment | undefined;
    nguyenNhan: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IViewTaiSanThanhLy) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.epcCode = _data["epcCode"];
            this.tenTaiSan = _data["tenTaiSan"];
            this.loaiTaiSan = _data["loaiTaiSan"];
            this.loaiTaiSanId = _data["loaiTaiSanId"];
            this.serialNumber = _data["serialNumber"];
            this.nhaCungCap = _data["nhaCungCap"];
            this.ngayMua = _data["ngayMua"] ? moment(_data["ngayMua"].toString()) : <any>undefined;
            this.ngayMuaStr = _data["ngayMuaStr"];
            this.nguyenGia = _data["nguyenGia"];
            this.nguyenGiaStr = _data["nguyenGiaStr"];
            this.phongBanQuanLy = _data["phongBanQuanLy"];
            this.phongBanQuanLyId = _data["phongBanQuanLyId"];
            this.ngayKhaiBao = _data["ngayKhaiBao"] ? moment(_data["ngayKhaiBao"].toString()) : <any>undefined;
            this.nguyenNhan = _data["nguyenNhan"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ViewTaiSanThanhLy {
        data = typeof data === 'object' ? data : {};
        let result = new ViewTaiSanThanhLy();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["epcCode"] = this.epcCode;
        data["tenTaiSan"] = this.tenTaiSan;
        data["loaiTaiSan"] = this.loaiTaiSan;
        data["loaiTaiSanId"] = this.loaiTaiSanId;
        data["serialNumber"] = this.serialNumber;
        data["nhaCungCap"] = this.nhaCungCap;
        data["ngayMua"] = this.ngayMua ? this.ngayMua.toISOString() : <any>undefined;
        data["ngayMuaStr"] = this.ngayMuaStr;
        data["nguyenGia"] = this.nguyenGia;
        data["nguyenGiaStr"] = this.nguyenGiaStr;
        data["phongBanQuanLy"] = this.phongBanQuanLy;
        data["phongBanQuanLyId"] = this.phongBanQuanLyId;
        data["ngayKhaiBao"] = this.ngayKhaiBao ? this.ngayKhaiBao.toISOString() : <any>undefined;
        data["nguyenNhan"] = this.nguyenNhan;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): ViewTaiSanThanhLy {
        const json = this.toJSON();
        let result = new ViewTaiSanThanhLy();
        result.init(json);
        return result;
    }
}

export interface IViewTaiSanThanhLy {
    epcCode: string | undefined;
    tenTaiSan: string | undefined;
    loaiTaiSan: string | undefined;
    loaiTaiSanId: number | undefined;
    serialNumber: string | undefined;
    nhaCungCap: string | undefined;
    ngayMua: moment.Moment | undefined;
    ngayMuaStr: string | undefined;
    nguyenGia: number | undefined;
    nguyenGiaStr: string | undefined;
    phongBanQuanLy: string | undefined;
    phongBanQuanLyId: number | undefined;
    ngayKhaiBao: moment.Moment | undefined;
    nguyenNhan: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class NhaCungCap_File implements INhaCungCap_File {
    tenantId: number | undefined;
    nhaCungCapId: number | undefined;
    tenFile: string | undefined;
    linkFile: string | undefined;
    loaiFile: number | undefined;
    ghiChu: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: INhaCungCap_File) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.nhaCungCapId = _data["nhaCungCapId"];
            this.tenFile = _data["tenFile"];
            this.linkFile = _data["linkFile"];
            this.loaiFile = _data["loaiFile"];
            this.ghiChu = _data["ghiChu"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): NhaCungCap_File {
        data = typeof data === 'object' ? data : {};
        let result = new NhaCungCap_File();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["nhaCungCapId"] = this.nhaCungCapId;
        data["tenFile"] = this.tenFile;
        data["linkFile"] = this.linkFile;
        data["loaiFile"] = this.loaiFile;
        data["ghiChu"] = this.ghiChu;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): NhaCungCap_File {
        const json = this.toJSON();
        let result = new NhaCungCap_File();
        result.init(json);
        return result;
    }
}

export interface INhaCungCap_File {
    tenantId: number | undefined;
    nhaCungCapId: number | undefined;
    tenFile: string | undefined;
    linkFile: string | undefined;
    loaiFile: number | undefined;
    ghiChu: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class NhaCungCap implements INhaCungCap {
    tenantId: number | undefined;
    maNhaCungCap: string | undefined;
    tenNhaCungCap: string | undefined;
    diaChi: string | undefined;
    soDienThoai: string | undefined;
    maSoThue: string | undefined;
    linhVucKinhDoanhId: number | undefined;
    email: string | undefined;
    ghiChu: string | undefined;
    nhaCungCapDinhKemFileList: NhaCungCap_File[] | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: INhaCungCap) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.maNhaCungCap = _data["maNhaCungCap"];
            this.tenNhaCungCap = _data["tenNhaCungCap"];
            this.diaChi = _data["diaChi"];
            this.soDienThoai = _data["soDienThoai"];
            this.maSoThue = _data["maSoThue"];
            this.linhVucKinhDoanhId = _data["linhVucKinhDoanhId"];
            this.email = _data["email"];
            this.ghiChu = _data["ghiChu"];
            if (Array.isArray(_data["nhaCungCapDinhKemFileList"])) {
                this.nhaCungCapDinhKemFileList = [] as any;
                for (let item of _data["nhaCungCapDinhKemFileList"])
                    this.nhaCungCapDinhKemFileList.push(NhaCungCap_File.fromJS(item));
            }
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): NhaCungCap {
        data = typeof data === 'object' ? data : {};
        let result = new NhaCungCap();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["maNhaCungCap"] = this.maNhaCungCap;
        data["tenNhaCungCap"] = this.tenNhaCungCap;
        data["diaChi"] = this.diaChi;
        data["soDienThoai"] = this.soDienThoai;
        data["maSoThue"] = this.maSoThue;
        data["linhVucKinhDoanhId"] = this.linhVucKinhDoanhId;
        data["email"] = this.email;
        data["ghiChu"] = this.ghiChu;
        if (Array.isArray(this.nhaCungCapDinhKemFileList)) {
            data["nhaCungCapDinhKemFileList"] = [];
            for (let item of this.nhaCungCapDinhKemFileList)
                data["nhaCungCapDinhKemFileList"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): NhaCungCap {
        const json = this.toJSON();
        let result = new NhaCungCap();
        result.init(json);
        return result;
    }
}

export interface INhaCungCap {
    tenantId: number | undefined;
    maNhaCungCap: string | undefined;
    tenNhaCungCap: string | undefined;
    diaChi: string | undefined;
    soDienThoai: string | undefined;
    maSoThue: string | undefined;
    linhVucKinhDoanhId: number | undefined;
    email: string | undefined;
    ghiChu: string | undefined;
    nhaCungCapDinhKemFileList: NhaCungCap_File[] | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class NhaCungCapForViewDto implements INhaCungCapForViewDto {
    nhaCungCap: NhaCungCap;
    tenLinhVuc: string | undefined;

    constructor(data?: INhaCungCapForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.nhaCungCap = _data["nhaCungCap"] ? NhaCungCap.fromJS(_data["nhaCungCap"]) : <any>undefined;
            this.tenLinhVuc = _data["tenLinhVuc"];
        }
    }

    static fromJS(data: any): NhaCungCapForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new NhaCungCapForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nhaCungCap"] = this.nhaCungCap ? this.nhaCungCap.toJSON() : <any>undefined;
        data["tenLinhVuc"] = this.tenLinhVuc;
        return data; 
    }

    clone(): NhaCungCapForViewDto {
        const json = this.toJSON();
        let result = new NhaCungCapForViewDto();
        result.init(json);
        return result;
    }
}

export interface INhaCungCapForViewDto {
    nhaCungCap: NhaCungCap;
    tenLinhVuc: string | undefined;
}

export class NhaCungCapForViewDtoPagedResultDto implements INhaCungCapForViewDtoPagedResultDto {
    totalCount: number;
    items: NhaCungCapForViewDto[] | undefined;

    constructor(data?: INhaCungCapForViewDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(NhaCungCapForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): NhaCungCapForViewDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new NhaCungCapForViewDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): NhaCungCapForViewDtoPagedResultDto {
        const json = this.toJSON();
        let result = new NhaCungCapForViewDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface INhaCungCapForViewDtoPagedResultDto {
    totalCount: number;
    items: NhaCungCapForViewDto[] | undefined;
}

export class NhaCungCapCreateInputDto implements INhaCungCapCreateInputDto {
    maNhaCungCap: string | undefined;
    tenNhaCungCap: string | undefined;
    diaChi: string | undefined;
    soDienThoai: string | undefined;
    linhVucKinhDoanhId: number | undefined;
    maSoThue: string | undefined;
    email: string | undefined;
    ghiChu: string | undefined;
    listFile: NhaCungCap_File[] | undefined;
    id: number | undefined;

    constructor(data?: INhaCungCapCreateInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.maNhaCungCap = _data["maNhaCungCap"];
            this.tenNhaCungCap = _data["tenNhaCungCap"];
            this.diaChi = _data["diaChi"];
            this.soDienThoai = _data["soDienThoai"];
            this.linhVucKinhDoanhId = _data["linhVucKinhDoanhId"];
            this.maSoThue = _data["maSoThue"];
            this.email = _data["email"];
            this.ghiChu = _data["ghiChu"];
            if (Array.isArray(_data["listFile"])) {
                this.listFile = [] as any;
                for (let item of _data["listFile"])
                    this.listFile.push(NhaCungCap_File.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): NhaCungCapCreateInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new NhaCungCapCreateInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maNhaCungCap"] = this.maNhaCungCap;
        data["tenNhaCungCap"] = this.tenNhaCungCap;
        data["diaChi"] = this.diaChi;
        data["soDienThoai"] = this.soDienThoai;
        data["linhVucKinhDoanhId"] = this.linhVucKinhDoanhId;
        data["maSoThue"] = this.maSoThue;
        data["email"] = this.email;
        data["ghiChu"] = this.ghiChu;
        if (Array.isArray(this.listFile)) {
            data["listFile"] = [];
            for (let item of this.listFile)
                data["listFile"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data; 
    }

    clone(): NhaCungCapCreateInputDto {
        const json = this.toJSON();
        let result = new NhaCungCapCreateInputDto();
        result.init(json);
        return result;
    }
}

export interface INhaCungCapCreateInputDto {
    maNhaCungCap: string | undefined;
    tenNhaCungCap: string | undefined;
    diaChi: string | undefined;
    soDienThoai: string | undefined;
    linhVucKinhDoanhId: number | undefined;
    maSoThue: string | undefined;
    email: string | undefined;
    ghiChu: string | undefined;
    listFile: NhaCungCap_File[] | undefined;
    id: number | undefined;
}

export class NhaCungCapGetAllInputDto implements INhaCungCapGetAllInputDto {
    keyword: string | undefined;
    linhVuc: number | undefined;
    isSearch: boolean | undefined;
    sorting: string | undefined;
    skipCount: number;
    maxResultCount: number;

    constructor(data?: INhaCungCapGetAllInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.keyword = _data["keyword"];
            this.linhVuc = _data["linhVuc"];
            this.isSearch = _data["isSearch"];
            this.sorting = _data["sorting"];
            this.skipCount = _data["skipCount"];
            this.maxResultCount = _data["maxResultCount"];
        }
    }

    static fromJS(data: any): NhaCungCapGetAllInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new NhaCungCapGetAllInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["keyword"] = this.keyword;
        data["linhVuc"] = this.linhVuc;
        data["isSearch"] = this.isSearch;
        data["sorting"] = this.sorting;
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        return data; 
    }

    clone(): NhaCungCapGetAllInputDto {
        const json = this.toJSON();
        let result = new NhaCungCapGetAllInputDto();
        result.init(json);
        return result;
    }
}

export interface INhaCungCapGetAllInputDto {
    keyword: string | undefined;
    linhVuc: number | undefined;
    isSearch: boolean | undefined;
    sorting: string | undefined;
    skipCount: number;
    maxResultCount: number;
}

export class DuTruMuaSamOutPutPagedResultDto implements IDuTruMuaSamOutPutPagedResultDto {
    totalCount: number;
    items: DuTruMuaSamOutPut[] | undefined;

    constructor(data?: IDuTruMuaSamOutPutPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(DuTruMuaSamOutPut.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DuTruMuaSamOutPutPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new DuTruMuaSamOutPutPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): DuTruMuaSamOutPutPagedResultDto {
        const json = this.toJSON();
        let result = new DuTruMuaSamOutPutPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IDuTruMuaSamOutPutPagedResultDto {
    totalCount: number;
    items: DuTruMuaSamOutPut[] | undefined;
}

export class PhieuDuTruMuaSamChiTiet implements IPhieuDuTruMuaSamChiTiet {
    tenantId: number | undefined;
    phieuDuTruMuaSamId: number | undefined;
    tenTaiSan: string | undefined;
    productNumber: string | undefined;
    hangSanXuat: string | undefined;
    nhaCungCap: string | undefined;
    soLuong: number | undefined;
    donGia: number | undefined;
    ghiChu: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IPhieuDuTruMuaSamChiTiet) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.phieuDuTruMuaSamId = _data["phieuDuTruMuaSamId"];
            this.tenTaiSan = _data["tenTaiSan"];
            this.productNumber = _data["productNumber"];
            this.hangSanXuat = _data["hangSanXuat"];
            this.nhaCungCap = _data["nhaCungCap"];
            this.soLuong = _data["soLuong"];
            this.donGia = _data["donGia"];
            this.ghiChu = _data["ghiChu"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PhieuDuTruMuaSamChiTiet {
        data = typeof data === 'object' ? data : {};
        let result = new PhieuDuTruMuaSamChiTiet();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["phieuDuTruMuaSamId"] = this.phieuDuTruMuaSamId;
        data["tenTaiSan"] = this.tenTaiSan;
        data["productNumber"] = this.productNumber;
        data["hangSanXuat"] = this.hangSanXuat;
        data["nhaCungCap"] = this.nhaCungCap;
        data["soLuong"] = this.soLuong;
        data["donGia"] = this.donGia;
        data["ghiChu"] = this.ghiChu;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): PhieuDuTruMuaSamChiTiet {
        const json = this.toJSON();
        let result = new PhieuDuTruMuaSamChiTiet();
        result.init(json);
        return result;
    }
}

export interface IPhieuDuTruMuaSamChiTiet {
    tenantId: number | undefined;
    phieuDuTruMuaSamId: number | undefined;
    tenTaiSan: string | undefined;
    productNumber: string | undefined;
    hangSanXuat: string | undefined;
    nhaCungCap: string | undefined;
    soLuong: number | undefined;
    donGia: number | undefined;
    ghiChu: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class PhieuDuTruMuaSamDinhKemFile implements IPhieuDuTruMuaSamDinhKemFile {
    tenantId: number | undefined;
    phieuDuTruMuaSamId: number | undefined;
    tenFile: string | undefined;
    linkFile: string | undefined;
    phanLoaiId: number | undefined;
    ghiChu: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IPhieuDuTruMuaSamDinhKemFile) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.phieuDuTruMuaSamId = _data["phieuDuTruMuaSamId"];
            this.tenFile = _data["tenFile"];
            this.linkFile = _data["linkFile"];
            this.phanLoaiId = _data["phanLoaiId"];
            this.ghiChu = _data["ghiChu"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PhieuDuTruMuaSamDinhKemFile {
        data = typeof data === 'object' ? data : {};
        let result = new PhieuDuTruMuaSamDinhKemFile();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["phieuDuTruMuaSamId"] = this.phieuDuTruMuaSamId;
        data["tenFile"] = this.tenFile;
        data["linkFile"] = this.linkFile;
        data["phanLoaiId"] = this.phanLoaiId;
        data["ghiChu"] = this.ghiChu;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): PhieuDuTruMuaSamDinhKemFile {
        const json = this.toJSON();
        let result = new PhieuDuTruMuaSamDinhKemFile();
        result.init(json);
        return result;
    }
}

export interface IPhieuDuTruMuaSamDinhKemFile {
    tenantId: number | undefined;
    phieuDuTruMuaSamId: number | undefined;
    tenFile: string | undefined;
    linkFile: string | undefined;
    phanLoaiId: number | undefined;
    ghiChu: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class CreateDuTruInput implements ICreateDuTruInput {
    maPhieu: string | undefined;
    tenPhieu: string | undefined;
    toChucId: number | undefined;
    nguoiLapPhieuId: number | undefined;
    ngayLapPhieuStr: string | undefined;
    trangThaiId: number | undefined;
    listPhieuChiTiet: PhieuDuTruMuaSamChiTiet[] | undefined;
    listDinhKem: PhieuDuTruMuaSamDinhKemFile[] | undefined;
    id: number | undefined;

    constructor(data?: ICreateDuTruInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.maPhieu = _data["maPhieu"];
            this.tenPhieu = _data["tenPhieu"];
            this.toChucId = _data["toChucId"];
            this.nguoiLapPhieuId = _data["nguoiLapPhieuId"];
            this.ngayLapPhieuStr = _data["ngayLapPhieuStr"];
            this.trangThaiId = _data["trangThaiId"];
            if (Array.isArray(_data["listPhieuChiTiet"])) {
                this.listPhieuChiTiet = [] as any;
                for (let item of _data["listPhieuChiTiet"])
                    this.listPhieuChiTiet.push(PhieuDuTruMuaSamChiTiet.fromJS(item));
            }
            if (Array.isArray(_data["listDinhKem"])) {
                this.listDinhKem = [] as any;
                for (let item of _data["listDinhKem"])
                    this.listDinhKem.push(PhieuDuTruMuaSamDinhKemFile.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateDuTruInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateDuTruInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maPhieu"] = this.maPhieu;
        data["tenPhieu"] = this.tenPhieu;
        data["toChucId"] = this.toChucId;
        data["nguoiLapPhieuId"] = this.nguoiLapPhieuId;
        data["ngayLapPhieuStr"] = this.ngayLapPhieuStr;
        data["trangThaiId"] = this.trangThaiId;
        if (Array.isArray(this.listPhieuChiTiet)) {
            data["listPhieuChiTiet"] = [];
            for (let item of this.listPhieuChiTiet)
                data["listPhieuChiTiet"].push(item.toJSON());
        }
        if (Array.isArray(this.listDinhKem)) {
            data["listDinhKem"] = [];
            for (let item of this.listDinhKem)
                data["listDinhKem"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data; 
    }

    clone(): CreateDuTruInput {
        const json = this.toJSON();
        let result = new CreateDuTruInput();
        result.init(json);
        return result;
    }
}

export interface ICreateDuTruInput {
    maPhieu: string | undefined;
    tenPhieu: string | undefined;
    toChucId: number | undefined;
    nguoiLapPhieuId: number | undefined;
    ngayLapPhieuStr: string | undefined;
    trangThaiId: number | undefined;
    listPhieuChiTiet: PhieuDuTruMuaSamChiTiet[] | undefined;
    listDinhKem: PhieuDuTruMuaSamDinhKemFile[] | undefined;
    id: number | undefined;
}

export class DuTruMuaSamInput implements IDuTruMuaSamInput {
    keyword: string | undefined;
    phongBan: number[] | undefined;
    isSearch: boolean | undefined;
    sorting: string | undefined;
    skipCount: number;
    maxResultCount: number;

    constructor(data?: IDuTruMuaSamInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.keyword = _data["keyword"];
            if (Array.isArray(_data["phongBan"])) {
                this.phongBan = [] as any;
                for (let item of _data["phongBan"])
                    this.phongBan.push(item);
            }
            this.isSearch = _data["isSearch"];
            this.sorting = _data["sorting"];
            this.skipCount = _data["skipCount"];
            this.maxResultCount = _data["maxResultCount"];
        }
    }

    static fromJS(data: any): DuTruMuaSamInput {
        data = typeof data === 'object' ? data : {};
        let result = new DuTruMuaSamInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["keyword"] = this.keyword;
        if (Array.isArray(this.phongBan)) {
            data["phongBan"] = [];
            for (let item of this.phongBan)
                data["phongBan"].push(item);
        }
        data["isSearch"] = this.isSearch;
        data["sorting"] = this.sorting;
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        return data; 
    }

    clone(): DuTruMuaSamInput {
        const json = this.toJSON();
        let result = new DuTruMuaSamInput();
        result.init(json);
        return result;
    }
}

export interface IDuTruMuaSamInput {
    keyword: string | undefined;
    phongBan: number[] | undefined;
    isSearch: boolean | undefined;
    sorting: string | undefined;
    skipCount: number;
    maxResultCount: number;
}

export class RoleDto implements IRoleDto {
    name: string;
    displayName: string;
    normalizedName: string | undefined;
    description: string | undefined;
    grantedPermissions: string[] | undefined;
    id: number;

    constructor(data?: IRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.normalizedName = _data["normalizedName"];
            this.description = _data["description"];
            if (Array.isArray(_data["grantedPermissions"])) {
                this.grantedPermissions = [] as any;
                for (let item of _data["grantedPermissions"])
                    this.grantedPermissions.push(item);
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): RoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["normalizedName"] = this.normalizedName;
        data["description"] = this.description;
        if (Array.isArray(this.grantedPermissions)) {
            data["grantedPermissions"] = [];
            for (let item of this.grantedPermissions)
                data["grantedPermissions"].push(item);
        }
        data["id"] = this.id;
        return data; 
    }

    clone(): RoleDto {
        const json = this.toJSON();
        let result = new RoleDto();
        result.init(json);
        return result;
    }
}

export interface IRoleDto {
    name: string;
    displayName: string;
    normalizedName: string | undefined;
    description: string | undefined;
    grantedPermissions: string[] | undefined;
    id: number;
}

export class RoleDtoPagedResultDto implements IRoleDtoPagedResultDto {
    totalCount: number;
    items: RoleDto[] | undefined;

    constructor(data?: IRoleDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(RoleDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RoleDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): RoleDtoPagedResultDto {
        const json = this.toJSON();
        let result = new RoleDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IRoleDtoPagedResultDto {
    totalCount: number;
    items: RoleDto[] | undefined;
}

export class CreateRoleDto implements ICreateRoleDto {
    name: string;
    displayName: string;
    normalizedName: string | undefined;
    description: string | undefined;
    grantedPermissions: string[] | undefined;

    constructor(data?: ICreateRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.normalizedName = _data["normalizedName"];
            this.description = _data["description"];
            if (Array.isArray(_data["grantedPermissions"])) {
                this.grantedPermissions = [] as any;
                for (let item of _data["grantedPermissions"])
                    this.grantedPermissions.push(item);
            }
        }
    }

    static fromJS(data: any): CreateRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["normalizedName"] = this.normalizedName;
        data["description"] = this.description;
        if (Array.isArray(this.grantedPermissions)) {
            data["grantedPermissions"] = [];
            for (let item of this.grantedPermissions)
                data["grantedPermissions"].push(item);
        }
        return data; 
    }

    clone(): CreateRoleDto {
        const json = this.toJSON();
        let result = new CreateRoleDto();
        result.init(json);
        return result;
    }
}

export interface ICreateRoleDto {
    name: string;
    displayName: string;
    normalizedName: string | undefined;
    description: string | undefined;
    grantedPermissions: string[] | undefined;
}

export class RoleListDto implements IRoleListDto {
    name: string | undefined;
    displayName: string | undefined;
    isStatic: boolean;
    isDefault: boolean;
    creationTime: moment.Moment;
    id: number;

    constructor(data?: IRoleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.isStatic = _data["isStatic"];
            this.isDefault = _data["isDefault"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): RoleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["isStatic"] = this.isStatic;
        data["isDefault"] = this.isDefault;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): RoleListDto {
        const json = this.toJSON();
        let result = new RoleListDto();
        result.init(json);
        return result;
    }
}

export interface IRoleListDto {
    name: string | undefined;
    displayName: string | undefined;
    isStatic: boolean;
    isDefault: boolean;
    creationTime: moment.Moment;
    id: number;
}

export class RoleListDtoListResultDto implements IRoleListDtoListResultDto {
    items: RoleListDto[] | undefined;

    constructor(data?: IRoleListDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(RoleListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RoleListDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleListDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): RoleListDtoListResultDto {
        const json = this.toJSON();
        let result = new RoleListDtoListResultDto();
        result.init(json);
        return result;
    }
}

export interface IRoleListDtoListResultDto {
    items: RoleListDto[] | undefined;
}

export class PermissionDto implements IPermissionDto {
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    id: number;

    constructor(data?: IPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["id"] = this.id;
        return data; 
    }

    clone(): PermissionDto {
        const json = this.toJSON();
        let result = new PermissionDto();
        result.init(json);
        return result;
    }
}

export interface IPermissionDto {
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    id: number;
}

export class PermissionDtoListResultDto implements IPermissionDtoListResultDto {
    items: PermissionDto[] | undefined;

    constructor(data?: IPermissionDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(PermissionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PermissionDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PermissionDtoListResultDto {
        const json = this.toJSON();
        let result = new PermissionDtoListResultDto();
        result.init(json);
        return result;
    }
}

export interface IPermissionDtoListResultDto {
    items: PermissionDto[] | undefined;
}

export class RoleEditDto implements IRoleEditDto {
    name: string;
    displayName: string;
    description: string | undefined;
    isStatic: boolean;
    id: number;

    constructor(data?: IRoleEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            this.isStatic = _data["isStatic"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): RoleEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["isStatic"] = this.isStatic;
        data["id"] = this.id;
        return data; 
    }

    clone(): RoleEditDto {
        const json = this.toJSON();
        let result = new RoleEditDto();
        result.init(json);
        return result;
    }
}

export interface IRoleEditDto {
    name: string;
    displayName: string;
    description: string | undefined;
    isStatic: boolean;
    id: number;
}

export class FlatPermissionDto implements IFlatPermissionDto {
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;

    constructor(data?: IFlatPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): FlatPermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new FlatPermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        return data; 
    }

    clone(): FlatPermissionDto {
        const json = this.toJSON();
        let result = new FlatPermissionDto();
        result.init(json);
        return result;
    }
}

export interface IFlatPermissionDto {
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
}

export class GetRoleForEditOutput implements IGetRoleForEditOutput {
    role: RoleEditDto;
    permissions: FlatPermissionDto[] | undefined;
    grantedPermissionNames: string[] | undefined;

    constructor(data?: IGetRoleForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.role = _data["role"] ? RoleEditDto.fromJS(_data["role"]) : <any>undefined;
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions.push(FlatPermissionDto.fromJS(item));
            }
            if (Array.isArray(_data["grantedPermissionNames"])) {
                this.grantedPermissionNames = [] as any;
                for (let item of _data["grantedPermissionNames"])
                    this.grantedPermissionNames.push(item);
            }
        }
    }

    static fromJS(data: any): GetRoleForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRoleForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        if (Array.isArray(this.grantedPermissionNames)) {
            data["grantedPermissionNames"] = [];
            for (let item of this.grantedPermissionNames)
                data["grantedPermissionNames"].push(item);
        }
        return data; 
    }

    clone(): GetRoleForEditOutput {
        const json = this.toJSON();
        let result = new GetRoleForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetRoleForEditOutput {
    role: RoleEditDto;
    permissions: FlatPermissionDto[] | undefined;
    grantedPermissionNames: string[] | undefined;
}

export class ApplicationInfoDto implements IApplicationInfoDto {
    version: string | undefined;
    releaseDate: moment.Moment;
    features: { [key: string]: boolean; } | undefined;

    constructor(data?: IApplicationInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.version = _data["version"];
            this.releaseDate = _data["releaseDate"] ? moment(_data["releaseDate"].toString()) : <any>undefined;
            if (_data["features"]) {
                this.features = {} as any;
                for (let key in _data["features"]) {
                    if (_data["features"].hasOwnProperty(key))
                        this.features[key] = _data["features"][key];
                }
            }
        }
    }

    static fromJS(data: any): ApplicationInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["version"] = this.version;
        data["releaseDate"] = this.releaseDate ? this.releaseDate.toISOString() : <any>undefined;
        if (this.features) {
            data["features"] = {};
            for (let key in this.features) {
                if (this.features.hasOwnProperty(key))
                    data["features"][key] = this.features[key];
            }
        }
        return data; 
    }

    clone(): ApplicationInfoDto {
        const json = this.toJSON();
        let result = new ApplicationInfoDto();
        result.init(json);
        return result;
    }
}

export interface IApplicationInfoDto {
    version: string | undefined;
    releaseDate: moment.Moment;
    features: { [key: string]: boolean; } | undefined;
}

export class UserLoginInfoDto implements IUserLoginInfoDto {
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    id: number;

    constructor(data?: IUserLoginInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.userName = _data["userName"];
            this.emailAddress = _data["emailAddress"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserLoginInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserLoginInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["id"] = this.id;
        return data; 
    }

    clone(): UserLoginInfoDto {
        const json = this.toJSON();
        let result = new UserLoginInfoDto();
        result.init(json);
        return result;
    }
}

export interface IUserLoginInfoDto {
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    id: number;
}

export class TenantLoginInfoDto implements ITenantLoginInfoDto {
    tenancyName: string | undefined;
    name: string | undefined;
    id: number;

    constructor(data?: ITenantLoginInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
            this.name = _data["name"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TenantLoginInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantLoginInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["id"] = this.id;
        return data; 
    }

    clone(): TenantLoginInfoDto {
        const json = this.toJSON();
        let result = new TenantLoginInfoDto();
        result.init(json);
        return result;
    }
}

export interface ITenantLoginInfoDto {
    tenancyName: string | undefined;
    name: string | undefined;
    id: number;
}

export class GetCurrentLoginInformationsOutput implements IGetCurrentLoginInformationsOutput {
    application: ApplicationInfoDto;
    user: UserLoginInfoDto;
    tenant: TenantLoginInfoDto;

    constructor(data?: IGetCurrentLoginInformationsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.application = _data["application"] ? ApplicationInfoDto.fromJS(_data["application"]) : <any>undefined;
            this.user = _data["user"] ? UserLoginInfoDto.fromJS(_data["user"]) : <any>undefined;
            this.tenant = _data["tenant"] ? TenantLoginInfoDto.fromJS(_data["tenant"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetCurrentLoginInformationsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetCurrentLoginInformationsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["application"] = this.application ? this.application.toJSON() : <any>undefined;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["tenant"] = this.tenant ? this.tenant.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetCurrentLoginInformationsOutput {
        const json = this.toJSON();
        let result = new GetCurrentLoginInformationsOutput();
        result.init(json);
        return result;
    }
}

export interface IGetCurrentLoginInformationsOutput {
    application: ApplicationInfoDto;
    user: UserLoginInfoDto;
    tenant: TenantLoginInfoDto;
}

export class TaiSanChuaSuDungForViewDtoPagedResultDto implements ITaiSanChuaSuDungForViewDtoPagedResultDto {
    totalCount: number;
    items: TaiSanChuaSuDungForViewDto[] | undefined;

    constructor(data?: ITaiSanChuaSuDungForViewDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(TaiSanChuaSuDungForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TaiSanChuaSuDungForViewDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new TaiSanChuaSuDungForViewDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): TaiSanChuaSuDungForViewDtoPagedResultDto {
        const json = this.toJSON();
        let result = new TaiSanChuaSuDungForViewDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface ITaiSanChuaSuDungForViewDtoPagedResultDto {
    totalCount: number;
    items: TaiSanChuaSuDungForViewDto[] | undefined;
}

export class PhieuTaiSanChiTietDto implements IPhieuTaiSanChiTietDto {
    phieuTaiSanId: number | undefined;
    taiSanId: number | undefined;
    trangThaiId: number | undefined;
    viTriLapDat: number | undefined;
    ghiChu: string | undefined;
    id: number;

    constructor(data?: IPhieuTaiSanChiTietDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.phieuTaiSanId = _data["phieuTaiSanId"];
            this.taiSanId = _data["taiSanId"];
            this.trangThaiId = _data["trangThaiId"];
            this.viTriLapDat = _data["viTriLapDat"];
            this.ghiChu = _data["ghiChu"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PhieuTaiSanChiTietDto {
        data = typeof data === 'object' ? data : {};
        let result = new PhieuTaiSanChiTietDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["phieuTaiSanId"] = this.phieuTaiSanId;
        data["taiSanId"] = this.taiSanId;
        data["trangThaiId"] = this.trangThaiId;
        data["viTriLapDat"] = this.viTriLapDat;
        data["ghiChu"] = this.ghiChu;
        data["id"] = this.id;
        return data; 
    }

    clone(): PhieuTaiSanChiTietDto {
        const json = this.toJSON();
        let result = new PhieuTaiSanChiTietDto();
        result.init(json);
        return result;
    }
}

export interface IPhieuTaiSanChiTietDto {
    phieuTaiSanId: number | undefined;
    taiSanId: number | undefined;
    trangThaiId: number | undefined;
    viTriLapDat: number | undefined;
    ghiChu: string | undefined;
    id: number;
}

export class PhieuTaiSanCreateInputDto implements IPhieuTaiSanCreateInputDto {
    phanLoaiId: number | undefined;
    ngayKhaiBao: moment.Moment | undefined;
    nguoiKhaiBaoId: number | undefined;
    toChucKhaiBaoId: number | undefined;
    toChucDuocNhanId: number | undefined;
    noiDung: string | undefined;
    diaChi: string | undefined;
    ghiChu: string | undefined;
    phieuTaiSanChiTietList: PhieuTaiSanChiTietDto[] | undefined;
    id: number | undefined;

    constructor(data?: IPhieuTaiSanCreateInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.phanLoaiId = _data["phanLoaiId"];
            this.ngayKhaiBao = _data["ngayKhaiBao"] ? moment(_data["ngayKhaiBao"].toString()) : <any>undefined;
            this.nguoiKhaiBaoId = _data["nguoiKhaiBaoId"];
            this.toChucKhaiBaoId = _data["toChucKhaiBaoId"];
            this.toChucDuocNhanId = _data["toChucDuocNhanId"];
            this.noiDung = _data["noiDung"];
            this.diaChi = _data["diaChi"];
            this.ghiChu = _data["ghiChu"];
            if (Array.isArray(_data["phieuTaiSanChiTietList"])) {
                this.phieuTaiSanChiTietList = [] as any;
                for (let item of _data["phieuTaiSanChiTietList"])
                    this.phieuTaiSanChiTietList.push(PhieuTaiSanChiTietDto.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PhieuTaiSanCreateInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new PhieuTaiSanCreateInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["phanLoaiId"] = this.phanLoaiId;
        data["ngayKhaiBao"] = this.ngayKhaiBao ? this.ngayKhaiBao.toISOString() : <any>undefined;
        data["nguoiKhaiBaoId"] = this.nguoiKhaiBaoId;
        data["toChucKhaiBaoId"] = this.toChucKhaiBaoId;
        data["toChucDuocNhanId"] = this.toChucDuocNhanId;
        data["noiDung"] = this.noiDung;
        data["diaChi"] = this.diaChi;
        data["ghiChu"] = this.ghiChu;
        if (Array.isArray(this.phieuTaiSanChiTietList)) {
            data["phieuTaiSanChiTietList"] = [];
            for (let item of this.phieuTaiSanChiTietList)
                data["phieuTaiSanChiTietList"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data; 
    }

    clone(): PhieuTaiSanCreateInputDto {
        const json = this.toJSON();
        let result = new PhieuTaiSanCreateInputDto();
        result.init(json);
        return result;
    }
}

export interface IPhieuTaiSanCreateInputDto {
    phanLoaiId: number | undefined;
    ngayKhaiBao: moment.Moment | undefined;
    nguoiKhaiBaoId: number | undefined;
    toChucKhaiBaoId: number | undefined;
    toChucDuocNhanId: number | undefined;
    noiDung: string | undefined;
    diaChi: string | undefined;
    ghiChu: string | undefined;
    phieuTaiSanChiTietList: PhieuTaiSanChiTietDto[] | undefined;
    id: number | undefined;
}

export class EntityDto implements IEntityDto {
    id: number;

    constructor(data?: IEntityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): EntityDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }

    clone(): EntityDto {
        const json = this.toJSON();
        let result = new EntityDto();
        result.init(json);
        return result;
    }
}

export interface IEntityDto {
    id: number;
}

export class ViewTaiSanHongPagedResultDto implements IViewTaiSanHongPagedResultDto {
    totalCount: number;
    items: ViewTaiSanHong[] | undefined;

    constructor(data?: IViewTaiSanHongPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(ViewTaiSanHong.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ViewTaiSanHongPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ViewTaiSanHongPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ViewTaiSanHongPagedResultDto {
        const json = this.toJSON();
        let result = new ViewTaiSanHongPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IViewTaiSanHongPagedResultDto {
    totalCount: number;
    items: ViewTaiSanHong[] | undefined;
}

export class ViewTaiSan implements IViewTaiSan {
    tenTaiSan: string | undefined;
    serialNumber: string | undefined;
    loaiTaiSan: string | undefined;
    loaiTaiSanId: number | undefined;
    nhaCungCap: string | undefined;
    nguyenGia: number | undefined;
    phongBanQuanLy: string | undefined;
    phongBanQuanLyId: number | undefined;
    hinhThuc: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IViewTaiSan) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenTaiSan = _data["tenTaiSan"];
            this.serialNumber = _data["serialNumber"];
            this.loaiTaiSan = _data["loaiTaiSan"];
            this.loaiTaiSanId = _data["loaiTaiSanId"];
            this.nhaCungCap = _data["nhaCungCap"];
            this.nguyenGia = _data["nguyenGia"];
            this.phongBanQuanLy = _data["phongBanQuanLy"];
            this.phongBanQuanLyId = _data["phongBanQuanLyId"];
            this.hinhThuc = _data["hinhThuc"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ViewTaiSan {
        data = typeof data === 'object' ? data : {};
        let result = new ViewTaiSan();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenTaiSan"] = this.tenTaiSan;
        data["serialNumber"] = this.serialNumber;
        data["loaiTaiSan"] = this.loaiTaiSan;
        data["loaiTaiSanId"] = this.loaiTaiSanId;
        data["nhaCungCap"] = this.nhaCungCap;
        data["nguyenGia"] = this.nguyenGia;
        data["phongBanQuanLy"] = this.phongBanQuanLy;
        data["phongBanQuanLyId"] = this.phongBanQuanLyId;
        data["hinhThuc"] = this.hinhThuc;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): ViewTaiSan {
        const json = this.toJSON();
        let result = new ViewTaiSan();
        result.init(json);
        return result;
    }
}

export interface IViewTaiSan {
    tenTaiSan: string | undefined;
    serialNumber: string | undefined;
    loaiTaiSan: string | undefined;
    loaiTaiSanId: number | undefined;
    nhaCungCap: string | undefined;
    nguyenGia: number | undefined;
    phongBanQuanLy: string | undefined;
    phongBanQuanLyId: number | undefined;
    hinhThuc: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class ViewTaiSanPagedResultDto implements IViewTaiSanPagedResultDto {
    totalCount: number;
    items: ViewTaiSan[] | undefined;

    constructor(data?: IViewTaiSanPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(ViewTaiSan.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ViewTaiSanPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ViewTaiSanPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ViewTaiSanPagedResultDto {
        const json = this.toJSON();
        let result = new ViewTaiSanPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IViewTaiSanPagedResultDto {
    totalCount: number;
    items: ViewTaiSan[] | undefined;
}

export class ViewTaiSanHuy implements IViewTaiSanHuy {
    epcCode: string | undefined;
    tenTaiSan: string | undefined;
    loaiTaiSan: string | undefined;
    loaiTaiSanId: number | undefined;
    serialNumber: string | undefined;
    nhaCungCap: string | undefined;
    ngayMua: moment.Moment | undefined;
    ngayMuaStr: string | undefined;
    nguyenGia: number | undefined;
    nguyenGiaStr: string | undefined;
    phongBanQuanLy: string | undefined;
    phongBanQuanLyId: number | undefined;
    ngayKhaiBao: moment.Moment | undefined;
    nguyenNhan: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IViewTaiSanHuy) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.epcCode = _data["epcCode"];
            this.tenTaiSan = _data["tenTaiSan"];
            this.loaiTaiSan = _data["loaiTaiSan"];
            this.loaiTaiSanId = _data["loaiTaiSanId"];
            this.serialNumber = _data["serialNumber"];
            this.nhaCungCap = _data["nhaCungCap"];
            this.ngayMua = _data["ngayMua"] ? moment(_data["ngayMua"].toString()) : <any>undefined;
            this.ngayMuaStr = _data["ngayMuaStr"];
            this.nguyenGia = _data["nguyenGia"];
            this.nguyenGiaStr = _data["nguyenGiaStr"];
            this.phongBanQuanLy = _data["phongBanQuanLy"];
            this.phongBanQuanLyId = _data["phongBanQuanLyId"];
            this.ngayKhaiBao = _data["ngayKhaiBao"] ? moment(_data["ngayKhaiBao"].toString()) : <any>undefined;
            this.nguyenNhan = _data["nguyenNhan"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ViewTaiSanHuy {
        data = typeof data === 'object' ? data : {};
        let result = new ViewTaiSanHuy();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["epcCode"] = this.epcCode;
        data["tenTaiSan"] = this.tenTaiSan;
        data["loaiTaiSan"] = this.loaiTaiSan;
        data["loaiTaiSanId"] = this.loaiTaiSanId;
        data["serialNumber"] = this.serialNumber;
        data["nhaCungCap"] = this.nhaCungCap;
        data["ngayMua"] = this.ngayMua ? this.ngayMua.toISOString() : <any>undefined;
        data["ngayMuaStr"] = this.ngayMuaStr;
        data["nguyenGia"] = this.nguyenGia;
        data["nguyenGiaStr"] = this.nguyenGiaStr;
        data["phongBanQuanLy"] = this.phongBanQuanLy;
        data["phongBanQuanLyId"] = this.phongBanQuanLyId;
        data["ngayKhaiBao"] = this.ngayKhaiBao ? this.ngayKhaiBao.toISOString() : <any>undefined;
        data["nguyenNhan"] = this.nguyenNhan;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): ViewTaiSanHuy {
        const json = this.toJSON();
        let result = new ViewTaiSanHuy();
        result.init(json);
        return result;
    }
}

export interface IViewTaiSanHuy {
    epcCode: string | undefined;
    tenTaiSan: string | undefined;
    loaiTaiSan: string | undefined;
    loaiTaiSanId: number | undefined;
    serialNumber: string | undefined;
    nhaCungCap: string | undefined;
    ngayMua: moment.Moment | undefined;
    ngayMuaStr: string | undefined;
    nguyenGia: number | undefined;
    nguyenGiaStr: string | undefined;
    phongBanQuanLy: string | undefined;
    phongBanQuanLyId: number | undefined;
    ngayKhaiBao: moment.Moment | undefined;
    nguyenNhan: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class ViewTaiSanHuyPagedResultDto implements IViewTaiSanHuyPagedResultDto {
    totalCount: number;
    items: ViewTaiSanHuy[] | undefined;

    constructor(data?: IViewTaiSanHuyPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(ViewTaiSanHuy.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ViewTaiSanHuyPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ViewTaiSanHuyPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ViewTaiSanHuyPagedResultDto {
        const json = this.toJSON();
        let result = new ViewTaiSanHuyPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IViewTaiSanHuyPagedResultDto {
    totalCount: number;
    items: ViewTaiSanHuy[] | undefined;
}

export class ViewTaiSanMat implements IViewTaiSanMat {
    epcCode: string | undefined;
    tenTaiSan: string | undefined;
    loaiTaiSan: string | undefined;
    loaiTaiSanId: number | undefined;
    serialNumber: string | undefined;
    nhaCungCap: string | undefined;
    ngayMua: moment.Moment | undefined;
    ngayMuaStr: string | undefined;
    nguyenGia: number | undefined;
    nguyenGiaStr: string | undefined;
    phongBanQuanLy: string | undefined;
    phongBanQuanLyId: number | undefined;
    ngayKhaiBao: moment.Moment | undefined;
    nguyenNhan: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IViewTaiSanMat) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.epcCode = _data["epcCode"];
            this.tenTaiSan = _data["tenTaiSan"];
            this.loaiTaiSan = _data["loaiTaiSan"];
            this.loaiTaiSanId = _data["loaiTaiSanId"];
            this.serialNumber = _data["serialNumber"];
            this.nhaCungCap = _data["nhaCungCap"];
            this.ngayMua = _data["ngayMua"] ? moment(_data["ngayMua"].toString()) : <any>undefined;
            this.ngayMuaStr = _data["ngayMuaStr"];
            this.nguyenGia = _data["nguyenGia"];
            this.nguyenGiaStr = _data["nguyenGiaStr"];
            this.phongBanQuanLy = _data["phongBanQuanLy"];
            this.phongBanQuanLyId = _data["phongBanQuanLyId"];
            this.ngayKhaiBao = _data["ngayKhaiBao"] ? moment(_data["ngayKhaiBao"].toString()) : <any>undefined;
            this.nguyenNhan = _data["nguyenNhan"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ViewTaiSanMat {
        data = typeof data === 'object' ? data : {};
        let result = new ViewTaiSanMat();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["epcCode"] = this.epcCode;
        data["tenTaiSan"] = this.tenTaiSan;
        data["loaiTaiSan"] = this.loaiTaiSan;
        data["loaiTaiSanId"] = this.loaiTaiSanId;
        data["serialNumber"] = this.serialNumber;
        data["nhaCungCap"] = this.nhaCungCap;
        data["ngayMua"] = this.ngayMua ? this.ngayMua.toISOString() : <any>undefined;
        data["ngayMuaStr"] = this.ngayMuaStr;
        data["nguyenGia"] = this.nguyenGia;
        data["nguyenGiaStr"] = this.nguyenGiaStr;
        data["phongBanQuanLy"] = this.phongBanQuanLy;
        data["phongBanQuanLyId"] = this.phongBanQuanLyId;
        data["ngayKhaiBao"] = this.ngayKhaiBao ? this.ngayKhaiBao.toISOString() : <any>undefined;
        data["nguyenNhan"] = this.nguyenNhan;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): ViewTaiSanMat {
        const json = this.toJSON();
        let result = new ViewTaiSanMat();
        result.init(json);
        return result;
    }
}

export interface IViewTaiSanMat {
    epcCode: string | undefined;
    tenTaiSan: string | undefined;
    loaiTaiSan: string | undefined;
    loaiTaiSanId: number | undefined;
    serialNumber: string | undefined;
    nhaCungCap: string | undefined;
    ngayMua: moment.Moment | undefined;
    ngayMuaStr: string | undefined;
    nguyenGia: number | undefined;
    nguyenGiaStr: string | undefined;
    phongBanQuanLy: string | undefined;
    phongBanQuanLyId: number | undefined;
    ngayKhaiBao: moment.Moment | undefined;
    nguyenNhan: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class ViewTaiSanMatPagedResultDto implements IViewTaiSanMatPagedResultDto {
    totalCount: number;
    items: ViewTaiSanMat[] | undefined;

    constructor(data?: IViewTaiSanMatPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(ViewTaiSanMat.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ViewTaiSanMatPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ViewTaiSanMatPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ViewTaiSanMatPagedResultDto {
        const json = this.toJSON();
        let result = new ViewTaiSanMatPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IViewTaiSanMatPagedResultDto {
    totalCount: number;
    items: ViewTaiSanMat[] | undefined;
}

export class ViewTaiSanSuaChuaBaoDuongPagedResultDto implements IViewTaiSanSuaChuaBaoDuongPagedResultDto {
    totalCount: number;
    items: ViewTaiSanSuaChuaBaoDuong[] | undefined;

    constructor(data?: IViewTaiSanSuaChuaBaoDuongPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(ViewTaiSanSuaChuaBaoDuong.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ViewTaiSanSuaChuaBaoDuongPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ViewTaiSanSuaChuaBaoDuongPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ViewTaiSanSuaChuaBaoDuongPagedResultDto {
        const json = this.toJSON();
        let result = new ViewTaiSanSuaChuaBaoDuongPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IViewTaiSanSuaChuaBaoDuongPagedResultDto {
    totalCount: number;
    items: ViewTaiSanSuaChuaBaoDuong[] | undefined;
}

export class ViewTaiSanThanhLyPagedResultDto implements IViewTaiSanThanhLyPagedResultDto {
    totalCount: number;
    items: ViewTaiSanThanhLy[] | undefined;

    constructor(data?: IViewTaiSanThanhLyPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(ViewTaiSanThanhLy.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ViewTaiSanThanhLyPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ViewTaiSanThanhLyPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ViewTaiSanThanhLyPagedResultDto {
        const json = this.toJSON();
        let result = new ViewTaiSanThanhLyPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IViewTaiSanThanhLyPagedResultDto {
    totalCount: number;
    items: ViewTaiSanThanhLy[] | undefined;
}

export class CreateTenantDto implements ICreateTenantDto {
    tenancyName: string;
    name: string;
    adminEmailAddress: string;
    connectionString: string | undefined;
    isActive: boolean;

    constructor(data?: ICreateTenantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
            this.name = _data["name"];
            this.adminEmailAddress = _data["adminEmailAddress"];
            this.connectionString = _data["connectionString"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): CreateTenantDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTenantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["adminEmailAddress"] = this.adminEmailAddress;
        data["connectionString"] = this.connectionString;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): CreateTenantDto {
        const json = this.toJSON();
        let result = new CreateTenantDto();
        result.init(json);
        return result;
    }
}

export interface ICreateTenantDto {
    tenancyName: string;
    name: string;
    adminEmailAddress: string;
    connectionString: string | undefined;
    isActive: boolean;
}

export class TenantDto implements ITenantDto {
    tenancyName: string;
    name: string;
    isActive: boolean;
    id: number;

    constructor(data?: ITenantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
            this.name = _data["name"];
            this.isActive = _data["isActive"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TenantDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        data["id"] = this.id;
        return data; 
    }

    clone(): TenantDto {
        const json = this.toJSON();
        let result = new TenantDto();
        result.init(json);
        return result;
    }
}

export interface ITenantDto {
    tenancyName: string;
    name: string;
    isActive: boolean;
    id: number;
}

export class TenantDtoPagedResultDto implements ITenantDtoPagedResultDto {
    totalCount: number;
    items: TenantDto[] | undefined;

    constructor(data?: ITenantDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(TenantDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TenantDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): TenantDtoPagedResultDto {
        const json = this.toJSON();
        let result = new TenantDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface ITenantDtoPagedResultDto {
    totalCount: number;
    items: TenantDto[] | undefined;
}

export class GetAllInputDto implements IGetAllInputDto {
    fillter: string | undefined;
    phongBanqQL: number[] | undefined;
    loaiTS: number | undefined;
    nhaCungCap: number | undefined;
    tinhTrangSD: number | undefined;
    maSD: number | undefined;
    isSearch: boolean | undefined;
    sorting: string | undefined;
    skipCount: number;
    maxResultCount: number;

    constructor(data?: IGetAllInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fillter = _data["fillter"];
            if (Array.isArray(_data["phongBanqQL"])) {
                this.phongBanqQL = [] as any;
                for (let item of _data["phongBanqQL"])
                    this.phongBanqQL.push(item);
            }
            this.loaiTS = _data["loaiTS"];
            this.nhaCungCap = _data["nhaCungCap"];
            this.tinhTrangSD = _data["tinhTrangSD"];
            this.maSD = _data["maSD"];
            this.isSearch = _data["isSearch"];
            this.sorting = _data["sorting"];
            this.skipCount = _data["skipCount"];
            this.maxResultCount = _data["maxResultCount"];
        }
    }

    static fromJS(data: any): GetAllInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fillter"] = this.fillter;
        if (Array.isArray(this.phongBanqQL)) {
            data["phongBanqQL"] = [];
            for (let item of this.phongBanqQL)
                data["phongBanqQL"].push(item);
        }
        data["loaiTS"] = this.loaiTS;
        data["nhaCungCap"] = this.nhaCungCap;
        data["tinhTrangSD"] = this.tinhTrangSD;
        data["maSD"] = this.maSD;
        data["isSearch"] = this.isSearch;
        data["sorting"] = this.sorting;
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        return data; 
    }

    clone(): GetAllInputDto {
        const json = this.toJSON();
        let result = new GetAllInputDto();
        result.init(json);
        return result;
    }
}

export interface IGetAllInputDto {
    fillter: string | undefined;
    phongBanqQL: number[] | undefined;
    loaiTS: number | undefined;
    nhaCungCap: number | undefined;
    tinhTrangSD: number | undefined;
    maSD: number | undefined;
    isSearch: boolean | undefined;
    sorting: string | undefined;
    skipCount: number;
    maxResultCount: number;
}

export class ToChuc implements IToChuc {
    tenantId: number | undefined;
    maToChuc: string | undefined;
    tenToChuc: string | undefined;
    trucThuocToChucId: number | undefined;
    viTriDiaLyId: number | undefined;
    maHexa: string | undefined;
    ghiChu: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IToChuc) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.maToChuc = _data["maToChuc"];
            this.tenToChuc = _data["tenToChuc"];
            this.trucThuocToChucId = _data["trucThuocToChucId"];
            this.viTriDiaLyId = _data["viTriDiaLyId"];
            this.maHexa = _data["maHexa"];
            this.ghiChu = _data["ghiChu"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ToChuc {
        data = typeof data === 'object' ? data : {};
        let result = new ToChuc();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["maToChuc"] = this.maToChuc;
        data["tenToChuc"] = this.tenToChuc;
        data["trucThuocToChucId"] = this.trucThuocToChucId;
        data["viTriDiaLyId"] = this.viTriDiaLyId;
        data["maHexa"] = this.maHexa;
        data["ghiChu"] = this.ghiChu;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): ToChuc {
        const json = this.toJSON();
        let result = new ToChuc();
        result.init(json);
        return result;
    }
}

export interface IToChuc {
    tenantId: number | undefined;
    maToChuc: string | undefined;
    tenToChuc: string | undefined;
    trucThuocToChucId: number | undefined;
    viTriDiaLyId: number | undefined;
    maHexa: string | undefined;
    ghiChu: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class ToChucForViewDto implements IToChucForViewDto {
    toChuc: ToChuc;
    diaChi: string | undefined;
    maHe10: number;

    constructor(data?: IToChucForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.toChuc = _data["toChuc"] ? ToChuc.fromJS(_data["toChuc"]) : <any>undefined;
            this.diaChi = _data["diaChi"];
            this.maHe10 = _data["maHe10"];
        }
    }

    static fromJS(data: any): ToChucForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new ToChucForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["toChuc"] = this.toChuc ? this.toChuc.toJSON() : <any>undefined;
        data["diaChi"] = this.diaChi;
        data["maHe10"] = this.maHe10;
        return data; 
    }

    clone(): ToChucForViewDto {
        const json = this.toJSON();
        let result = new ToChucForViewDto();
        result.init(json);
        return result;
    }
}

export interface IToChucForViewDto {
    toChuc: ToChuc;
    diaChi: string | undefined;
    maHe10: number;
}

export class ToChucTreeTableForViewDto implements IToChucTreeTableForViewDto {
    data: ToChucForViewDto;
    children: ToChucTreeTableForViewDto[] | undefined;
    expanded: boolean;

    constructor(data?: IToChucTreeTableForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? ToChucForViewDto.fromJS(_data["data"]) : <any>undefined;
            if (Array.isArray(_data["children"])) {
                this.children = [] as any;
                for (let item of _data["children"])
                    this.children.push(ToChucTreeTableForViewDto.fromJS(item));
            }
            this.expanded = _data["expanded"];
        }
    }

    static fromJS(data: any): ToChucTreeTableForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new ToChucTreeTableForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        if (Array.isArray(this.children)) {
            data["children"] = [];
            for (let item of this.children)
                data["children"].push(item.toJSON());
        }
        data["expanded"] = this.expanded;
        return data; 
    }

    clone(): ToChucTreeTableForViewDto {
        const json = this.toJSON();
        let result = new ToChucTreeTableForViewDto();
        result.init(json);
        return result;
    }
}

export interface IToChucTreeTableForViewDto {
    data: ToChucForViewDto;
    children: ToChucTreeTableForViewDto[] | undefined;
    expanded: boolean;
}

export class ToChucCreateInputDto implements IToChucCreateInputDto {
    maToChuc: string | undefined;
    tenToChuc: string | undefined;
    maHexa: string | undefined;
    trucThuocToChucId: number | undefined;
    viTriDiaLyId: number | undefined;
    ghiChu: string | undefined;
    id: number | undefined;

    constructor(data?: IToChucCreateInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.maToChuc = _data["maToChuc"];
            this.tenToChuc = _data["tenToChuc"];
            this.maHexa = _data["maHexa"];
            this.trucThuocToChucId = _data["trucThuocToChucId"];
            this.viTriDiaLyId = _data["viTriDiaLyId"];
            this.ghiChu = _data["ghiChu"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ToChucCreateInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new ToChucCreateInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maToChuc"] = this.maToChuc;
        data["tenToChuc"] = this.tenToChuc;
        data["maHexa"] = this.maHexa;
        data["trucThuocToChucId"] = this.trucThuocToChucId;
        data["viTriDiaLyId"] = this.viTriDiaLyId;
        data["ghiChu"] = this.ghiChu;
        data["id"] = this.id;
        return data; 
    }

    clone(): ToChucCreateInputDto {
        const json = this.toJSON();
        let result = new ToChucCreateInputDto();
        result.init(json);
        return result;
    }
}

export interface IToChucCreateInputDto {
    maToChuc: string | undefined;
    tenToChuc: string | undefined;
    maHexa: string | undefined;
    trucThuocToChucId: number | undefined;
    viTriDiaLyId: number | undefined;
    ghiChu: string | undefined;
    id: number | undefined;
}

export class ToChucGetAllInputDto implements IToChucGetAllInputDto {
    keyword: string | undefined;
    isSearch: boolean | undefined;

    constructor(data?: IToChucGetAllInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.keyword = _data["keyword"];
            this.isSearch = _data["isSearch"];
        }
    }

    static fromJS(data: any): ToChucGetAllInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new ToChucGetAllInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["keyword"] = this.keyword;
        data["isSearch"] = this.isSearch;
        return data; 
    }

    clone(): ToChucGetAllInputDto {
        const json = this.toJSON();
        let result = new ToChucGetAllInputDto();
        result.init(json);
        return result;
    }
}

export interface IToChucGetAllInputDto {
    keyword: string | undefined;
    isSearch: boolean | undefined;
}

export class ToChucForExportDto implements IToChucForExportDto {
    maToChuc: string | undefined;
    tenToChuc: string | undefined;
    diaChi: string | undefined;
    boiDam: boolean;

    constructor(data?: IToChucForExportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.maToChuc = _data["maToChuc"];
            this.tenToChuc = _data["tenToChuc"];
            this.diaChi = _data["diaChi"];
            this.boiDam = _data["boiDam"];
        }
    }

    static fromJS(data: any): ToChucForExportDto {
        data = typeof data === 'object' ? data : {};
        let result = new ToChucForExportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maToChuc"] = this.maToChuc;
        data["tenToChuc"] = this.tenToChuc;
        data["diaChi"] = this.diaChi;
        data["boiDam"] = this.boiDam;
        return data; 
    }

    clone(): ToChucForExportDto {
        const json = this.toJSON();
        let result = new ToChucForExportDto();
        result.init(json);
        return result;
    }
}

export interface IToChucForExportDto {
    maToChuc: string | undefined;
    tenToChuc: string | undefined;
    diaChi: string | undefined;
    boiDam: boolean;
}

export class AuthenticateModel implements IAuthenticateModel {
    userNameOrEmailAddress: string;
    password: string;
    rememberClient: boolean;

    constructor(data?: IAuthenticateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userNameOrEmailAddress = _data["userNameOrEmailAddress"];
            this.password = _data["password"];
            this.rememberClient = _data["rememberClient"];
        }
    }

    static fromJS(data: any): AuthenticateModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userNameOrEmailAddress"] = this.userNameOrEmailAddress;
        data["password"] = this.password;
        data["rememberClient"] = this.rememberClient;
        return data; 
    }

    clone(): AuthenticateModel {
        const json = this.toJSON();
        let result = new AuthenticateModel();
        result.init(json);
        return result;
    }
}

export interface IAuthenticateModel {
    userNameOrEmailAddress: string;
    password: string;
    rememberClient: boolean;
}

export class AuthenticateResultModel implements IAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
    userId: number;

    constructor(data?: IAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"];
            this.encryptedAccessToken = _data["encryptedAccessToken"];
            this.expireInSeconds = _data["expireInSeconds"];
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): AuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["userId"] = this.userId;
        return data; 
    }

    clone(): AuthenticateResultModel {
        const json = this.toJSON();
        let result = new AuthenticateResultModel();
        result.init(json);
        return result;
    }
}

export interface IAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
    userId: number;
}

export class ExternalLoginProviderInfoModel implements IExternalLoginProviderInfoModel {
    name: string | undefined;
    clientId: string | undefined;

    constructor(data?: IExternalLoginProviderInfoModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.clientId = _data["clientId"];
        }
    }

    static fromJS(data: any): ExternalLoginProviderInfoModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalLoginProviderInfoModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["clientId"] = this.clientId;
        return data; 
    }

    clone(): ExternalLoginProviderInfoModel {
        const json = this.toJSON();
        let result = new ExternalLoginProviderInfoModel();
        result.init(json);
        return result;
    }
}

export interface IExternalLoginProviderInfoModel {
    name: string | undefined;
    clientId: string | undefined;
}

export class ExternalAuthenticateModel implements IExternalAuthenticateModel {
    authProvider: string;
    providerKey: string;
    providerAccessCode: string;

    constructor(data?: IExternalAuthenticateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.authProvider = _data["authProvider"];
            this.providerKey = _data["providerKey"];
            this.providerAccessCode = _data["providerAccessCode"];
        }
    }

    static fromJS(data: any): ExternalAuthenticateModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalAuthenticateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["authProvider"] = this.authProvider;
        data["providerKey"] = this.providerKey;
        data["providerAccessCode"] = this.providerAccessCode;
        return data; 
    }

    clone(): ExternalAuthenticateModel {
        const json = this.toJSON();
        let result = new ExternalAuthenticateModel();
        result.init(json);
        return result;
    }
}

export interface IExternalAuthenticateModel {
    authProvider: string;
    providerKey: string;
    providerAccessCode: string;
}

export class ExternalAuthenticateResultModel implements IExternalAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
    waitingForActivation: boolean;

    constructor(data?: IExternalAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"];
            this.encryptedAccessToken = _data["encryptedAccessToken"];
            this.expireInSeconds = _data["expireInSeconds"];
            this.waitingForActivation = _data["waitingForActivation"];
        }
    }

    static fromJS(data: any): ExternalAuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalAuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["waitingForActivation"] = this.waitingForActivation;
        return data; 
    }

    clone(): ExternalAuthenticateResultModel {
        const json = this.toJSON();
        let result = new ExternalAuthenticateResultModel();
        result.init(json);
        return result;
    }
}

export interface IExternalAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
    waitingForActivation: boolean;
}

export class UserDtoPagedResultDto implements IUserDtoPagedResultDto {
    totalCount: number;
    items: UserDto[] | undefined;

    constructor(data?: IUserDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(UserDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UserDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): UserDtoPagedResultDto {
        const json = this.toJSON();
        let result = new UserDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IUserDtoPagedResultDto {
    totalCount: number;
    items: UserDto[] | undefined;
}

export class CreateUserDto implements ICreateUserDto {
    userName: string;
    name: string;
    surname: string;
    emailAddress: string;
    isActive: boolean;
    roleNames: string[] | undefined;
    password: string;
    toChucId: number | undefined;
    chucVu: string | undefined;
    phoneNumber: string | undefined;
    ghiChu: string | undefined;

    constructor(data?: ICreateUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.emailAddress = _data["emailAddress"];
            this.isActive = _data["isActive"];
            if (Array.isArray(_data["roleNames"])) {
                this.roleNames = [] as any;
                for (let item of _data["roleNames"])
                    this.roleNames.push(item);
            }
            this.password = _data["password"];
            this.toChucId = _data["toChucId"];
            this.chucVu = _data["chucVu"];
            this.phoneNumber = _data["phoneNumber"];
            this.ghiChu = _data["ghiChu"];
        }
    }

    static fromJS(data: any): CreateUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["emailAddress"] = this.emailAddress;
        data["isActive"] = this.isActive;
        if (Array.isArray(this.roleNames)) {
            data["roleNames"] = [];
            for (let item of this.roleNames)
                data["roleNames"].push(item);
        }
        data["password"] = this.password;
        data["toChucId"] = this.toChucId;
        data["chucVu"] = this.chucVu;
        data["phoneNumber"] = this.phoneNumber;
        data["ghiChu"] = this.ghiChu;
        return data; 
    }

    clone(): CreateUserDto {
        const json = this.toJSON();
        let result = new CreateUserDto();
        result.init(json);
        return result;
    }
}

export interface ICreateUserDto {
    userName: string;
    name: string;
    surname: string;
    emailAddress: string;
    isActive: boolean;
    roleNames: string[] | undefined;
    password: string;
    toChucId: number | undefined;
    chucVu: string | undefined;
    phoneNumber: string | undefined;
    ghiChu: string | undefined;
}

export class RoleDtoListResultDto implements IRoleDtoListResultDto {
    items: RoleDto[] | undefined;

    constructor(data?: IRoleDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(RoleDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RoleDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): RoleDtoListResultDto {
        const json = this.toJSON();
        let result = new RoleDtoListResultDto();
        result.init(json);
        return result;
    }
}

export interface IRoleDtoListResultDto {
    items: RoleDto[] | undefined;
}

export class ChangeUserLanguageDto implements IChangeUserLanguageDto {
    languageName: string;

    constructor(data?: IChangeUserLanguageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.languageName = _data["languageName"];
        }
    }

    static fromJS(data: any): ChangeUserLanguageDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeUserLanguageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["languageName"] = this.languageName;
        return data; 
    }

    clone(): ChangeUserLanguageDto {
        const json = this.toJSON();
        let result = new ChangeUserLanguageDto();
        result.init(json);
        return result;
    }
}

export interface IChangeUserLanguageDto {
    languageName: string;
}

export class ResetPasswordDto implements IResetPasswordDto {
    adminPassword: string;
    userId: number;
    newPassword: string;

    constructor(data?: IResetPasswordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.adminPassword = _data["adminPassword"];
            this.userId = _data["userId"];
            this.newPassword = _data["newPassword"];
        }
    }

    static fromJS(data: any): ResetPasswordDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["adminPassword"] = this.adminPassword;
        data["userId"] = this.userId;
        data["newPassword"] = this.newPassword;
        return data; 
    }

    clone(): ResetPasswordDto {
        const json = this.toJSON();
        let result = new ResetPasswordDto();
        result.init(json);
        return result;
    }
}

export interface IResetPasswordDto {
    adminPassword: string;
    userId: number;
    newPassword: string;
}

export class GetAllDtos implements IGetAllDtos {
    id: number;
    tenViTri: string | undefined;
    tinhThanh: string | undefined;
    quanHuyen: string | undefined;
    diaChi: string | undefined;
    ghiChu: string | undefined;
    ngayTao: moment.Moment;

    constructor(data?: IGetAllDtos) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenViTri = _data["tenViTri"];
            this.tinhThanh = _data["tinhThanh"];
            this.quanHuyen = _data["quanHuyen"];
            this.diaChi = _data["diaChi"];
            this.ghiChu = _data["ghiChu"];
            this.ngayTao = _data["ngayTao"] ? moment(_data["ngayTao"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): GetAllDtos {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllDtos();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenViTri"] = this.tenViTri;
        data["tinhThanh"] = this.tinhThanh;
        data["quanHuyen"] = this.quanHuyen;
        data["diaChi"] = this.diaChi;
        data["ghiChu"] = this.ghiChu;
        data["ngayTao"] = this.ngayTao ? this.ngayTao.toISOString() : <any>undefined;
        return data; 
    }

    clone(): GetAllDtos {
        const json = this.toJSON();
        let result = new GetAllDtos();
        result.init(json);
        return result;
    }
}

export interface IGetAllDtos {
    id: number;
    tenViTri: string | undefined;
    tinhThanh: string | undefined;
    quanHuyen: string | undefined;
    diaChi: string | undefined;
    ghiChu: string | undefined;
    ngayTao: moment.Moment;
}

export class GetAllDtosPagedResultDto implements IGetAllDtosPagedResultDto {
    totalCount: number;
    items: GetAllDtos[] | undefined;

    constructor(data?: IGetAllDtosPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(GetAllDtos.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetAllDtosPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllDtosPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): GetAllDtosPagedResultDto {
        const json = this.toJSON();
        let result = new GetAllDtosPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IGetAllDtosPagedResultDto {
    totalCount: number;
    items: GetAllDtos[] | undefined;
}

export class CreateOrEditDtos implements ICreateOrEditDtos {
    id: number | undefined;
    tenViTri: string | undefined;
    tinhThanh: number;
    quanHuyen: number;
    diaChi: string | undefined;
    ghiChu: string | undefined;

    constructor(data?: ICreateOrEditDtos) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenViTri = _data["tenViTri"];
            this.tinhThanh = _data["tinhThanh"];
            this.quanHuyen = _data["quanHuyen"];
            this.diaChi = _data["diaChi"];
            this.ghiChu = _data["ghiChu"];
        }
    }

    static fromJS(data: any): CreateOrEditDtos {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditDtos();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenViTri"] = this.tenViTri;
        data["tinhThanh"] = this.tinhThanh;
        data["quanHuyen"] = this.quanHuyen;
        data["diaChi"] = this.diaChi;
        data["ghiChu"] = this.ghiChu;
        return data; 
    }

    clone(): CreateOrEditDtos {
        const json = this.toJSON();
        let result = new CreateOrEditDtos();
        result.init(json);
        return result;
    }
}

export interface ICreateOrEditDtos {
    id: number | undefined;
    tenViTri: string | undefined;
    tinhThanh: number;
    quanHuyen: number;
    diaChi: string | undefined;
    ghiChu: string | undefined;
}

export class GetValueForView implements IGetValueForView {
    tenViTri: string | undefined;
    tinhThanh: number | undefined;
    quanHuyen: number | undefined;
    diaChi: string | undefined;
    ghiChu: string | undefined;

    constructor(data?: IGetValueForView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenViTri = _data["tenViTri"];
            this.tinhThanh = _data["tinhThanh"];
            this.quanHuyen = _data["quanHuyen"];
            this.diaChi = _data["diaChi"];
            this.ghiChu = _data["ghiChu"];
        }
    }

    static fromJS(data: any): GetValueForView {
        data = typeof data === 'object' ? data : {};
        let result = new GetValueForView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenViTri"] = this.tenViTri;
        data["tinhThanh"] = this.tinhThanh;
        data["quanHuyen"] = this.quanHuyen;
        data["diaChi"] = this.diaChi;
        data["ghiChu"] = this.ghiChu;
        return data; 
    }

    clone(): GetValueForView {
        const json = this.toJSON();
        let result = new GetValueForView();
        result.init(json);
        return result;
    }
}

export interface IGetValueForView {
    tenViTri: string | undefined;
    tinhThanh: number | undefined;
    quanHuyen: number | undefined;
    diaChi: string | undefined;
    ghiChu: string | undefined;
}

export class GetAllInPutDtos implements IGetAllInPutDtos {
    fillter: string | undefined;
    tinhThanh: number | undefined;
    quanHuyen: number | undefined;
    isSearch: boolean | undefined;
    sorting: string | undefined;
    skipCount: number;
    maxResultCount: number;

    constructor(data?: IGetAllInPutDtos) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fillter = _data["fillter"];
            this.tinhThanh = _data["tinhThanh"];
            this.quanHuyen = _data["quanHuyen"];
            this.isSearch = _data["isSearch"];
            this.sorting = _data["sorting"];
            this.skipCount = _data["skipCount"];
            this.maxResultCount = _data["maxResultCount"];
        }
    }

    static fromJS(data: any): GetAllInPutDtos {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllInPutDtos();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fillter"] = this.fillter;
        data["tinhThanh"] = this.tinhThanh;
        data["quanHuyen"] = this.quanHuyen;
        data["isSearch"] = this.isSearch;
        data["sorting"] = this.sorting;
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        return data; 
    }

    clone(): GetAllInPutDtos {
        const json = this.toJSON();
        let result = new GetAllInPutDtos();
        result.init(json);
        return result;
    }
}

export interface IGetAllInPutDtos {
    fillter: string | undefined;
    tinhThanh: number | undefined;
    quanHuyen: number | undefined;
    isSearch: boolean | undefined;
    sorting: string | undefined;
    skipCount: number;
    maxResultCount: number;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}